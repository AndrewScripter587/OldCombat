import {FileSystem} from "../sys/FileSystem.js"
import {McbError} from "../mcl/error/McbError.js"
import {Tokenizer} from "../mcl/Tokenizer.js"
import {TemplateRegisterer} from "../mcl/TemplateRegisterer.js"
import {Parser} from "../mcl/Parser.js"
import {LibStore} from "../mcl/LibStore.js"
import {Compiler, VariableMap} from "../mcl/Compiler.js"
import {Logger} from "./Logger.js"
import {Path} from "../haxe/io/Path.js"
import {HttpNodeJs} from "../haxe/http/HttpNodeJs.js"
import {StringMap} from "../haxe/ds/StringMap.js"
import {Unserializer} from "../haxe/Unserializer.js"
import {Template} from "../haxe/Template.js"
import {Exception} from "../haxe/Exception.js"
import {Register} from "../genes/Register.js"
import * as Fs from "fs"
import {Std} from "../Std.js"
import {SyncIo} from "../Io.js"
import {HxOverrides} from "../HxOverrides.js"

const $global = Register.$global

export const AppMain = Register.global("$hxClasses")["mcb.AppMain"] = 
class AppMain {
	static loadDebugProject(file, outdir) {
		let reader = new Unserializer(Fs.readFileSync(file, {"encoding": "utf8"}));
		while (true) {
			let item = reader.unserialize();
			if (item == null) {
				break;
			};
			let p = Path.join([outdir, item.f]);
			FileSystem.createDirectory(Path.directory(p));
			Fs.writeFileSync(p, item.s);
			Fs.writeFileSync(p + ".tokens", Std.string(item.t));
			Fs.writeFileSync(p + ".ast", Std.string(item.a));
		};
	}
	static discoverConfigFile(p) {
		if (FileSystem.exists(p + ".cjs")) {
			return p + ".cjs";
		} else if (FileSystem.exists(p + ".js")) {
			return p + ".js";
		} else if (FileSystem.exists(p + ".json")) {
			return p + ".json";
		} else {
			return p;
		};
	}
	static getFilesInDirectory(dir) {
		let files = Fs.readdirSync(dir);
		let result = [];
		let _g = 0;
		while (_g < files.length) {
			let f = files[_g];
			++_g;
			let p = Path.join([dir, f]);
			if (FileSystem.isDirectory(p)) {
				result = result.concat(AppMain.getFilesInDirectory(p));
			} else {
				result.push(p);
			};
		};
		return result;
	}
	static create(name) {
		let templateDir = Path.join([Path.directory(__filename), "template"]);
		let destDir = Path.join([Path.addTrailingSlash(process.cwd()), name]);
		FileSystem.createDirectory(destDir);
		let fetcher = new HttpNodeJs("https://raw.githubusercontent.com/misode/mcmeta/summary/version.json");
		fetcher.onData = function (data) {
			let version = JSON.parse(data);
			let copyDir = null;
			copyDir = function (from, to) {
				let _g = 0;
				let _g1 = Fs.readdirSync(from);
				while (_g < _g1.length) {
					let f = _g1[_g];
					++_g;
					let fromPath = Path.join([from, f]);
					let toPath = Path.join([to, f]);
					if (FileSystem.isDirectory(fromPath)) {
						FileSystem.createDirectory(toPath);
						copyDir(fromPath, toPath);
					} else {
						let template = new Template(Fs.readFileSync(fromPath, {"encoding": "utf8"}));
						let copyDir = name == null;
						Fs.writeFileSync(toPath, template.execute({"name": name, "version": version.data_pack_version}));
					};
				};
			};
			copyDir(templateDir, destDir);
		};
		fetcher.request();
	}
	static compile(opts) {
		Logger.log("Started build at " + HxOverrides.dateStr(new Date()));
		let startTime = Date.now() / 1000;
		let srcDir = Path.join([opts.baseDir, "src"]);
		let configPath = AppMain.discoverConfigFile(opts.configPath);
		let config;
		if (Fs.existsSync(configPath)) {
			try {
				config = require(configPath);
			}catch (_g) {
				let e = Exception.caught(_g);
				Logger.error("Failed to load config file: " + configPath);
				throw Exception.thrown(e);
			};
		} else {
			Logger.warn("Config file not found, using default config.");
			config = {};
		};
		let compiler = new Compiler(srcDir, config, new LibStore(opts.libDir));
		let didFail = true;
		try {
			compiler.config.events.onPreBuild.dispatch({});
			let sourceFiles = AppMain.getFilesInDirectory(srcDir);
			let _g = 0;
			while (_g < sourceFiles.length) {
				let f = sourceFiles[_g];
				++_g;
				let ext = Path.extension(f);
				if (ext != "mcb" && ext != "mcbt") {
					continue;
				};
				let tokens = Tokenizer.tokenize(Fs.readFileSync(f, {"encoding": "utf8"}), f);
				try {
					let ast = (ext == "mcb") ? Parser.parseMcbFile(tokens) : Parser.parseMcbtFile(tokens);
					compiler.addFile(f, ast);
				}catch (_g) {
					let e = Exception.caught(_g).unwrap();
					compiler.success = false;
					throw Exception.thrown(e);
				};
			};
			let _g1 = new StringMap();
			_g1.inst.set("config", config);
			_g1.inst.set("global", AppMain.globalJsData);
			_g1.inst.set("store", {});
			compiler.compile(new VariableMap(null, _g1));
			didFail = false;
		}catch (_g) {
			let e = Exception.caught(_g).unwrap();
			didFail = true;
			if (McbError.isMclError(e)) {
				let x = e;
				Logger.error(x.get_message());
			} else {
				Logger.error("A fatal error occurred during compilation. Please report this to the developers.");
				throw Exception.thrown(e);
			};
		};
		compiler.config.events.onPostBuild.dispatch({"success": !didFail});
		let endTime = Date.now() / 1000;
		Logger.log("Build finished in " + (endTime - startTime).toFixed(2) + " seconds");
		return compiler;
	}
	static doBuild(opts) {
		TemplateRegisterer.register();
		AppMain.watch = opts.watch;
		let cacheFile = Path.join([opts.baseDir, ".mcb", "fs-cache.txt"]);
		let cache;
		if (FileSystem.exists(cacheFile)) {
			let _g = new StringMap();
			let _g1 = 0;
			let _this = Fs.readFileSync(cacheFile, {"encoding": "utf8"}).split("\n");
			let result = new Array(_this.length);
			let _g2 = 0;
			let _g3 = _this.length;
			while (_g2 < _g3) {
				let i = _g2++;
				result[i] = _this[i].split(":");
			};
			let _g4 = result;
			while (_g1 < _g4.length) {
				let e = _g4[_g1];
				++_g1;
				if (e[0] != "") {
					_g.inst.set(e[0], e[1]);
				};
			};
			cache = _g;
		} else {
			cache = new StringMap();
		};
		let writeCache = function () {
			FileSystem.createDirectory(Path.directory(cacheFile));
			let _g = [];
			let map = cache;
			let _g_map = map;
			let _g_keys = map.keys();
			while (_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = _g_map.get(key);
				let _g_key = key;
				let k = _g_key;
				let v = _g_value;
				_g.push("" + k + ":" + v);
			};
			let content = _g.join("\n");
			Fs.writeFileSync(cacheFile, content);
		};
		let handleUpdatingFilesBasedOnCache = function (io) {
			let added = io.reportFilesAdded(cache);
			let removed = io.reportFilesRemoved(cache);
			let changed = io.reportFilesChanged(cache);
			let dirsToCheck = new Set();
			let _g = 0;
			while (_g < removed.length) {
				let f = removed[_g];
				++_g;
				if (FileSystem.exists(f)) {
					Fs.unlinkSync(f);
				};
				dirsToCheck.add(Path.directory(f));
			};
			let _g1 = [];
			let jsIterator = dirsToCheck.values();
			let _g_jsIterator = jsIterator;
			let _g_lastStep = jsIterator.next();
			while (!_g_lastStep.done) {
				let v = _g_lastStep.value;
				_g_lastStep = _g_jsIterator.next();
				let k = v;
				_g1.push(k);
			};
			let dirList = _g1;
			let deletedDirs = new Set();
			let _g2 = 0;
			while (_g2 < dirList.length) {
				let dir = dirList[_g2];
				++_g2;
				if (dir != "" && !deletedDirs.has(dir) && Fs.readdirSync(dir).length == 0) {
					if (FileSystem.exists(dir)) {
						let _g = 0;
						let _g1 = Fs.readdirSync(dir);
						while (_g < _g1.length) {
							let file = _g1[_g];
							++_g;
							let curPath = dir + "/" + file;
							if (FileSystem.isDirectory(curPath)) {
								if (FileSystem.exists(curPath)) {
									let _g = 0;
									let _g1 = Fs.readdirSync(curPath);
									while (_g < _g1.length) {
										let file = _g1[_g];
										++_g;
										let curPath1 = curPath + "/" + file;
										if (FileSystem.isDirectory(curPath1)) {
											FileSystem.deleteDirectory(curPath1);
										} else {
											Fs.unlinkSync(curPath1);
										};
									};
									Fs.rmdirSync(curPath);
								};
							} else {
								Fs.unlinkSync(curPath);
							};
						};
						Fs.rmdirSync(dir);
					};
					dirList.push(Path.join([dir, ".."]));
					deletedDirs.add(dir);
				};
			};
			cache = io.reportFileMetadata();
			writeCache();
		};
		let build = AppMain.compile(opts);
		if (build.success) {
			handleUpdatingFilesBasedOnCache(build.io);
		} else if (((build.io) instanceof SyncIo)) {
			let x = build.io;
			Logger.warn("Reverting file changes...");
			x.revertMap.revert();
		};
	}
	static generate(outfile, arg) {
		let configPath = AppMain.discoverConfigFile(arg.configPath);
		let config;
		if (Fs.existsSync(configPath)) {
			try {
				config = require(configPath);
			}catch (_g) {
				let e = Exception.caught(_g);
				Logger.error("Failed to load config file: " + configPath);
				throw Exception.thrown(e);
			};
		} else {
			Logger.warn("Config file not found, using default config.");
			config = {};
		};
		let compiler = new Compiler(arg.baseDir, config, new LibStore(arg.libDir));
		let tokens = Tokenizer.tokenize(Fs.readFileSync(outfile, {"encoding": "utf8"}), outfile);
		let ast = Parser.parseMcbFile(tokens);
		compiler.addFile(outfile, ast);
		let _g = new StringMap();
		_g.inst.set("config", config);
		_g.inst.set("global", AppMain.globalJsData);
		_g.inst.set("store", {});
		compiler.transform(new VariableMap(null, _g));
	}
	static get __name__() {
		return "mcb.AppMain"
	}
	get __class__() {
		return AppMain
	}
}


AppMain.globalJsData = {}
AppMain.watch = false