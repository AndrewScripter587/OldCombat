import {Tokenizer} from "./mcl/Tokenizer.js"
import {TemplateRegisterer} from "./mcl/TemplateRegisterer.js"
import {Parser} from "./mcl/Parser.js"
import {Compiler, VariableMap} from "./mcl/Compiler.js"
import {Path} from "./haxe/io/Path.js"
import {Exception} from "./haxe/Exception.js"
import {Register} from "./genes/Register.js"
import * as Fs from "fs"
import {SyncIo, ThreadedIo, MultiThreadIo} from "./Io.js"

const $global = Register.$global

export const LibMain = Register.global("$hxClasses")["LibMain"] = 
class LibMain {
	static main() {
		TemplateRegisterer.register();
	}
	static createCompiler(baseDir, config, libStore) {
		return new Compiler(baseDir, config, libStore);
	}
	static parseFile(path, content) {
		let ext = Path.extension(path);
		let tokens = Tokenizer.tokenize(content, path);
		if (ext == "mcb") {
			return Parser.parseMcbFile(tokens);
		} else if (ext == "mcbt") {
			return Parser.parseMcbtFile(tokens);
		} else {
			throw Exception.thrown("Unknown file extension: " + ext);
		};
	}
	static addFileToCompiler(compiler, path) {
		let ext = Path.extension(path);
		let tokens = Tokenizer.tokenize(Fs.readFileSync(path, {"encoding": "utf8"}), path);
		compiler.addFile(path, (ext == "mcb") ? Parser.parseMcbFile(tokens) : Parser.parseMcbtFile(tokens));
	}
	static compileFromFsLikeMap(baseDir, files, io) {
		let compiler = LibMain.createCompiler(baseDir, {}, null);
		let jsIterator = files.entries();
		let _g_jsIterator = jsIterator;
		let _g_lastStep = jsIterator.next();
		while (!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = _g_jsIterator.next();
			let path = v;
			let tokens = Tokenizer.tokenize(path[1], path[0]);
			let tmp = (Path.extension(path[0]) == "mcb") ? Parser.parseMcbFile(tokens) : Parser.parseMcbtFile(tokens);
			compiler.addFile(path[0], tmp);
		};
		compiler.io = io;
		compiler.compile(new VariableMap(null));
	}
	static createIoProvider(threadCount) {
		switch (threadCount) {
			case 0:
				return new SyncIo();
				break
			case 1:
				return new ThreadedIo();
				break
			default:
			return new MultiThreadIo(threadCount);
			
		};
	}
	static get __name__() {
		return "LibMain"
	}
	get __class__() {
		return LibMain
	}
}

