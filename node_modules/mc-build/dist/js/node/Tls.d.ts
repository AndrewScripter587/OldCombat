import {Socket} from "net"
import {Buffer} from "buffer"

export type TlsOptionsBase = {
	/**
	possible NPN protocols. (Protocols should be ordered by their priority).
	*/
	NPNProtocols?: null | string[] | Buffer, 
	/**
	If true the server will reject any connection which is not authorized with the list of supplied CAs.
	This option only has an effect if `requestCert` is true.
	Default: false.
	*/
	rejectUnauthorized?: null | boolean
}

export type TlsServerOptionsBase = {
	/**
	possible NPN protocols. (Protocols should be ordered by their priority).
	*/
	NPNProtocols?: null | string[] | Buffer, 
	/**
	A function that will be called if client supports SNI TLS extension.
	Two argument will be passed to it: `servername`, and `cb`.
	SNICallback should invoke `cb(null, ctx)`, where `ctx` is a SecureContext instance.
	(You can use tls.createSecureContext(...) to get proper `SecureContext`).
	If `SNICallback` wasn't provided - default callback with high-level API will be used.
	*/
	SNICallback?: null | ((servername: string, cb: ((arg0: Error) => SecureContext)) => void), 
	/**
	If true the server will reject any connection which is not authorized with the list of supplied CAs.
	This option only has an effect if `requestCert` is true.
	Default: false.
	*/
	rejectUnauthorized?: null | boolean, 
	/**
	If true the server will request a certificate from clients that connect
	and attempt to verify that certificate.
	Default: false.
	*/
	requestCert?: null | boolean
}

export type TlsClientOptionsBase = {
	/**
	possible NPN protocols. (Protocols should be ordered by their priority).
	*/
	NPNProtocols?: null | string[] | Buffer, 
	/**
	If true the server will reject any connection which is not authorized with the list of supplied CAs.
	This option only has an effect if `requestCert` is true.
	Default: false.
	*/
	rejectUnauthorized?: null | boolean, 
	/**
	If true - OCSP status request extension would be added to client hello,
	and OCSPResponse event will be emitted on socket before establishing secure communication
	*/
	requestOCSP?: null | boolean, 
	/**
	A Buffer instance, containing TLS session.
	*/
	session?: null | Buffer
}

/**
Base structure for options object used in tls methods.
*/
export type TlsCreateServerOptions = {
	/**
	possible NPN protocols. (Protocols should be ordered by their priority).
	*/
	NPNProtocols?: null | string[] | Buffer, 
	/**
	A function that will be called if client supports SNI TLS extension.
	Two argument will be passed to it: `servername`, and `cb`.
	SNICallback should invoke `cb(null, ctx)`, where `ctx` is a SecureContext instance.
	(You can use tls.createSecureContext(...) to get proper `SecureContext`).
	If `SNICallback` wasn't provided - default callback with high-level API will be used.
	*/
	SNICallback?: null | ((servername: string, cb: ((arg0: Error) => SecureContext)) => void), 
	/**
	trusted certificates in PEM format.
	If this is omitted several well known "root" CAs will be used, like VeriSign.
	These are used to authorize connections.
	*/
	ca?: null | string | Buffer[], 
	/**
	certificate key of the server in PEM format.
	*/
	cert?: null | string | Buffer, 
	/**
	ciphers to use or exclude.
	
	To mitigate BEAST attacks it is recommended that you use this option in conjunction with the `honorCipherOrder`
	option described below to prioritize the non-CBC cipher.
	
	Defaults to AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH.
	
	Consult the OpenSSL cipher list format documentation for details on the format.
	ECDH (Elliptic Curve Diffie-Hellman) ciphers are not yet supported.
	*/
	ciphers?: null | string, 
	/**
	PEM encoded CRLs (Certificate Revocation List)
	*/
	crl?: null | string | string[], 
	/**
	Diffie Hellman parameters, required for Perfect Forward Secrecy.
	
	Use openssl dhparam to create it. Its key length should be greater than or equal to 1024 bits,
	otherwise it throws an error. It is strongly recommended to use 2048 bits or more for stronger security.
	If omitted or invalid, it is silently discarded and DHE ciphers won't be available.
	*/
	dhparam?: null | string | Buffer, 
	/**
	named curve to use for ECDH key agreement or false to disable ECDH.
	
	Defaults to prime256v1 (NIST P-256). Use `Crypto.getCurves` to obtain a list of available curve names.
	On recent releases, openssl ecparam -list_curves will also display the name and description
	of each available elliptic curve.
	*/
	ecdhCurve?: null | string, 
	/**
	Abort the connection if the SSL/TLS handshake does not finish in this many milliseconds.
	The default is 120 seconds.
	A 'clientError' is emitted on the `tls.Server` object whenever a handshake times out.
	*/
	handshakeTimeout?: null | number, 
	/**
	When choosing a cipher, use the server's preferences instead of the client preferences.
	Default: true.
	*/
	honorCipherOrder?: null | boolean, 
	/**
	private key of the server in PEM format.
	*/
	key?: null | string | Buffer, 
	/**
	passphrase for the private key or pfx.
	*/
	passphrase?: null | string, 
	/**
	private key, certificate and CA certs of the server in PFX or PKCS12 format.
	*/
	pfx?: null | string | Buffer, 
	/**
	If true the server will reject any connection which is not authorized with the list of supplied CAs.
	This option only has an effect if `requestCert` is true.
	Default: false.
	*/
	rejectUnauthorized?: null | boolean, 
	/**
	If true the server will request a certificate from clients that connect
	and attempt to verify that certificate.
	Default: false.
	*/
	requestCert?: null | boolean, 
	/**
	The SSL method to use, e.g. SSLv3_method to force SSL version 3.
	The possible values depend on your installation of OpenSSL and are defined in the constant SSL_METHODS.
	*/
	secureProtocol?: null | string, 
	/**
	opaque identifier for session resumption.
	If `requestCert` is true, the default is MD5 hash value generated from command-line.
	Otherwise, the default is not provided.
	*/
	sessionIdContext?: null | string, 
	/**
	An integer specifying the seconds after which TLS session identifiers
	and TLS session tickets created by the server are timed out.
	See SSL_CTX_set_timeout for more details.
	*/
	sessionTimeout?: null | number, 
	/**
	A 48-byte `Buffer` instance consisting of 16-byte prefix, 16-byte hmac key, 16-byte AES key.
	You could use it to accept tls session tickets on multiple instances of tls server.
	
	NOTE: Automatically shared between cluster module workers.
	*/
	ticketKeys?: null | Buffer
}

export type TlsConnectOptions = {
	/**
	possible NPN protocols. (Protocols should be ordered by their priority).
	*/
	NPNProtocols?: null | string[] | Buffer, 
	/**
	trusted certificates in PEM format.
	If this is omitted several well known "root" CAs will be used, like VeriSign.
	These are used to authorize connections.
	*/
	ca?: null | string | Buffer[], 
	/**
	certificate key of the server in PEM format.
	*/
	cert?: null | string | Buffer, 
	/**
	An override for checking server's hostname against the certificate.
	Should return an error if verification fails. Return `js.Lib.undefined` if passing.
	*/
	checkServerIdentity?: null | ((arg0: string, arg1: {
	}) => any), 
	/**
	ciphers to use or exclude.
	
	To mitigate BEAST attacks it is recommended that you use this option in conjunction with the `honorCipherOrder`
	option described below to prioritize the non-CBC cipher.
	
	Defaults to AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH.
	
	Consult the OpenSSL cipher list format documentation for details on the format.
	ECDH (Elliptic Curve Diffie-Hellman) ciphers are not yet supported.
	*/
	ciphers?: null | string, 
	/**
	PEM encoded CRLs (Certificate Revocation List)
	*/
	crl?: null | string | string[], 
	/**
	Diffie Hellman parameters, required for Perfect Forward Secrecy.
	
	Use openssl dhparam to create it. Its key length should be greater than or equal to 1024 bits,
	otherwise it throws an error. It is strongly recommended to use 2048 bits or more for stronger security.
	If omitted or invalid, it is silently discarded and DHE ciphers won't be available.
	*/
	dhparam?: null | string | Buffer, 
	/**
	named curve to use for ECDH key agreement or false to disable ECDH.
	
	Defaults to prime256v1 (NIST P-256). Use `Crypto.getCurves` to obtain a list of available curve names.
	On recent releases, openssl ecparam -list_curves will also display the name and description
	of each available elliptic curve.
	*/
	ecdhCurve?: null | string, 
	/**
	When choosing a cipher, use the server's preferences instead of the client preferences.
	Default: true.
	*/
	honorCipherOrder?: null | boolean, 
	/**
	Host the client should connect to.
	Defaults to 'localhost'
	*/
	host?: null | string, 
	/**
	private key of the server in PEM format.
	*/
	key?: null | string | Buffer, 
	/**
	passphrase for the private key or pfx.
	*/
	passphrase?: null | string, 
	/**
	Creates unix socket connection to path.
	If this option is specified, host and port are ignored.
	*/
	path?: null | string, 
	/**
	private key, certificate and CA certs of the server in PFX or PKCS12 format.
	*/
	pfx?: null | string | Buffer, 
	/**
	Port the client should connect to
	*/
	port?: null | number, 
	/**
	If true the server will reject any connection which is not authorized with the list of supplied CAs.
	This option only has an effect if `requestCert` is true.
	Default: false.
	*/
	rejectUnauthorized?: null | boolean, 
	/**
	If true - OCSP status request extension would be added to client hello,
	and OCSPResponse event will be emitted on socket before establishing secure communication
	*/
	requestOCSP?: null | boolean, 
	/**
	The SSL method to use, e.g. SSLv3_method to force SSL version 3.
	The possible values depend on your installation of OpenSSL and are defined in the constant SSL_METHODS.
	*/
	secureProtocol?: null | string, 
	/**
	Servername for SNI (Server Name Indication) TLS extension.
	*/
	servername?: null | string, 
	/**
	A Buffer instance, containing TLS session.
	*/
	session?: null | Buffer, 
	/**
	opaque identifier for session resumption.
	If `requestCert` is true, the default is MD5 hash value generated from command-line.
	Otherwise, the default is not provided.
	*/
	sessionIdContext?: null | string, 
	/**
	Establish secure connection on a given socket rather than creating a new socket.
	If this option is specified, `host` and `port` are ignored.
	*/
	socket?: null | Socket
}
