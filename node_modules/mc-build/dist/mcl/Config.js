import {FeatureFlags} from "./FeatureFlags.js"
import {Logger} from "../mcb/Logger.js"
import {Path} from "../haxe/io/Path.js"
import {Exception} from "../haxe/Exception.js"
import {Register} from "../genes/Register.js"
import * as Fs from "fs"
import {Reflect as Reflect__1} from "../Reflect.js"
import {MultiThreadIo, SyncIo, ThreadedIo} from "../Io.js"

const $global = Register.$global

export const EventDispatcher = Register.global("$hxClasses")["mcl.EventDispatcher"] = 
class EventDispatcher extends Register.inherits() {
	new() {
		this._subscribers = new Array();
	}
	subscribe(callback) {
		this._subscribers.push(callback);
	}
	dispatch(event) {
		if (this._subscribers.length == 0) {
			return;
		};
		let _g = 0;
		let _g1 = this._subscribers;
		while (_g < _g1.length) {
			let subscriber = _g1[_g];
			++_g;
			subscriber(event);
		};
	}
	static get __name__() {
		return "mcl.EventDispatcher"
	}
	get __class__() {
		return EventDispatcher
	}
}


export const ConfigEvents = Register.global("$hxClasses")["mcl.ConfigEvents"] = 
class ConfigEvents extends Register.inherits() {
	new() {
		this.onPostBuild = new EventDispatcher();
		this.onPreBuild = new EventDispatcher();
	}
	static get __name__() {
		return "mcl.ConfigEvents"
	}
	get __class__() {
		return ConfigEvents
	}
}


export const ConfigUtil = Register.global("$hxClasses")["mcl._Config.ConfigUtil"] = 
class ConfigUtil {
	static lock(obj) {
		Object.freeze(obj);
		let _g = 0;
		let _g1 = Reflect__1.fields(obj);
		while (_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			let value = Reflect__1.field(obj, field);
			if (value != null && typeof(value) == "object") {
				ConfigUtil.lock(value);
			};
		};
		return obj;
	}
	static get __name__() {
		return "mcl._Config.ConfigUtil"
	}
	get __class__() {
		return ConfigUtil
	}
}


export const Config = Register.global("$hxClasses")["mcl.Config"] = 
class Config extends Register.inherits() {
	new() {
		this.header = "# Generated with MC-Build\n";
		this.features = new FeatureFlags();
		this.formatVersion = 1;
		this.dontEmitComments = false;
		this.eqConstScoreboardName = "mcb.eq.const";
		this.eqVarScoreboardName = "mcb.eq.var";
		this.io = null;
		this.generatedDirName = "zzz";
		this.events = new ConfigEvents();
		this.libDir = Path.join([__filename, "..", ".mcblib"]);
		this.internalScoreboardName = "mcb.internal";
	}
	static create(base) {
		ConfigUtil.lock(base);
		let c = new Config();
		if (base.libDir != null) {
			c.libDir = base.libDir;
		};
		if (base.generatedDirName != null) {
			c.generatedDirName = base.generatedDirName;
		};
		if (base.internalScoreboardName != null) {
			c.internalScoreboardName = base.internalScoreboardName;
		};
		if (base.ioThreadCount != null) {
			let _g = base.ioThreadCount;
			if (base.ioThreadCount < 1) {
				throw Exception.thrown("io-thread-count must be greater than 0");
			} else if (_g == null) {
				c.io = new MultiThreadIo(base.ioThreadCount);
			} else {
				switch (_g) {
					case 1:
						c.io = new SyncIo();
						break
					case 2:
						c.io = new ThreadedIo();
						break
					default:
					c.io = new MultiThreadIo(base.ioThreadCount);
					
				};
			};
		};
		if (base.eqConstScoreboardName != null) {
			c.eqConstScoreboardName = base.eqConstScoreboardName;
		};
		if (base.eqVarScoreboardName != null) {
			c.eqVarScoreboardName = base.eqVarScoreboardName;
		};
		if (base.header != null) {
			c.header = base.header;
		};
		if (base.dontEmitComments != null) {
			c.dontEmitComments = base.dontEmitComments;
		};
		if (base.formatVersion != null) {
			c.formatVersion = base.formatVersion;
		} else {
			let content = Fs.readFileSync(Path.join([Path.addTrailingSlash(process.cwd()), "pack.mcmeta"]), {"encoding": "utf8"});
			let json = JSON.parse(content);
			if (json != null && json.pack != null && json.pack.pack_format != null) {
				c.formatVersion = json.pack.pack_format;
			} else {
				Logger.error("Could not determine pack format version, please specify it in the config or pack.mcmeta file, if you have a pack.mcmeta file already this may be the result of a parsing error.");
				process.exit(21);
			};
		};
		c.features.apply(c.formatVersion, null);
		if (base.setup != null) {
			base.setup(c);
		};
		return c;
	}
	static mergeFeatureFlagsToConfig(c) {
	}
	static get __name__() {
		return "mcl.Config"
	}
	get __class__() {
		return Config
	}
}


export const UserConfig = function() {};
UserConfig.__isInterface__ = true;
