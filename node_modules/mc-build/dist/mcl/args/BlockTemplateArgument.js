import {TemplateArgument} from "./TemplateArgument.js"
import {Tokenizer} from "../Tokenizer.js"
import {ArrayInput, Parser} from "../Parser.js"
import {AstNode} from "../AstNode.js"
import {StringMap} from "../../haxe/ds/StringMap.js"
import {Exception} from "../../haxe/Exception.js"
import {Register} from "../../genes/Register.js"

const $global = Register.$global

export const BoundBlock = Register.global("$hxClasses")["mcl.args.BoundBlock"] = 
class BoundBlock extends Register.inherits() {
	new(node, ctx) {
		this.node = node;
		this.ctx = ctx;
	}
	appendAstNode(node) {
		let _g = this.node;
		if (_g._hx_index == 8) {
			let _g1 = _g.pos;
			let _g2 = _g.name;
			let _g3 = _g.data;
			let _g4 = _g.isMacro;
			let _g5 = _g.isInline;
			let body = _g.body;
			body.push(node);
		} else {
			throw Exception.thrown("BoundBlock.append: node is not a block");
		};
	}
	append(code) {
		let tokens = Tokenizer.tokenize(code, "<inline BoundBlock.append>");
		let tokenInput = new ArrayInput(tokens);
		while (tokenInput.hasNext()) this.appendAstNode(Parser.innerParse(tokenInput));
	}
	setName(name) {
		let _g = this.node;
		if (_g._hx_index == 8) {
			let _g1 = _g.name;
			let pos = _g.pos;
			let body = _g.body;
			let data = _g.data;
			let isMacro = _g.isMacro;
			let isInline = _g.isInline;
			this.node = AstNode.Block(pos, name, body, data, isMacro, isInline);
		} else {
			throw Exception.thrown("BoundBlock.setName: node is not a block");
		};
	}
	embedTo(context, pos, file, actuallyEmbed) {
		if (actuallyEmbed == null) {
			actuallyEmbed = true;
		};
		let content = [];
		let ctx = {"isTemplate": false, "uidIndex": context.uidIndex, "namespace": context.namespace, "path": context.path, "variables": this.ctx.variables, "replacements": this.ctx.replacements, "stack": this.ctx.stack, "append": function (s) {
			content.push(s);
		}, "templates": this.ctx.templates, "requireTemplateKeyword": this.ctx.requireTemplateKeyword, "compiler": this.ctx.compiler, "globalVariables": this.ctx.globalVariables, "functions": this.ctx.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": this.ctx.currentFunction};
		if (actuallyEmbed) {
			file.embed(ctx, pos, new StringMap(), [this.node]);
		} else {
			file.embedTransform(ctx, pos, new StringMap(), [this.node]);
		};
		return content.join("\n");
	}
	static get __name__() {
		return "mcl.args.BoundBlock"
	}
	get __class__() {
		return BoundBlock
	}
}


export const BlockTemplateArgument = Register.global("$hxClasses")["mcl.args.BlockTemplateArgument"] = 
class BlockTemplateArgument extends Register.inherits(TemplateArgument) {
	new(s, pos) {
		super.new(s, pos);
		this.expectBlock = true;
	}
	parseValueBlock(s, p, context) {
		if (s._hx_index == 8) {
			let _g = s.pos;
			let _g1 = s.name;
			let _g2 = s.body;
			let _g3 = s.data;
			let _g4 = s.isMacro;
			let _g5 = s.isInline;
			return {"success": true, "value": new BoundBlock(s, context)};
		} else {
			return {"success": false};
		};
	}
	static register() {
		TemplateArgument.register("block", BlockTemplateArgument);
	}
	static get __name__() {
		return "mcl.args.BlockTemplateArgument"
	}
	static get __super__() {
		return TemplateArgument
	}
	get __class__() {
		return BlockTemplateArgument
	}
}

