import * as Module from "module"
import {McbError} from "./error/McbError.js"
import {CompilerError} from "./error/CompilerError.js"
import {TemplateArgument} from "./args/TemplateArgument.js"
import {Tokenizer} from "./Tokenizer.js"
import {TagManager} from "./TagManager.js"
import {ArrayInput, Parser} from "./Parser.js"
import {McMath} from "./McMath.js"
import {Globals} from "./Globals.js"
import {Config} from "./Config.js"
import {AstNode, JsonTagType} from "./AstNode.js"
import {Boot} from "../js/Boot.js"
import {Path} from "../haxe/io/Path.js"
import {StringMap} from "../haxe/ds/StringMap.js"
import {ObjectMap} from "../haxe/ds/ObjectMap.js"
import {IntMap} from "../haxe/ds/IntMap.js"
import {Exception} from "../haxe/Exception.js"
import {EsMap} from "../genes/util/EsMap.js"
import {Register} from "../genes/Register.js"
import {Type, ValueType} from "../Type.js"
import {StringTools} from "../StringTools.js"
import {Std} from "../Std.js"
import {Reflect as Reflect__1} from "../Reflect.js"
import {SyncIo} from "../Io.js"

const $global = Register.$global

export const ErrorUtil = Register.global("$hxClasses")["mcl.ErrorUtil"] = 
class ErrorUtil {
	static format(message, pos) {
		return "" + pos.file + ":" + pos.line + ":" + (pos.col + 1) + ": " + message;
	}
	static formatWithStack(message, stack) {
		let res = message;
		let _g = 0;
		while (_g < stack.length) {
			let pos = stack[_g];
			++_g;
			if (pos == null) {
				res += "\n\tat <unknown>";
			} else {
				res += "\n\tat " + pos.file + ":" + pos.line + ":" + (pos.col + 1);
			};
		};
		return res;
	}
	static formatContext(message, pos, context) {
		return ErrorUtil.formatWithStack(message, context.stack.concat([pos]));
	}
	static get __name__() {
		return "mcl.ErrorUtil"
	}
	get __class__() {
		return ErrorUtil
	}
}


export const UidTracker = Register.global("$hxClasses")["mcl._Compiler.UidTracker"] = 
class UidTracker extends Register.inherits() {
	new() {
		this.uid = 0;
	}
	get() {
		return this.uid++;
	}
	static get __name__() {
		return "mcl._Compiler.UidTracker"
	}
	get __class__() {
		return UidTracker
	}
}


export const McTemplate = Register.global("$hxClasses")["mcl.McTemplate"] = 
class McTemplate extends Register.inherits() {
	new(name, body, file) {
		this.jsValueCache = new IntMap();
		this.hasBeenUsed = false;
		this.tickBlock = null;
		this.loadBlock = null;
		this.overloads = new ObjectMap();
		this.name = name;
		this.body = body;
		this.parse(body);
		this.file = file;
	}
	compileArgs(args, pos) {
		let $arguments = [];
		let sections = args.split(" ");
		let offset = 0;
		let _g = 0;
		while (_g < sections.length) {
			let section = sections[_g];
			++_g;
			if (section == "") {
				++offset;
				continue;
			};
			$arguments.push(TemplateArgument.parse(section, {"file": pos.file, "line": pos.line, "col": pos.col + offset}));
			offset += section.length;
		};
		return $arguments;
	}
	parse(nodes) {
		let _g = 0;
		while (_g < nodes.length) {
			let node = nodes[_g];
			++_g;
			switch (node._hx_index) {
				case 9:
					let pos = node.pos;
					let body = node.body;
					if (this.tickBlock == null) {
						this.tickBlock = body;
					} else {
						throw new CompilerError(ErrorUtil.format("Templates can only have one top-level tick block", pos), false);
					};
					break
				case 10:
					let pos1 = node.pos;
					let body1 = node.body;
					if (this.loadBlock == null) {
						this.loadBlock = body1;
					} else {
						throw new CompilerError(ErrorUtil.format("Templates can only have one top-level load block", pos1), false);
					};
					break
				case 17:
					let pos2 = node.pos;
					let args = node.args;
					let body2 = node.body;
					let this1 = this.overloads;
					let key = this.compileArgs(args, pos2);
					this1.inst.set(key, body2);
					break
				default:
				if (node._hx_index != 16) {
					throw new CompilerError(ErrorUtil.format("Unexpected node type: " + Std.string(node), Reflect__1.field(node, "pos")), true);
				};
				
			};
		};
	}
	inject(context, into) {
		this.hasBeenUsed = true;
		let defs = [];
		if (this.loadBlock != null && this.loadBlock.length > 0) {
			let pos = this.loadBlock[0].pos;
			defs.push(AstNode.FunctionDef(pos, "load", this.loadBlock, "minecraft:load"));
		};
		if (this.tickBlock != null && this.tickBlock.length > 0) {
			let pos = this.tickBlock[0].pos;
			defs.push(AstNode.FunctionDef(pos, "tick", this.tickBlock, "minecraft:tick"));
		};
		if (defs.length > 0) {
			let pos = defs[0].pos;
			let info = context.compiler.getInitialPathInfo(this.file.name);
			let tmp = {"append": function (v) {
				throw new CompilerError(ErrorUtil.formatContext("tried to append to a Void context (template virtual context)", pos, context), false, [pos].concat(context.stack));
			}, "namespace": info.namespace, "path": info.path, "uidIndex": context.uidIndex, "variables": new VariableMap(context.globalVariables), "templates": this.file.templates, "stack": context.stack, "replacements": new VariableMap(null), "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
			let tmp1 = AstNode.Directory(pos, this.name, defs);
			into.embed(tmp, pos, new StringMap(), [tmp1], true);
		};
	}
	injectTransform(context, into) {
		this.hasBeenUsed = true;
		let defs = [];
		if (this.loadBlock != null && this.loadBlock.length > 0) {
			let pos = this.loadBlock[0].pos;
			defs.push(AstNode.FunctionDef(pos, "load", this.loadBlock, "minecraft:load"));
		};
		if (this.tickBlock != null && this.tickBlock.length > 0) {
			let pos = this.tickBlock[0].pos;
			defs.push(AstNode.FunctionDef(pos, "tick", this.tickBlock, "minecraft:tick"));
		};
		if (defs.length > 0) {
			let pos = defs[0].pos;
			let info = context.compiler.getInitialPathInfo(this.file.name);
			let tmp = {"append": function (v) {
				throw new CompilerError(ErrorUtil.formatContext("tried to append to a Void context (template virtual context)", pos, context), false, [pos].concat(context.stack));
			}, "namespace": info.namespace, "path": info.path, "uidIndex": context.uidIndex, "variables": new VariableMap(context.globalVariables), "templates": this.file.templates, "stack": context.stack, "replacements": new VariableMap(null), "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
			let tmp1 = AstNode.Directory(pos, this.name, defs);
			into.embedTransform(tmp, pos, new StringMap(), [tmp1], true);
		};
		return AstNode.Void;
	}
	process(file, context, pos, value, extras) {
		let argstring = StringTools.ltrim(value.substring(this.name.length));
		this.jsValueCache.clear();
		TemplateArgument.jsCache = this.jsValueCache;
		let map = this.overloads;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let types = _g_key;
			let overloadBody = _g_value;
			let args = new StringMap();
			let successCount = 0;
			let pidx = 0;
			let argList = [argstring].concat((extras == null) ? [] : extras);
			let lastEntryWasBlock = false;
			let jsCacheIdx = 0;
			let _g = 0;
			while (_g < types.length) {
				let arg = types[_g];
				++_g;
				while (pidx < argList.length && argList[pidx] == "") ++pidx;
				if (pidx >= argList.length) {
					break;
				};
				if (arg.expectBlock) {
					if (!Type.enumEq(Type["typeof"](argList[pidx]), ValueType.TEnum(AstNode))) {
						break;
					};
					let x = arg.parseValueBlock(argList[pidx], pos, context);
					if (!x.success) {
						break;
					};
					lastEntryWasBlock = true;
					args.inst.set(arg.name, x.value);
					argList[pidx] = x.raw;
					++successCount;
					++pidx;
				} else {
					if (typeof(argList[pidx]) != "string") {
						break;
					};
					let s = argList[pidx];
					let jsBlockRaw = null;
					if (s.charAt(0) == "<" && s.charAt(1) == "%" && !arg.expectJsValue) {
						let end = s.indexOf("%>");
						if (end == -1) {
							throw new CompilerError(ErrorUtil.formatContext("Unexpected end of inline script block", pos, context), false, [pos].concat(context.stack));
						};
						let script = s.substring(2, end);
						jsBlockRaw = script;
						if (this.jsValueCache.inst.has(jsCacheIdx)) {
							let jsVal = this.jsValueCache.inst.get(jsCacheIdx);
							s = (jsVal == null) ? "null" : Std.string(jsVal);
						} else {
							let jsVal = McFile.invokeExpressionInline(script, context, pos);
							this.jsValueCache.inst.set(jsCacheIdx, jsVal);
							s = (jsVal == null) ? "null" : Std.string(jsVal);
						};
						++jsCacheIdx;
					} else if (arg.expectJsValue) {
						TemplateArgument.jsCacheIdx = jsCacheIdx;
						++jsCacheIdx;
					};
					let x = arg.parseValue(s, pos, context);
					if (!x.success) {
						break;
					};
					if (arg.name != null) {
						args.inst.set(arg.name, x.value);
					};
					if (jsBlockRaw != null) {
						argList[pidx] = StringTools.ltrim((Boot.__cast(argList[pidx], String)).substring(jsBlockRaw.length + 4));
					} else {
						argList[pidx] = StringTools.ltrim((Boot.__cast(argList[pidx], String)).substring(x.raw.length));
					};
					++successCount;
					lastEntryWasBlock = false;
				};
			};
			while (pidx < argList.length && argList[pidx] == "") ++pidx;
			if (successCount != types.length || pidx != argList.length || argList[pidx - 1] != "" && !lastEntryWasBlock) {
				continue;
			};
			if (!this.hasBeenUsed) {
				this.inject(context, file);
			};
			let newContext = {"append": context.append, "namespace": context.namespace, "path": context.path, "uidIndex": context.uidIndex, "variables": context.variables, "templates": this.file.templates, "stack": context.stack, "replacements": context.replacements, "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
			file.embed(newContext, pos, args, overloadBody);
			return;
		};
		throw new CompilerError(ErrorUtil.formatContext("Failed to find matching template overload for: " + value, pos, context), false, [pos].concat(context.stack));
	}
	transform(file, context, pos, value, extras) {
		let argstring = StringTools.ltrim(value.substring(this.name.length));
		this.jsValueCache.clear();
		TemplateArgument.jsCache = this.jsValueCache;
		let map = this.overloads;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let types = _g_key;
			let overloadBody = _g_value;
			let args = new StringMap();
			let successCount = 0;
			let pidx = 0;
			let argList = [argstring].concat((extras == null) ? [] : extras);
			let lastEntryWasBlock = false;
			let jsCacheIdx = 0;
			let _g = 0;
			while (_g < types.length) {
				let arg = types[_g];
				++_g;
				while (pidx < argList.length && argList[pidx] == "") ++pidx;
				if (pidx >= argList.length) {
					break;
				};
				if (arg.expectBlock) {
					if (!Type.enumEq(Type["typeof"](argList[pidx]), ValueType.TEnum(AstNode))) {
						break;
					};
					let x = arg.parseValueBlock(argList[pidx], pos, context);
					if (!x.success) {
						break;
					};
					lastEntryWasBlock = true;
					args.inst.set(arg.name, x.value);
					argList[pidx] = x.raw;
					++successCount;
					++pidx;
				} else {
					if (typeof(argList[pidx]) != "string") {
						break;
					};
					let s = argList[pidx];
					let jsBlockRaw = null;
					if (s.charAt(0) == "<" && s.charAt(1) == "%" && !arg.expectJsValue) {
						let end = s.indexOf("%>");
						if (end == -1) {
							throw new CompilerError(ErrorUtil.formatContext("Unexpected end of inline script block", pos, context), false, [pos].concat(context.stack));
						};
						let script = s.substring(2, end);
						jsBlockRaw = script;
						if (this.jsValueCache.inst.has(jsCacheIdx)) {
							let jsVal = this.jsValueCache.inst.get(jsCacheIdx);
							s = (jsVal == null) ? "null" : Std.string(jsVal);
						} else {
							let jsVal = McFile.invokeExpressionInline(script, context, pos);
							this.jsValueCache.inst.set(jsCacheIdx, jsVal);
							s = (jsVal == null) ? "null" : Std.string(jsVal);
						};
						++jsCacheIdx;
					} else if (arg.expectJsValue) {
						TemplateArgument.jsCacheIdx = jsCacheIdx;
						++jsCacheIdx;
					};
					let x = arg.parseValue(s, pos, context);
					if (!x.success) {
						break;
					};
					if (arg.name != null) {
						args.inst.set(arg.name, x.value);
					};
					if (jsBlockRaw != null) {
						argList[pidx] = StringTools.ltrim((Boot.__cast(argList[pidx], String)).substring(jsBlockRaw.length + 4));
					} else {
						argList[pidx] = StringTools.ltrim((Boot.__cast(argList[pidx], String)).substring(x.raw.length));
					};
					++successCount;
					lastEntryWasBlock = false;
				};
			};
			while (pidx < argList.length && argList[pidx] == "") ++pidx;
			if (successCount != types.length || pidx != argList.length || argList[pidx - 1] != "" && !lastEntryWasBlock) {
				continue;
			};
			let nodes = [];
			if (!this.hasBeenUsed) {
				nodes.push(this.injectTransform(context, file));
			};
			let newContext = {"append": context.append, "namespace": context.namespace, "path": context.path, "uidIndex": context.uidIndex, "variables": context.variables, "templates": this.file.templates, "stack": context.stack, "replacements": context.replacements, "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
			nodes.push(file.embedTransform(newContext, pos, args, overloadBody, false));
			return AstNode.Group(nodes);
		};
		throw new CompilerError(ErrorUtil.formatContext("Failed to find matching template overload for: " + value, pos, context), false, [pos].concat(context.stack));
	}
	static get __name__() {
		return "mcl.McTemplate"
	}
	get __class__() {
		return McTemplate
	}
}


export const VariableMap = Register.global("$hxClasses")["mcl.VariableMap"] = 
class VariableMap extends Register.inherits() {
	new(parent, variables) {
		this.parent = parent;
		this.variables = (variables == null) ? new StringMap() : variables;
	}
	get() {
		if (this._cache != null) {
			let _g = new StringMap();
			let map = this._cache;
			let _g_map = map;
			let _g_keys = map.keys();
			while (_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = _g_map.get(key);
				let _g_key = key;
				let k = _g_key;
				let v = _g_value;
				_g.inst.set(k, v);
			};
			return _g;
		};
		let res = (this.parent == null) ? new StringMap() : this.parent.get();
		let map = this.variables;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			res.inst.set(k, v);
		};
		this._cache = res;
		return res;
	}
	static fromObject(obj) {
		let res = new StringMap();
		let _g = 0;
		let _g1 = Reflect__1.fields(obj);
		while (_g < _g1.length) {
			let k = _g1[_g];
			++_g;
			res.inst.set(k, Reflect__1.field(obj, k));
		};
		return new VariableMap(null, res);
	}
	static get __name__() {
		return "mcl.VariableMap"
	}
	get __class__() {
		return VariableMap
	}
}


Register.createStatic(VariableMap, "globals", function () { return new VariableMap(null, Globals.map) })
export const ImportFileType = 
Register.global("$hxEnums")["mcl.ImportFileType"] = 
{
	__ename__: "mcl.ImportFileType",
	
	IMcFile: Object.assign((f) => ({_hx_index: 0, __enum__: "mcl.ImportFileType", "f": f, "@kind": "IMcFile"}), {_hx_name: "IMcFile", __params__: ["f"]}),
	IJsFile: Object.assign((f) => ({_hx_index: 1, __enum__: "mcl.ImportFileType", "f": f, "@kind": "IJsFile"}), {_hx_name: "IJsFile", __params__: ["f"]})
}
ImportFileType.__constructs__ = [ImportFileType.IMcFile, ImportFileType.IJsFile]
ImportFileType.__empty_constructs__ = []

export const McFile = Register.global("$hxClasses")["mcl.McFile"] = 
class McFile extends Register.inherits() {
	new(name, ast) {
		this.tagsDir = "tags";
		this.functionsDir = "functions";
		this.fileJs = {};
		this.tickCommands = [];
		this.loadCommands = [];
		this.imports = new StringMap();
		this.exportedTemplates = new StringMap();
		this.templates = new StringMap();
		this.ast = [];
		this.name = name;
		this.ast = ast;
		this.ext = Path.extension(name);
	}
	getTemplates() {
		if (this.ext == "mcbt") {
			return this.exportedTemplates;
		};
		throw new CompilerError("tried to get templates from non-template file:" + this.name, true);
	}
	setup(compiler) {
		if (compiler.config.features.useFolderRenames48) {
			this.functionsDir = "function";
		};
		let ast = this.ast;
		this.ast = [];
		let _g = 0;
		while (_g < ast.length) {
			let node = ast[_g];
			++_g;
			switch (node._hx_index) {
				case 2:
					let _g1 = node.pos;
					let name = node.name;
					let body = node.body;
					let template = new McTemplate(name, body, this);
					this.templates.inst.set(name, template);
					this.exportedTemplates.inst.set(name, template);
					break
				case 4:
					let _g2 = node.pos;
					let importName = node.name;
					let res = compiler.resolve(this.name, importName);
					switch (res._hx_index) {
						case 0:
							let f = res.f;
							this.imports.inst.set(importName, f);
							break
						case 1:
							let f1 = res.f;
							Object.assign(this.fileJs, f1);;
							break
						
					};
					break
				case 15:
					let _g3 = node.pos;
					let _g4 = node.value;
					break
				default:
				this.ast.push(node);
				
			};
		};
		let dep = EsMap.adaptIterator(this.imports.inst.values());
		while (dep.hasNext()) {
			let dep1 = dep.next();
			let importedTemplates = dep1.getTemplates();
			let map = importedTemplates;
			let _g_map = map;
			let _g_keys = map.keys();
			while (_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = _g_map.get(key);
				let _g_key = key;
				let k = _g_key;
				let v = _g_value;
				this.templates.inst.set(k, v);
			};
		};
	}
	createAnonymousFunction(pos, body, data, context, name, isMacro) {
		name = (name != null) ? this.injectValues(name, context, pos) : null;
		let commands = [];
		let uid = (name == null) ? Std.string(context.uidIndex.get()) : "";
		let id = (name == null) ? "" + context.compiler.config.generatedDirName + "/" + uid : name;
		let newGeneratedRoot = (name == null) ? [] : [name];
		if (name != null && name.indexOf("/") != -1) {
			let segments = name.split("/");
			segments.pop();
			newGeneratedRoot = segments;
		};
		let callSig = context.namespace + ":" + context.path.concat((name == null) ? [context.compiler.config.generatedDirName, uid] : [name]).join("/");
		let namespace = context.namespace;
		let _this = context.variables;
		let variables = null;
		let variableMap = (variables == null) ? _this : new VariableMap(_this, variables);
		let path = context.path.concat(newGeneratedRoot);
		let uidIndex = context.uidIndex;
		let stack = context.stack;
		let replacements = context.variables;
		let templates = context.templates;
		let requireTemplateKeyword = context.requireTemplateKeyword;
		let compiler = context.compiler;
		let globalVariables = context.globalVariables;
		let functions = context.functions.concat([callSig]);
		let newContext = {"append": function (v) {
			commands.push(v);
		}, "namespace": namespace, "path": (path == null) ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": stack, "replacements": replacements, "isTemplate": this.ext == "mcbt", "templates": templates, "requireTemplateKeyword": requireTemplateKeyword, "compiler": compiler, "globalVariables": globalVariables, "functions": functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
		let _g = 0;
		while (_g < body.length) {
			let node = body[_g];
			++_g;
			this.compileCommand(node, newContext);
		};
		let result = commands.join("\n");
		if (name != null) {
			name = this.injectValues(name, context, pos);
		};
		let path1 = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([id + ".mcfunction"])));
		let content = result;
		if (context.compiler.config.header.length > 0 && path1.endsWith(".mcfunction")) {
			content = context.compiler.config.header + "\n" + content;
		};
		context.compiler.io.write(path1, content);
		let cmd = "function " + context.namespace + ":" + context.path.concat([id]).join("/");
		let cmd1 = (data == null) ? "" : " " + this.injectValues(data, context, pos);
		return "" + ((isMacro) ? "$" : "") + (cmd + cmd1);
	}
	embedTransform(context, pos, varmap, body, useTld) {
		if (useTld == null) {
			useTld = false;
		};
		let namespace = context.namespace;
		let append = context.append;
		let _this = context.globalVariables;
		let variableMap = new VariableMap(VariableMap.globals, ((varmap == null) ? _this : new VariableMap(_this, varmap)).get());
		let path = context.path;
		let newContext = {"append": append, "namespace": namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
		let _g = [];
		let _g1 = 0;
		while (_g1 < body.length) {
			let node = body[_g1];
			++_g1;
			if (useTld) {
				_g.push(this.transformTld(node, newContext));
			} else {
				_g.push(this.transformCommand(node, newContext));
			};
		};
		let res = AstNode.Group(_g);
		if (useTld) {
			context.compiler.addTopLevelAstNode(res);
		};
		if (useTld) {
			return AstNode.Void;
		} else {
			return res;
		};
	}
	embed(context, pos, varmap, body, useTld) {
		if (useTld == null) {
			useTld = false;
		};
		let namespace = context.namespace;
		let append = context.append;
		let _this = context.globalVariables;
		let variableMap = new VariableMap(VariableMap.globals, ((varmap == null) ? _this : new VariableMap(_this, varmap)).get());
		let path = context.path;
		let newContext = {"append": append, "namespace": namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
		let _g = 0;
		while (_g < body.length) {
			let node = body[_g];
			++_g;
			if (useTld) {
				this.compileTld(node, newContext);
			} else {
				this.compileCommand(node, newContext);
			};
		};
	}
	transformTemplate(context, pos, value, extras, isMacro) {
		if (context.compiler.templateParsingEnabled) {
			if (value.startsWith("template ")) {
				value = value.substring(9);
			};
			let map = context.templates;
			let _g_map = map;
			let _g_keys = map.keys();
			while (_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = _g_map.get(key);
				let _g_key = key;
				let k = _g_key;
				let v = _g_value;
				if (value == k || value.startsWith(k)) {
					return v.transform(this, context, pos, value, extras);
				};
			};
			if (extras != null && extras.length > 0) {
				throw new CompilerError(ErrorUtil.formatContext("Unexpected extra data in non template command", pos, context), false, [pos].concat(context.stack));
			};
		};
		return AstNode.Raw(pos, this.injectValues(value, context, pos), extras, isMacro);
	}
	processTemplate(context, pos, value, extras, isMacro) {
		if (context.compiler.templateParsingEnabled) {
			if (value.startsWith("template ")) {
				value = value.substring(9);
			};
			let map = context.templates;
			let _g_map = map;
			let _g_keys = map.keys();
			while (_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = _g_map.get(key);
				let _g_key = key;
				let k = _g_key;
				let v = _g_value;
				if (value == k || value.startsWith(k)) {
					v.process(this, context, pos, value, extras);
					return;
				};
			};
			if (extras != null && extras.length > 0) {
				throw new CompilerError(ErrorUtil.formatContext("Unexpected extra data in non template command", pos, context), false, [pos].concat(context.stack));
			};
		};
		let cmd = this.injectValues(value, context, pos);
		context.append("" + ((isMacro) ? "$" : "") + cmd);
	}
	compileInline(context, code, isTLD) {
		if (isTLD == null) {
			isTLD = false;
		};
		let tokens = Tokenizer.tokenize(code, "<inline " + this.name + ">");
		let tokenInput = new ArrayInput(tokens);
		let astNodes = [];
		while (tokenInput.hasNext()) if (isTLD) {
			astNodes.push(Parser.parseTLD(tokenInput));
		} else {
			astNodes.push(Parser.innerParse(tokenInput));
		};
		if (isTLD) {
			let _g = 0;
			while (_g < astNodes.length) {
				let node = astNodes[_g];
				++_g;
				this.compileTld(node, context);
			};
		} else {
			let _g = 0;
			while (_g < astNodes.length) {
				let node = astNodes[_g];
				++_g;
				this.compileCommand(node, context);
			};
		};
	}
	transformInline(context, code, isTLD) {
		if (isTLD == null) {
			isTLD = false;
		};
		let tokens = Tokenizer.tokenize(code, "<inline " + this.name + ">");
		let tokenInput = new ArrayInput(tokens);
		let astNodes = [];
		while (tokenInput.hasNext()) if (isTLD) {
			astNodes.push(Parser.parseTLD(tokenInput));
		} else {
			astNodes.push(Parser.innerParse(tokenInput));
		};
		let tmp;
		if (isTLD) {
			let _g = [];
			let _g1 = 0;
			while (_g1 < astNodes.length) {
				let node = astNodes[_g1];
				++_g1;
				_g.push(this.transformTld(node, context));
			};
			tmp = _g;
		} else {
			let _g = [];
			let _g1 = 0;
			while (_g1 < astNodes.length) {
				let node = astNodes[_g1];
				++_g1;
				_g.push(this.transformCommand(node, context));
			};
			tmp = _g;
		};
		return AstNode.Group(tmp);
	}
	processMlScript(context, pos, tokens, isTLD) {
		if (isTLD == null) {
			isTLD = false;
		};
		let str = "";
		let _g = 0;
		while (_g < tokens.length) {
			let t = tokens[_g];
			++_g;
			switch (t._hx_index) {
				case 0:
					let v = t.v;
					let pos = t.pos;
					str += v + "\n";
					break
				case 1:
					let pos1 = t.pos;
					let data = t.data;
					str += "{" + data;
					break
				case 2:
					let pos2 = t.pos;
					str += "}";
					break
				
			};
		};
		let names = ["emit", "context", "embed", "require"];
		let emit = function (c) {
			context.append(c);
		};
		let _gthis = this;
		let emitMcb = function (code) {
			_gthis.compileInline(context, code, isTLD);
		};
		let emitBlock = function (commands, data) {
			let id = "" + context.compiler.config.generatedDirName + "/" + Std.string(context.uidIndex.get());
			let path = Path.join(["data", context.namespace, _gthis.functionsDir].concat(context.path.concat([id + ".mcfunction"])));
			let content = commands.join("\n");
			if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
				content = context.compiler.config.header + "\n" + content;
			};
			context.compiler.io.write(path, content);
			let signature = "" + context.namespace + ":" + context.path.concat([id]).join("/");
			context.append("function " + signature + ((data == null) ? "" : " " + data));
			return signature;
		};
		emit.mcb = emitMcb;
		if (!isTLD) {
			emit.block = emitBlock;
		};
		let values = [emit, context, function (v) {
			if (isTLD) {
				throw new CompilerError(ErrorUtil.formatContext("embed not available in toplevel script blocks", pos, context), false, [pos].concat(context.stack));
			};
			return v.embedTo(context, pos, _gthis);
		}, (context.compiler.disableRequire) ? function (s) {
			throw new CompilerError(ErrorUtil.formatContext("Require not available as it has been disabled, please disable compiler.disableRequire", pos, context), false, [pos].concat(context.stack));
		} : Module.createRequire(this.name)];
		let jsEnv = context.variables.get();
		let map = jsEnv;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			names.push(k);
			values.push(v);
		};
		try {
			new Function(...names,str)(...values);
		}catch (_g) {
			let e = Exception.caught(_g);
			if (((e) instanceof McbError)) {
				throw Exception.thrown(e);
			} else {
				throw new CompilerError(ErrorUtil.formatContext("Error in multi-line script, '" + e.get_message() + "' at " + pos.file + ":" + pos.line + ":" + (pos.col + 1), pos, context), false, [pos].concat(context.stack));
			};
		};
	}
	processMlScriptTransform(context, pos, tokens, isTLD) {
		if (isTLD == null) {
			isTLD = false;
		};
		let str = "";
		let _g = 0;
		while (_g < tokens.length) {
			let t = tokens[_g];
			++_g;
			switch (t._hx_index) {
				case 0:
					let v = t.v;
					let pos = t.pos;
					str += v + "\n";
					break
				case 1:
					let pos1 = t.pos;
					let data = t.data;
					str += "{" + data;
					break
				case 2:
					let pos2 = t.pos;
					str += "}";
					break
				
			};
		};
		let names = ["emit", "context", "embed", "require"];
		let results = [];
		let emit = function (c) {
			return results.push(AstNode.Raw(pos, c, [], null));
		};
		let _gthis = this;
		let emitMcb = function (code) {
			results.push(_gthis.transformInline(context, code, isTLD));
		};
		let emitBlock = function (commands, data) {
			let id = context.uidIndex.get();
			let context1 = context.compiler;
			let pos1 = pos;
			let pos2 = pos;
			let emitBlock = "block_" + id;
			let _g = [];
			let _g1 = 0;
			while (_g1 < commands.length) {
				let c = commands[_g1];
				++_g1;
				_g.push(AstNode.Raw(pos, c, [], false));
			};
			context1.addTopLevelAstNode(AstNode.Directory(pos1, "mcb_emmited_blocks", [AstNode.FunctionDef(pos2, emitBlock, _g, null)]));
			results.push(AstNode.FunctionCall(pos, context.namespace + ":" + context.baseNamespaceInfo.path.concat(["mcb_emmited_blocks", "block_" + id]).join("/"), (data == null) ? null : _gthis.injectValues(data, context, pos), false));
			return context.namespace + ":" + context.baseNamespaceInfo.path.concat(["mcb_emmited_blocks", "block_" + id]).join("/");
		};
		emit.mcb = emitMcb;
		if (!isTLD) {
			emit.block = emitBlock;
		};
		let values = [emit, context, function (v) {
			if (isTLD) {
				throw new CompilerError(ErrorUtil.formatContext("embed not available in toplevel script blocks", pos, context), false, [pos].concat(context.stack));
			};
			return v.embedTo(context, pos, _gthis, false);
		}, (context.compiler.disableRequire) ? function (s) {
			throw new CompilerError(ErrorUtil.formatContext("Require not available as it has been disabled, please disable compiler.disableRequire", pos, context), false, [pos].concat(context.stack));
		} : Module.createRequire(this.name)];
		let jsEnv = context.variables.get();
		let map = jsEnv;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			names.push(k);
			values.push(v);
		};
		try {
			new Function(...names,str)(...values);
		}catch (_g) {
			let e = Exception.caught(_g);
			if (((e) instanceof McbError)) {
				throw Exception.thrown(e);
			} else {
				throw new CompilerError(ErrorUtil.formatContext("Error in multi-line script, '" + e.get_message() + "' at " + pos.file + ":" + pos.line + ":" + (pos.col + 1), pos, context), false, [pos].concat(context.stack));
			};
		};
		return AstNode.Group(results);
	}
	transformCommand(node, context) {
		let _gthis = this;
		switch (node._hx_index) {
			case 0:
				let pos = node.pos;
				let value = node.value;
				let extras = node.continuations;
				let isMacro = node.isMacro;
				return this.transformTemplate(context, pos, value, extras, isMacro);
				break
			case 5:
				let pos1 = node.pos;
				let expression = node.expression;
				let as = node.as;
				let body = node.body;
				let nodes = [];
				this.processCompilerLoop(expression, as, context, body, pos1, function (ctx, v) {
					nodes.push(_gthis.transformCommand(v, ctx));
				});
				return AstNode.Group(nodes);
				break
			case 6:
				let pos2 = node.pos;
				let expression1 = node.expression;
				let body1 = node.body;
				let elseExpressions = node.elseExpressions;
				return this.transformCompileTimeIf(expression1, body1, elseExpressions, pos2, context, function (v) {
					return _gthis.transformCommand(v, context);
				});
				break
			case 7:
				let pos3 = node.pos;
				let value1 = node.value;
				return this.processMlScriptTransform(context, pos3, value1);
				break
			case 8:
				let pos4 = node.pos;
				let name = node.name;
				let body2 = node.body;
				let data = node.data;
				let isMacro1 = node.isMacro;
				let isInline = node.isInline;
				let tmp = this.injectValues(name, context, pos4);
				let _g = [];
				let _g1 = 0;
				while (_g1 < body2.length) {
					let node = body2[_g1];
					++_g1;
					_g.push(this.transformCommand(node, context));
				};
				return AstNode.Block(pos4, tmp, _g, this.injectValues(data, context, pos4), isMacro1, isInline);
				break
			case 9:
				let pos5 = node.pos;
				let body3 = node.body;
				let _g2 = [];
				let _g3 = 0;
				while (_g3 < body3.length) {
					let node = body3[_g3];
					++_g3;
					_g2.push(this.transformCommand(node, context));
				};
				return AstNode.TickBlock(pos5, _g2);
				break
			case 10:
				let pos6 = node.pos;
				let body4 = node.body;
				let _g4 = [];
				let _g5 = 0;
				while (_g5 < body4.length) {
					let node = body4[_g5];
					++_g5;
					_g4.push(this.transformCommand(node, context));
				};
				return AstNode.LoadBlock(pos6, _g4);
				break
			case 11:
				let pos7 = node.pos;
				let execute = node.execute;
				let data1 = node.data;
				let body5 = node.body;
				let continuations = node.continuations;
				let isMacro2 = node.isMacro;
				let tmp1 = this.injectValues(execute, context, pos7);
				let tmp2 = this.injectValues(data1, context, pos7);
				let _g6 = [];
				let _g7 = 0;
				while (_g7 < body5.length) {
					let node = body5[_g7];
					++_g7;
					_g6.push(this.transformCommand(node, context));
				};
				let tmp3 = _g6;
				let tmp4;
				if (continuations == null) {
					tmp4 = [];
				} else {
					let _g = [];
					let _g1 = 0;
					while (_g1 < continuations.length) {
						let node = continuations[_g1];
						++_g1;
						_g.push(this.transformCommand(node, context));
					};
					tmp4 = _g;
				};
				return AstNode.ExecuteBlock(pos7, tmp1, tmp2, tmp3, tmp4, isMacro2);
				break
			case 12:
				let pos8 = node.pos;
				let delay = node.delay;
				let type = node.type;
				let body6 = node.body;
				let isMacro3 = node.isMacro;
				let tmp5 = this.injectValues(delay, context, pos8);
				let tmp6 = this.injectValues(type, context, pos8);
				let _g8 = [];
				let _g9 = 0;
				while (_g9 < body6.length) {
					let node = body6[_g9];
					++_g9;
					_g8.push(this.transformCommand(node, context));
				};
				return AstNode.ScheduleBlock(pos8, tmp5, tmp6, _g8, isMacro3);
				break
			case 15:
				let pos9 = node.pos;
				let value2 = node.value;
				if (context.compiler.config.dontEmitComments) {
					return AstNode.Void;
				} else {
					return AstNode.Comment(pos9, value2);
				};
				break
			case 19:
				let pos10 = node.pos;
				let command = node.command;
				let value3 = node.value;
				let isMacro4 = node.isMacro;
				return AstNode.Execute(pos10, this.injectValues(command, context, pos10), this.transformCommand(value3, context), isMacro4);
				break
			case 20:
				let pos11 = node.pos;
				let name1 = node.name;
				let data2 = node.data;
				let isMacro5 = node.isMacro;
				return AstNode.FunctionCall(pos11, this.injectValues(name1, context, pos11), this.injectValues(data2, context, pos11), isMacro5);
				break
			case 21:
				let pos12 = node.pos;
				let command1 = node.command;
				return AstNode.EqCommand(pos12, this.injectValues(command1, context, pos12));
				break
			case 22:
				let pos13 = node.pos;
				let delay1 = node.delay;
				let target = node.target;
				let mode = node.mode;
				let isMacro6 = node.isMacro;
				return AstNode.ScheduleCall(pos13, this.injectValues(delay1, context, pos13), this.injectValues(target, context, pos13), this.injectValues(mode, context, pos13), isMacro6);
				break
			case 23:
				let pos14 = node.pos;
				let value4 = node.value;
				let isMacro7 = node.isMacro;
				return AstNode.ReturnRun(pos14, this.transformCommand(value4, context), isMacro7);
				break
			case 24:
				let pos15 = node.pos;
				let target1 = node.target;
				let isMacro8 = node.isMacro;
				return AstNode.ScheduleClear(pos15, this.injectValues(target1, context, pos15), isMacro8);
				break
			default:
			debugger;
			console.log("src/mcl/Compiler.hx:897:",Std.string(node));
			throw Exception.thrown("Unexpected node type in transformCommand: " + Std.string(node));
			
		};
	}
	evaluateFunctionHandle(handle, context, pos, isMacro) {
		let name = this.injectValues(handle, context, pos);
		let tagPrefix = (name.charAt(0) == "#") ? "#" : "";
		if (tagPrefix != "") {
			name = name.substring(1);
		};
		switch (name.charAt(0)) {
			case "*":
				return "" + tagPrefix + context.namespace + ":" + name.substring(1);
				break
			case ".":
				if (name.charAt(1) == "/" || name.charAt(1) == "." && name.charAt(2) == "/") {
					let path = context.currentFunction.concat(name.split("/"));
					let resolved = [];
					let _g = 0;
					while (_g < path.length) {
						let node = path[_g];
						++_g;
						switch (node) {
							case "":case ".":
								break
							case "..":
								if (resolved.length == 0) {
									throw new CompilerError(ErrorUtil.formatContext("Invalid call: " + name, pos, context), false, [pos].concat(context.stack));
								};
								resolved.pop();
								break
							default:
							resolved.push(node);
							
						};
					};
					return "" + tagPrefix + context.namespace + ":" + resolved.join("/");
				} else {
					if (name.indexOf(":") == -1) {
						name = "" + context.namespace + ":" + context.path.concat([name]).join("/");
					};
					return "" + tagPrefix + name;
				};
				break
			case "^":
				let levels = Std.parseInt(name.substring(1));
				let fn = context.functions[context.functions.length - levels - 1];
				if (fn == null) {
					throw new CompilerError(ErrorUtil.formatContext("Unexpected call: " + name, pos, context), false, [pos].concat(context.stack));
				};
				return "" + tagPrefix + fn;
				break
			default:
			if (name.indexOf(":") == -1) {
				name = "" + context.namespace + ":" + context.path.concat([name]).join("/");
			};
			return "" + tagPrefix + name;
			
		};
	}
	compileCommand(node, context) {
		let _gthis = this;
		switch (node._hx_index) {
			case 0:
				let pos = node.pos;
				let value = node.value;
				let extras = node.continuations;
				let isMacro = node.isMacro;
				this.processTemplate(context, pos, value, extras, isMacro);
				break
			case 5:
				let pos1 = node.pos;
				let expression = node.expression;
				let as = node.as;
				let body = node.body;
				this.processCompilerLoop(expression, as, context, body, pos1, function (context, v) {
					_gthis.compileCommand(v, context);
				});
				break
			case 6:
				let pos2 = node.pos;
				let expression1 = node.expression;
				let body1 = node.body;
				let elseExpressions = node.elseExpressions;
				this.compileTimeIf(expression1, body1, elseExpressions, pos2, context, function (v) {
					_gthis.compileCommand(v, context);
				});
				break
			case 7:
				let pos3 = node.pos;
				let value1 = node.value;
				this.processMlScript(context, pos3, value1);
				break
			case 8:
				let _g = node.pos;
				let _g1 = node.name;
				let _g2 = node.body;
				let _g3 = node.data;
				let _g4 = node.isMacro;
				let _g5 = node.isInline;
				if (_g1 == null) {
					let pos = _g;
					let body = _g2;
					let data = _g3;
					let isMacro = _g4;
					let isInline = _g5;
					if (isInline) {
						if (data != null) {
							throw new CompilerError(ErrorUtil.formatContext("Inline block cannot have data", pos, context), false, [pos].concat(context.stack));
						} else {
							let _g = 0;
							while (_g < body.length) {
								let node = body[_g];
								++_g;
								this.compileCommand(node, context);
							};
						};
					} else {
						let context1 = context;
						let tmp = this.createAnonymousFunction(pos, body, data, context, null, isMacro);
						context1.append(tmp);
					};
				} else if (_g1 == "") {
					let pos = _g;
					let body = _g2;
					let data = _g3;
					let isMacro = _g4;
					let isInline = _g5;
					if (isInline) {
						if (data != null) {
							throw new CompilerError(ErrorUtil.formatContext("Inline block cannot have data", pos, context), false, [pos].concat(context.stack));
						} else {
							let _g = 0;
							while (_g < body.length) {
								let node = body[_g];
								++_g;
								this.compileCommand(node, context);
							};
						};
					} else {
						let context1 = context;
						let tmp = this.createAnonymousFunction(pos, body, data, context, null, isMacro);
						context1.append(tmp);
					};
				} else {
					let name = _g1;
					let pos = _g;
					let body = _g2;
					let data = _g3;
					let isMacro = _g4;
					let isInline = _g5;
					if (isInline) {
						if (data != null) {
							throw new CompilerError(ErrorUtil.formatContext("Inline block cannot have data", pos, context), false, [pos].concat(context.stack));
						} else {
							let _g = 0;
							while (_g < body.length) {
								let node = body[_g];
								++_g;
								this.compileCommand(node, context);
							};
						};
					} else {
						let context1 = context;
						let tmp = this.createAnonymousFunction(pos, body, data, context, name, isMacro);
						context1.append(tmp);
					};
				};
				break
			case 9:
				let pos4 = node.pos;
				let body2 = node.body;
				let functions = context.functions.concat([null]);
				let path = context.path;
				let newContext = {"append": function (v) {
					_gthis.tickCommands.push(v);
				}, "namespace": context.namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				let _g6 = 0;
				while (_g6 < body2.length) {
					let node = body2[_g6];
					++_g6;
					this.compileCommand(node, newContext);
				};
				break
			case 10:
				let pos5 = node.pos;
				let body3 = node.body;
				let functions1 = context.functions.concat([null]);
				let path1 = context.path;
				let newContext1 = {"append": function (v) {
					_gthis.loadCommands.push(v);
				}, "namespace": context.namespace, "path": (path1 == null) ? [] : path1, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions1, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				let _g7 = 0;
				while (_g7 < body3.length) {
					let node = body3[_g7];
					++_g7;
					this.compileCommand(node, newContext1);
				};
				break
			case 11:
				let pos6 = node.pos;
				let execute = node.execute;
				let data = node.data;
				let body4 = node.body;
				let continuations = node.continuations;
				let isMacro1 = node.isMacro;
				let commands = [];
				let append = function (command) {
					commands.push(command);
				};
				let uid = Std.string(context.uidIndex.get());
				let callSignature = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, uid]).join("/");
				let functions2 = context.functions.concat([callSignature]);
				let path2 = context.path;
				let newContext2 = {"append": append, "namespace": context.namespace, "path": (path2 == null) ? [] : path2, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions2, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				if (continuations != null) {
					context.append("scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 0");
					newContext2.append("scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 1");
				};
				let _g8 = 0;
				while (_g8 < body4.length) {
					let node = body4[_g8];
					++_g8;
					this.compileCommand(node, newContext2);
				};
				let result = commands.join("\n");
				let path3 = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, uid + ".mcfunction"])));
				let content = result;
				if (context.compiler.config.header.length > 0 && path3.endsWith(".mcfunction")) {
					content = context.compiler.config.header + "\n" + content;
				};
				context.compiler.io.write(path3, content);
				let context1 = context;
				let tmp = this.injectValues("" + ((isMacro1) ? "$" : "") + ("" + execute + " function " + callSignature + ((data == null) ? "" : " " + data)), context, pos6);
				context1.append(tmp);
				if (continuations != null) {
					let idx = 0;
					let _g = 0;
					while (_g < continuations.length) {
						let continuation = continuations[_g];
						++_g;
						let isDone = idx == continuations.length - 1;
						switch (continuation._hx_index) {
							case 8:
								let _g1 = continuation.pos;
								let _g2 = continuation.name;
								let _g3 = continuation.isInline;
								let body = continuation.body;
								let data = continuation.data;
								let isMacro2 = continuation.isMacro;
								let embedCommands = ["scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 1"];
								if (!isDone) {
									throw new CompilerError("block continuation must be the last continuation", true);
								};
								let appendEmbed = function (command) {
									embedCommands.push(command);
								};
								let id = Std.string(context.uidIndex.get());
								let callSignature = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id]).join("/");
								let functions = context.functions.concat([callSignature]);
								let path = context.path;
								let embedContext = {"append": appendEmbed, "namespace": context.namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
								let _g4 = 0;
								while (_g4 < body.length) {
									let node = body[_g4];
									++_g4;
									this.compileCommand(node, embedContext);
								};
								let result = embedCommands.join("\n");
								let path1 = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, id + ".mcfunction"])));
								let content = result;
								if (context.compiler.config.header.length > 0 && path1.endsWith(".mcfunction")) {
									content = context.compiler.config.header + "\n" + content;
								};
								context.compiler.io.write(path1, content);
								let context1 = context;
								let cmd = "execute if score #ifelse " + context.compiler.config.internalScoreboardName + " matches 0 run function " + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id]).join("/");
								context1.append("" + ((isMacro2) ? "$" : "") + (cmd + ((data == null) ? "" : " " + data)));
								break
							case 11:
								let _g5 = continuation.continuations;
								let pos = continuation.pos;
								let execute = continuation.execute;
								let data1 = continuation.data;
								let body1 = continuation.body;
								let isMacro21 = continuation.isMacro;
								let embedCommands1 = ["scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 1"];
								let embedAppend = function (command) {
									embedCommands1.push(command);
								};
								let id1 = Std.string(context.uidIndex.get());
								let callSignature1 = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id1]).join("/");
								let functions1 = context.functions.concat([callSignature1]);
								let path2 = context.path;
								let embedContext1 = {"append": embedAppend, "namespace": context.namespace, "path": (path2 == null) ? [] : path2, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions1, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
								let _g6 = 0;
								while (_g6 < body1.length) {
									let node = body1[_g6];
									++_g6;
									this.compileCommand(node, embedContext1);
								};
								let result1 = embedCommands1.join("\n");
								let path3 = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, id1 + ".mcfunction"])));
								let content1 = result1;
								if (context.compiler.config.header.length > 0 && path3.endsWith(".mcfunction")) {
									content1 = context.compiler.config.header + "\n" + content1;
								};
								context.compiler.io.write(path3, content1);
								let executeCommandArgs = (execute.startsWith("execute ")) ? execute.substring(8) : execute;
								let context2 = context;
								let cmd1 = "execute if score #ifelse " + context.compiler.config.internalScoreboardName + " matches 0 " + executeCommandArgs + " function " + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id1]).join("/");
								context2.append("" + ((isMacro21) ? "$" : "") + (cmd1 + ((data1 == null) ? "" : " " + data1)));
								break
							default:
							let pos1 = continuation.pos;
							throw new CompilerError(ErrorUtil.formatContext("Unexpected continuation type: " + Std.string(continuation), pos1, newContext2), false, [pos1].concat(newContext2.stack));
							
						};
						++idx;
					};
				};
				break
			case 12:
				let pos7 = node.pos;
				let delay = node.delay;
				let type = node.type;
				let body5 = node.body;
				let isMacro2 = node.isMacro;
				delay = this.injectValues(delay, context, pos7);
				type = this.injectValues(type, context, pos7);
				let commands1 = [];
				let append1 = function (command) {
					commands1.push(command);
				};
				let uid1 = Std.string(context.uidIndex.get());
				let callSignature1 = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, uid1]).join("/");
				let functions3 = context.functions.concat([callSignature1]);
				let path4 = context.path;
				let newContext3 = {"append": append1, "namespace": context.namespace, "path": (path4 == null) ? [] : path4, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions3, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				let _g9 = 0;
				while (_g9 < body5.length) {
					let node = body5[_g9];
					++_g9;
					this.compileCommand(node, newContext3);
				};
				let result1 = commands1.join("\n");
				let id = Std.string(context.uidIndex.get());
				let path5 = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, id + ".mcfunction"])));
				let content1 = result1;
				if (context.compiler.config.header.length > 0 && path5.endsWith(".mcfunction")) {
					content1 = context.compiler.config.header + "\n" + content1;
				};
				context.compiler.io.write(path5, content1);
				let context2 = context;
				let cmd = "schedule function " + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id]).join("/") + " " + delay + " " + type;
				context2.append("" + ((isMacro2) ? "$" : "") + cmd);
				break
			case 15:
				let _g10 = node.pos;
				let value2 = node.value;
				if (!context.compiler.config.dontEmitComments) {
					context.append(value2);
				};
				break
			case 19:
				let pos8 = node.pos;
				let command = node.command;
				let value3 = node.value;
				let isMacro3 = node.isMacro;
				let commands2 = [];
				let path6 = context.path;
				let newContext4 = {"append": function (v) {
					commands2.push(v);
				}, "namespace": context.namespace, "path": (path6 == null) ? [] : path6, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				this.compileCommand(value3, newContext4);
				if (commands2.length != 1) {
					throw new CompilerError(ErrorUtil.formatContext("Expected exactly 1 command after execute, got " + commands2.length, pos8, context), false, [pos8].concat(context.stack));
				};
				let context3 = context;
				let tmp1 = this.injectValues("" + ((isMacro3) ? "$" : "") + ("" + command + " " + commands2[0]), context, pos8);
				context3.append(tmp1);
				break
			case 20:
				let pos9 = node.pos;
				let name = node.name;
				let data1 = node.data;
				let isMacro4 = node.isMacro;
				let context4 = context;
				let cmd1 = "function " + this.evaluateFunctionHandle(name, context, pos9, isMacro4);
				let cmd2 = (data1.length == 0) ? "" : " " + this.injectValues(data1, context, pos9);
				let tmp2 = this.injectValues("" + ((isMacro4) ? "$" : "") + (cmd1 + cmd2), context, pos9);
				context4.append(tmp2);
				break
			case 21:
				let pos10 = node.pos;
				let command1 = node.command;
				let res = McMath.compile(this.injectValues(command1, context, pos10), context);
				context.append(res.commands);
				let addScoreboardCommand = "scoreboard objectives add " + context.compiler.config.eqConstScoreboardName + " dummy";
				if (!this.loadCommands.includes(addScoreboardCommand)) {
					this.loadCommands.push(addScoreboardCommand);
				};
				addScoreboardCommand = "scoreboard objectives add " + context.compiler.config.eqVarScoreboardName + " dummy";
				if (!this.loadCommands.includes(addScoreboardCommand)) {
					this.loadCommands.push(addScoreboardCommand);
				};
				let _g11 = 0;
				let _g12 = res.constants;
				while (_g11 < _g12.length) {
					let k = _g12[_g11];
					++_g11;
					let cmd = "scoreboard players set " + k + " " + context.compiler.config.eqConstScoreboardName + " " + k;
					if (!this.loadCommands.includes(cmd)) {
						this.loadCommands.push(cmd);
					};
				};
				break
			case 22:
				let pos11 = node.pos;
				let delay1 = node.delay;
				let name1 = node.target;
				let mode = node.mode;
				let isMacro5 = node.isMacro;
				delay1 = this.injectValues(delay1, context, pos11);
				mode = this.injectValues(mode, context, pos11);
				let context5 = context;
				let cmd3 = "schedule function " + this.evaluateFunctionHandle(name1, context, pos11, isMacro5) + " " + delay1 + " " + mode;
				context5.append("" + ((isMacro5) ? "$" : "") + cmd3);
				break
			case 23:
				let pos12 = node.pos;
				let value4 = node.value;
				let isMacro6 = node.isMacro;
				let content2 = [];
				let path7 = context.path;
				let newContext5 = {"append": function (v) {
					content2.push(v);
				}, "namespace": context.namespace, "path": (path7 == null) ? [] : path7, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				this.compileCommand(value4, newContext5);
				if (content2.length != 1) {
					throw new CompilerError(ErrorUtil.formatContext("Expected exactly 1 command after return run, got " + content2.length, pos12, context), false, [pos12].concat(context.stack));
				};
				context.append("" + ((isMacro6) ? "$" : "") + ("return run " + content2[0]));
				break
			case 24:
				let pos13 = node.pos;
				let name2 = node.target;
				let isMacro7 = node.isMacro;
				let context6 = context;
				let cmd4 = "schedule clear " + this.evaluateFunctionHandle(name2, context, pos13, isMacro7);
				context6.append("" + ((isMacro7) ? "$" : "") + cmd4);
				break
			default:
			debugger;
			console.log("src/mcl/Compiler.hx:1275:",Std.string(node));
			
		};
	}
	compileFunction(pos, name, body, appendTo, context) {
		name = this.injectValues(name, context, pos);
		let commands = [];
		let append = function (command) {
			commands.push(command);
		};
		let funcId = context.namespace + ":" + context.path.concat([name]).join("/");
		let functions = context.functions.concat([funcId]);
		let path = context.path;
		let newContext = {"append": append, "namespace": context.namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
		newContext.currentFunction = context.path;
		let _g = 0;
		while (_g < body.length) {
			let node = body[_g];
			++_g;
			this.compileCommand(node, newContext);
		};
		if (appendTo != null) {
			context.compiler.tags.addTagEntry(this.injectValues(appendTo, context, pos), funcId, context);
		};
		let path1 = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([name + ".mcfunction"])));
		let content = commands.join("\n");
		if (context.compiler.config.header.length > 0 && path1.endsWith(".mcfunction")) {
			content = context.compiler.config.header + "\n" + content;
		};
		context.compiler.io.write(path1, content);
	}
	compileDirectory(pos, name, body, context) {
		name = this.injectValues(name, context, pos);
		let namespace = context.namespace;
		let variableMap = context.variables;
		let path = context.path.concat([name]);
		let uidIndex = new UidTracker();
		let newContext = {"append": function (v) {
			throw new CompilerError(ErrorUtil.formatContext("append not available for directory context", pos, context), true, [pos].concat(context.stack));
		}, "namespace": namespace, "path": (path == null) ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
		let _g = 0;
		while (_g < body.length) {
			let node = body[_g];
			++_g;
			this.compileTld(node, newContext);
		};
	}
	transformTld(node, context) {
		let _gthis = this;
		switch (node._hx_index) {
			case 1:
				let pos = node.pos;
				let name = node.name;
				let body = node.body;
				let appendTo = node.appendTo;
				let tmp = this.injectValues(name, context, pos);
				let _g = [];
				let _g1 = 0;
				while (_g1 < body.length) {
					let node = body[_g1];
					++_g1;
					_g.push(this.transformCommand(node, context));
				};
				return AstNode.FunctionDef(pos, tmp, _g, appendTo);
				break
			case 3:
				let pos1 = node.pos;
				let name1 = node.name;
				let body1 = node.body;
				let tmp1 = this.injectValues(name1, context, pos1);
				let _g2 = [];
				let _g3 = 0;
				while (_g3 < body1.length) {
					let node = body1[_g3];
					++_g3;
					_g2.push(this.transformTld(node, context));
				};
				return AstNode.Directory(pos1, tmp1, _g2);
				break
			case 5:
				let pos2 = node.pos;
				let expression = node.expression;
				let as = node.as;
				let body2 = node.body;
				let results = [];
				this.processCompilerLoop(expression, as, context, body2, pos2, function (context, v) {
					results.push(_gthis.transformTld(v, context));
				});
				return AstNode.Group(results);
				break
			case 6:
				let pos3 = node.pos;
				let expression1 = node.expression;
				let body3 = node.body;
				let elseExpressions = node.elseExpressions;
				return this.transformCompileTimeIf(expression1, body3, elseExpressions, pos3, context, function (v) {
					return _gthis.transformTld(v, context);
				});
				break
			case 7:
				let pos4 = node.pos;
				let value = node.value;
				return this.processMlScriptTransform(context, pos4, value, true);
				break
			case 15:
				let _g4 = node.pos;
				let _g5 = node.value;
				return node;
				break
			case 16:
				let pos5 = node.pos;
				let name2 = node.name;
				let info = node.info;
				if (info._hx_index == 0) {
					let subType = info.subType;
					let replace = info.replace;
					let entries = info.entries;
					let _g = [];
					let _g1 = 0;
					while (_g1 < entries.length) {
						let e = entries[_g1];
						++_g1;
						let tmp;
						switch (e._hx_index) {
							case 0:
								let _g2 = e.continuations;
								if (_g2 == null) {
									throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
								} else if (_g2.length == 0) {
									if (e.isMacro == false) {
										let pos = e.pos;
										let value = e.value;
										tmp = this.injectValues(value, context, pos);
									} else {
										throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
									};
								} else {
									throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
								};
								break
							case 15:
								let pos = e.pos;
								let value = e.value;
								tmp = this.injectValues(value, context, pos);
								break
							default:
							throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
							
						};
						_g.push(AstNode.Raw(pos5, this.injectValues(tmp, context, pos5), [], false));
					};
					return AstNode.JsonFile(pos5, name2, JsonTagType.Tag(subType, replace, _g));
				} else {
					return AstNode.JsonFile(pos5, this.injectValues(name2, context, pos5), info);
				};
				break
			case 18:
				let pos6 = node.pos;
				let name3 = node.name;
				let time = node.time;
				let body4 = node.body;
				let _g6 = [];
				let _g7 = 0;
				while (_g7 < body4.length) {
					let node = body4[_g7];
					++_g7;
					_g6.push(this.transformCommand(node, context));
				};
				return AstNode.ClockExpr(pos6, name3, time, _g6);
				break
			default:
			let pos7 = node.pos;
			throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(node), pos7, context), true, [pos7].concat(context.stack));
			
		};
	}
	compileTld(node, context) {
		let _gthis = this;
		switch (node._hx_index) {
			case 1:
				let pos = node.pos;
				let name = node.name;
				let body = node.body;
				let appendTo = node.appendTo;
				if (!context.isTemplate) {
					this.compileFunction(pos, name, body, appendTo, context);
				} else {
					let pos = node.pos;
					throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(node), pos, context), true, [pos].concat(context.stack));
				};
				break
			case 3:
				let pos1 = node.pos;
				let name1 = node.name;
				let body1 = node.body;
				this.compileDirectory(pos1, name1, body1, context);
				break
			case 5:
				let pos2 = node.pos;
				let expression = node.expression;
				let as = node.as;
				let body2 = node.body;
				this.processCompilerLoop(expression, as, context, body2, pos2, function (context, v) {
					_gthis.compileTld(v, context);
				});
				break
			case 6:
				let pos3 = node.pos;
				let expression1 = node.expression;
				let body3 = node.body;
				let elseExpressions = node.elseExpressions;
				this.compileTimeIf(expression1, body3, elseExpressions, pos3, context, function (v) {
					_gthis.compileTld(v, context);
				});
				break
			case 7:
				let pos4 = node.pos;
				let value = node.value;
				this.processMlScript(context, pos4, value, true);
				break
			case 15:
				let _g = node.pos;
				let _g1 = node.value;
				break
			case 16:
				let pos5 = node.pos;
				let name2 = node.name;
				let info = node.info;
				this.compileJsonFile(pos5, name2, info, context);
				break
			case 18:
				let pos6 = node.pos;
				let name3 = node.name;
				let time = node.time;
				let body4 = node.body;
				let commands = [];
				let path = context.path;
				let newContext = {"append": function (v) {
					commands.push(v);
				}, "namespace": context.namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				let id = Std.string(context.uidIndex.get());
				let path1 = ((name3 == null) ? context.path.concat([context.compiler.config.generatedDirName, "" + id]) : context.path.concat([name3])).join("/");
				let functionId = context.namespace + ":" + path1;
				commands.push("schedule function " + functionId + " " + time + " replace");
				let _g2 = 0;
				while (_g2 < body4.length) {
					let node = body4[_g2];
					++_g2;
					this.compileCommand(node, newContext);
				};
				let result = commands.join("\n");
				let path2 = Path.join(["data", context.namespace, this.functionsDir, "" + path1 + ".mcfunction"]);
				let content = result;
				if (context.compiler.config.header.length > 0 && path2.endsWith(".mcfunction")) {
					content = context.compiler.config.header + "\n" + content;
				};
				context.compiler.io.write(path2, content);
				context.compiler.tags.addTagEntry("minecraft:load", functionId, context);
				break
			default:
			let pos7 = node.pos;
			throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(node), pos7, context), true, [pos7].concat(context.stack));
			
		};
	}
	compileJsonFileImpl(pos, name, info, entries, context) {
		let values = "{" + this.stringifyJsonTag(pos, name, entries, context) + "}";
		let type;
		switch (info._hx_index) {
			case 1:
				let _g = info.entries;
				type = (context.compiler.config.features.useFolderRenames48) ? "advancement" : "advancements";
				break
			case 2:
				let _g1 = info.entries;
				type = (context.compiler.config.features.useFolderRenames48) ? "item_modifier" : "item_modifiers";
				break
			case 3:
				let _g2 = info.entries;
				type = (context.compiler.config.features.useFolderRenames48) ? "loot_table" : "loot_tables";
				break
			case 4:
				let _g3 = info.entries;
				type = (context.compiler.config.features.useFolderRenames48) ? "predicate" : "predicates";
				break
			case 5:
				let _g4 = info.entries;
				type = (context.compiler.config.features.useFolderRenames48) ? "recipe" : "recipes";
				break
			case 6:
				let _g5 = info.entries;
				type = "chat";
				break
			case 7:
				let _g6 = info.entries;
				type = "damage";
				break
			case 8:
				let _g7 = info.entries;
				type = "dimension";
				break
			case 9:
				let _g8 = info.entries;
				type = "dimension_type";
				break
			case 10:
				let _g9 = info.entries;
				type = "enchantment";
				break
			default:
			throw new CompilerError(ErrorUtil.formatContext("unexpected json tag type:" + Std.string(info), pos, context), true, [pos].concat(context.stack));
			
		};
		let path = Path.join(["data", context.namespace, type].concat(context.path.concat([name + ".json"])));
		let content = values;
		if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
			content = context.compiler.config.header + "\n" + content;
		};
		context.compiler.io.write(path, content);
	}
	compileJsonFile(pos, name, info, context) {
		switch (info._hx_index) {
			case 0:
				let subType = info.subType;
				let replace = info.replace;
				let entries = info.entries;
				if (subType == "function" || subType == "functions") {
					name = context.namespace + ":" + context.path.concat([name]).join("/");
					context.compiler.tags.ensureTag(name, context);
					let _g = 0;
					while (_g < entries.length) {
						let e = entries[_g];
						++_g;
						switch (e._hx_index) {
							case 0:
								let _g1 = e.continuations;
								if (_g1 == null) {
									throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
								} else if (_g1.length == 0) {
									if (e.isMacro == false) {
										let pos = e.pos;
										let value = e.value;
										value = this.injectValues(value, context, pos);
										if (value.indexOf(" ") != -1 && value.endsWith(" replace")) {
											context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value.substring(0, value.length - 8), context, pos, false), context, true);
										} else if (value.indexOf(" ") != -1) {
											throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos, context), false, [pos].concat(context.stack));
										} else {
											context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value, context, pos, false), context, false);
										};
									} else {
										throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
									};
								} else {
									throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
								};
								break
							case 15:
								let pos1 = e.pos;
								let value = e.value;
								value = this.injectValues(value, context, pos1);
								if (value.indexOf(" ") != -1 && value.endsWith(" replace")) {
									context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value.substring(0, value.length - 8), context, pos1, false), context, true);
								} else if (value.indexOf(" ") != -1) {
									throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos1, context), false, [pos1].concat(context.stack));
								} else {
									context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value, context, pos1, false), context, false);
								};
								break
							default:
							throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
							
						};
					};
					if (replace) {
						context.compiler.tags.setTagReplace(name, context, true);
					};
				} else {
					let _g = [];
					let _g1 = 0;
					while (_g1 < entries.length) {
						let e = entries[_g1];
						++_g1;
						let data;
						switch (e._hx_index) {
							case 0:
								let _g2 = e.continuations;
								if (_g2 == null) {
									throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
								} else if (_g2.length == 0) {
									if (e.isMacro == false) {
										let pos = e.pos;
										let value = e.value;
										value = this.injectValues(value, context, pos);
										if (value.indexOf(" ") != -1 && value.endsWith(" replace")) {
											data = {"id": this.evaluateFunctionHandle(value.substring(0, value.length - 8), context, pos, false), "replace": true};
										} else if (value.indexOf(" ") != -1) {
											throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos, context), false, [pos].concat(context.stack));
										} else {
											data = this.evaluateFunctionHandle(value, context, pos, false);
										};
									} else {
										throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
									};
								} else {
									throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
								};
								break
							case 15:
								let pos1 = e.pos;
								let value = e.value;
								value = this.injectValues(value, context, pos1);
								if (value.indexOf(" ") != -1 && value.endsWith(" replace")) {
									data = {"id": this.evaluateFunctionHandle(value.substring(0, value.length - 8), context, pos1, false), "replace": true};
								} else if (value.indexOf(" ") != -1) {
									throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos1, context), false, [pos1].concat(context.stack));
								} else {
									data = this.evaluateFunctionHandle(value, context, pos1, false);
								};
								break
							default:
							throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
							
						};
						_g.push(data);
					};
					let data = JSON.stringify({"replace": replace, "values": _g});
					let isPlural = subType.charAt(subType.length - 1) == "s";
					let writePath = (context.compiler.config.features.useFolderRenames48) ? (isPlural) ? subType.substring(0, subType.length - 1) : subType : (isPlural) ? subType : subType + "s";
					let path = Path.join(["data", context.namespace, this.tagsDir, writePath].concat(context.path.concat([name + ".json"])));
					let content = data;
					if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
						content = context.compiler.config.header + "\n" + content;
					};
					context.compiler.io.write(path, content);
				};
				break
			case 1:
				let entries1 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries1, context);
				break
			case 2:
				let entries2 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries2, context);
				break
			case 3:
				let entries3 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries3, context);
				break
			case 4:
				let entries4 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries4, context);
				break
			case 5:
				let entries5 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries5, context);
				break
			case 6:
				let entries6 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries6, context);
				break
			case 7:
				let entries7 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries7, context);
				break
			case 8:
				let entries8 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries8, context);
				break
			case 9:
				let entries9 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries9, context);
				break
			case 10:
				let entries10 = info.entries;
				this.compileJsonFileImpl(pos, name, info, entries10, context);
				break
			case 11:
				let subType1 = info.subType;
				let name1 = info.name;
				let entries11 = info.entries;
				let values = "{" + this.stringifyJsonTag(pos, name1, entries11, context) + "}";
				let path = Path.join(["data", context.namespace, "worldgen", subType1].concat(context.path.concat([name1 + ".json"])));
				let content = values;
				if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
					content = context.compiler.config.header + "\n" + content;
				};
				context.compiler.io.write(path, content);
				break
			
		};
	}
	processCompilerLoop(expression, as, context, body, pos, handler) {
		let itterator = McFile.invokeExpressionInline(expression, context, pos);
		let v = itterator;
		while (v.hasNext()) {
			let v1 = v.next();
			if (as == null) {
				let _g = 0;
				while (_g < body.length) {
					let node = body[_g];
					++_g;
					handler(context, node);
				};
			} else {
				let varMap = new StringMap();
				if (as.length == 1) {
					varMap.inst.set(as[0], v1);
				} else if (Array.isArray(as)) {
					if (v1.length < as.length) {
						throw new CompilerError(ErrorUtil.formatContext("Failed to destructure as there are fewer elements then requested", pos, context), false, [pos].concat(context.stack));
					};
					let _g = 0;
					let _g1 = as.length;
					while (_g < _g1) {
						let i = _g++;
						varMap.inst.set(as[i], v1[i]);
					};
				} else {
					throw new CompilerError(ErrorUtil.formatContext("Invalid as clause", pos, context), false, [pos].concat(context.stack));
				};
				let namespace = context.namespace;
				let append = context.append;
				let _this = context.variables;
				let variableMap = (varMap == null) ? _this : new VariableMap(_this, varMap);
				let path = context.path;
				let newContext = {"append": append, "namespace": namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.variables, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
				let _g = 0;
				while (_g < body.length) {
					let node = body[_g];
					++_g;
					handler(newContext, node);
				};
			};
		};
	}
	stringifyJsonTag(pos, name, value, context) {
		name = this.injectValues(name, context, pos);
		let values = [];
		let path = context.path;
		let newContext = {"append": function (v) {
			values.push(v);
		}, "namespace": context.namespace, "path": (path == null) ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction};
		let _gthis = this;
		let _g = 0;
		while (_g < value.length) {
			let v = value[_g];
			++_g;
			switch (v._hx_index) {
				case 0:
					if (v.isMacro == false) {
						let extra = v.continuations;
						let value = v.value;
						let pos = v.pos;
						if (extra != null && extra.length > 0) {
							throw new CompilerError(ErrorUtil.formatContext("Unexpected extra data in json tag", pos, context), false, [pos].concat(context.stack));
						};
						values.push(this.injectValues(value, context, pos));
					} else {
						let pos = v.pos;
						throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(v), pos, context), true, [pos].concat(context.stack));
					};
					break
				case 5:
					let pos = v.pos;
					let expression = v.expression;
					let as = v.as;
					let body = v.body;
					this.processCompilerLoop(expression, as, context, body, pos, function (context, v) {
						_gthis.compileCommand(v, context);
					});
					break
				case 6:
					let pos1 = v.pos;
					let expression1 = v.expression;
					let body1 = v.body;
					let elseExpression = v.elseExpressions;
					this.compileTimeIf(expression1, body1, elseExpression, pos1, newContext, function (v) {
						_gthis.compileCommand(v, context);
					});
					break
				default:
				let pos2 = v.pos;
				throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(v), pos2, context), true, [pos2].concat(context.stack));
				
			};
		};
		return values.join("");
	}
	injectValues(target, context, pos) {
		if (target == null) {
			return "";
		};
		if (target.indexOf("<%") == -1) {
			return target;
		};
		let variables = context.variables.get();
		let argList = ["embed", "context"];
		let _gthis = this;
		let valueList = [function (v) {
			return v.embedTo(context, pos, _gthis);
		}, context];
		let map = variables;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			argList.push(k);
			valueList.push(v);
		};
		let segments = [];
		let values = [];
		let _g = 0;
		let _g1 = target.split("<%");
		while (_g < _g1.length) {
			let segment = _g1[_g];
			++_g;
			let parts = segment.split("%>");
			if (parts.length == 1) {
				values.push(parts[0]);
				segments.push("$$context" + "[" + Std.string(values.length - 1) + "]");
			} else {
				segments.push(parts[0]);
				values.push(parts[1]);
				segments.push("$$context" + "[" + Std.string(values.length - 1) + "]");
			};
		};
		let code = "return ([" + segments.join(",") + "].join(''));";
		try {
			return new Function(...argList,"$$context",code).apply(null, valueList.concat([values]));;
		}catch (_g) {
			let e = Exception.caught(_g);
			throw new CompilerError(ErrorUtil.formatContext(Parser.format("Encountered an error whilst evaluating expression '{}' at {}:{}:{}", e.get_message(), pos.file, pos.line, pos.col + 1), pos, context), false, [pos].concat(context.stack));
		};
	}
	transformCompileTimeIf(expression, body, elseExpression, pos, newContext, processNode, isContinuation) {
		if (isContinuation == null) {
			isContinuation = false;
		};
		let bool = McFile.invokeExpressionInline(expression, newContext, pos);
		if (bool) {
			let _g = [];
			let _g1 = 0;
			while (_g1 < body.length) {
				let node = body[_g1];
				++_g1;
				_g.push(processNode(node));
			};
			return AstNode.Group(_g);
		} else {
			let _g = 0;
			while (_g < elseExpression.length) {
				let elseNode = elseExpression[_g];
				++_g;
				let invoke = (elseNode.condition == null) ? true : McFile.invokeExpressionInline(elseNode.condition, newContext, pos);
				if (invoke) {
					let _g = [];
					let _g1 = 0;
					let _g2 = elseNode.node;
					while (_g1 < _g2.length) {
						let node = _g2[_g1];
						++_g1;
						_g.push(processNode(node));
					};
					return AstNode.Group(_g);
				};
			};
			return AstNode.Void;
		};
	}
	compileTimeIf(expression, body, elseExpression, pos, newContext, processNode, isContinuation) {
		if (isContinuation == null) {
			isContinuation = false;
		};
		let bool = McFile.invokeExpressionInline(expression, newContext, pos);
		if (bool) {
			let _g = 0;
			while (_g < body.length) {
				let node = body[_g];
				++_g;
				processNode(node);
			};
		} else {
			let _g = 0;
			while (_g < elseExpression.length) {
				let elseNode = elseExpression[_g];
				++_g;
				let invoke = (elseNode.condition == null) ? true : McFile.invokeExpressionInline(elseNode.condition, newContext, pos);
				if (invoke) {
					let _g = 0;
					let _g1 = elseNode.node;
					while (_g < _g1.length) {
						let node = _g1[_g];
						++_g;
						processNode(node);
					};
					return;
				};
			};
		};
	}
	transform(vars, compiler) {
		let info = compiler.getInitialPathInfo(this.name);
		let _g = new StringMap();
		let _g1 = 0;
		let _g2 = Reflect__1.fields(this.fileJs);
		while (_g1 < _g2.length) {
			let k = _g2[_g1];
			++_g1;
			_g.inst.set(k, Reflect__1.field(this.fileJs, k));
		};
		let thisFileVars = new VariableMap(vars, _g);
		let namespace = info.namespace;
		let variableMap = new VariableMap(thisFileVars, Globals.map);
		let path = info.path;
		let uidIndex = new UidTracker();
		let replacements = new VariableMap(null, new StringMap());
		let context = {"append": function (v) {
			throw new CompilerError("append not available for top-level context", true);
		}, "namespace": namespace, "path": (path == null) ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": [], "replacements": replacements, "isTemplate": this.ext == "mcbt", "templates": this.templates, "requireTemplateKeyword": this.ext == "mcbt", "compiler": compiler, "globalVariables": thisFileVars, "functions": [], "baseNamespaceInfo": info, "currentFunction": null};
		if (context.isTemplate) {
			if (this.ast.length > 0) {
				let pos = this.ast[0].pos;
				throw new CompilerError(ErrorUtil.formatContext("Unexpected top-level content in template file", pos, context), false, [pos].concat(context.stack));
			};
			return [AstNode.Void];
		};
		let _g3 = [];
		let _g4 = 0;
		let _g5 = this.ast;
		while (_g4 < _g5.length) {
			let node = _g5[_g4];
			++_g4;
			let tmp;
			switch (node._hx_index) {
				case 2:
					let _g = node.pos;
					let _g1 = node.name;
					let _g2 = node.body;
					throw new CompilerError("import or template definition found after setup", true);
					break
				case 4:
					let _g6 = node.pos;
					let _g7 = node.name;
					throw new CompilerError("import or template definition found after setup", true);
					break
				default:
				tmp = this.transformTld(node, context);
				
			};
			_g3.push(tmp);
		};
		return _g3;
	}
	compile(vars, compiler) {
		let info = compiler.getInitialPathInfo(this.name);
		let _g = new StringMap();
		let _g1 = 0;
		let _g2 = Reflect__1.fields(this.fileJs);
		while (_g1 < _g2.length) {
			let k = _g2[_g1];
			++_g1;
			_g.inst.set(k, Reflect__1.field(this.fileJs, k));
		};
		let thisFileVars = new VariableMap(vars, _g);
		let namespace = info.namespace;
		let variableMap = new VariableMap(thisFileVars, Globals.map);
		let path = info.path;
		let uidIndex = new UidTracker();
		let replacements = new VariableMap(null, new StringMap());
		let context = {"append": function (v) {
			throw new CompilerError("append not available for top-level context", true);
		}, "namespace": namespace, "path": (path == null) ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": [], "replacements": replacements, "isTemplate": this.ext == "mcbt", "templates": this.templates, "requireTemplateKeyword": this.ext == "mcbt", "compiler": compiler, "globalVariables": thisFileVars, "functions": [], "baseNamespaceInfo": info, "currentFunction": null};
		if (context.isTemplate) {
			if (this.ast.length > 0) {
				let pos = this.ast[0].pos;
				throw new CompilerError(ErrorUtil.formatContext("Unexpected top-level content in template file", pos, context), false, [pos].concat(context.stack));
			};
			return;
		};
		let _g3 = 0;
		let _g4 = this.ast;
		while (_g3 < _g4.length) {
			let node = _g4[_g3];
			++_g3;
			switch (node._hx_index) {
				case 2:
					let _g = node.pos;
					let _g1 = node.name;
					let _g2 = node.body;
					throw new CompilerError("import or template definition found after setup", true);
					break
				case 4:
					let _g5 = node.pos;
					let _g6 = node.name;
					throw new CompilerError("import or template definition found after setup", true);
					break
				default:
				this.compileTld(node, context);
				
			};
		};
		if (this.loadCommands.length > 0) {
			let path = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, "load.mcfunction"])));
			let content = this.loadCommands.join("\n");
			if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
				content = context.compiler.config.header + "\n" + content;
			};
			context.compiler.io.write(path, content);
			compiler.tags.addTagEntry("minecraft:load", context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, "load"]).join("/"), context);
		};
		if (this.tickCommands.length > 0) {
			let path = Path.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, "tick.mcfunction"])));
			let content = this.tickCommands.join("\n");
			if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
				content = context.compiler.config.header + "\n" + content;
			};
			context.compiler.io.write(path, content);
			compiler.tags.addTagEntry("minecraft:tick", context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, "tick"]).join("/"), context);
		};
	}
	static invokeExpressionInline(expression, context, pos) {
		let variables = context.variables.get();
		let argList = ["context"];
		let valueList = [context];
		let map = variables;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			argList.push(k);
			valueList.push(v);
		};
		let code = "return (" + expression + ");";
		try {
			return new Function(...argList,code).apply(null, valueList);;
		}catch (_g) {
			let e = Exception.caught(_g);
			throw new CompilerError(ErrorUtil.formatContext(Parser.format("Encountered an error whilst evaluating expression '{}' at {}:{}:{}", e.get_message(), pos.file, pos.line, pos.col + 1), pos, context), false, [pos].concat(context.stack));
		};
	}
	static get __name__() {
		return "mcl.McFile"
	}
	get __class__() {
		return McFile
	}
}


export const Compiler = Register.global("$hxClasses")["mcl.Compiler"] = 
class Compiler extends Register.inherits() {
	new(baseDir, config, lib) {
		this.topLevelAstNodes = new Array();
		this.success = true;
		this.templateParsingEnabled = true;
		this.disableRequire = false;
		this.packNamespace = "mcb-" + Std.string(new Date());
		this.tags = new TagManager();
		this.libStore = null;
		this.alreadySetupFiles = new StringMap();
		this.files = new StringMap();
		this.io = new SyncIo();
		this.config = Config.create(config);
		this.baseDir = baseDir;
		this.libStore = lib;
	}
	addFile(name, ast) {
		let file = new McFile(name, ast);
		this.files.inst.set(name, file);
	}
	resolve(baseFile, resolutionPath) {
		if (resolutionPath.charAt(0) == "." || resolutionPath.charAt(0) == "/") {
			let base;
			if (resolutionPath.charAt(0) == "/") {
				resolutionPath = resolutionPath.substring(1);
				base = this.baseDir;
			} else {
				base = Path.directory(baseFile);
			};
			let resolved = Path.join([base, resolutionPath]);
			let ext = Path.extension(resolutionPath);
			if (ext.endsWith("js") || ext == "json") {
				return ImportFileType.IJsFile(require(resolved));
			};
			if (this.files.inst.has(resolved)) {
				if (!this.alreadySetupFiles.inst.has(resolved)) {
					this.alreadySetupFiles.inst.set(resolved, true);
					this.files.inst.get(resolved).setup(this);
				};
				return ImportFileType.IMcFile(this.files.inst.get(resolved));
			};
			throw new CompilerError("Failed to resolve import: " + resolved, false);
		} else {
			return ImportFileType.IMcFile(this.libStore.lookup(resolutionPath, {"file": baseFile, "line": 0, "col": 0}, this));
		};
	}
	getInitialPathInfo(p) {
		let projectPath = ((p.startsWith(this.baseDir)) ? p.substring(this.baseDir.length) : p).split("\\").join("/");
		if (projectPath.charAt(0) == "/") {
			projectPath = projectPath.substring(1);
		};
		let parts = projectPath.split("/");
		let namespace = Path.withoutExtension(parts[0]);
		let path = parts.slice(1).join("/");
		return {"namespace": namespace, "path": (parts.length > 1) ? Path.withoutExtension(path).split("/") : []};
	}
	compile(root) {
		this.success = true;
		try {
			let file = EsMap.adaptIterator(this.files.inst.values());
			while (file.hasNext()) {
				let file1 = file.next();
				if (this.alreadySetupFiles.inst.has(file1.name)) {
					continue;
				};
				file1.setup(this);
			};
			let file1 = EsMap.adaptIterator(this.files.inst.values());
			while (file1.hasNext()) {
				let file = file1.next();
				file.compile(root, this);
			};
			this.tags.writeTagFiles(this);
		}catch (_g) {
			let e = Exception.caught(_g).unwrap();
			this.success = false;
			throw Exception.thrown(e);
		};
	}
	transform(root) {
		let result = new Map();
		let file = EsMap.adaptIterator(this.files.inst.values());
		while (file.hasNext()) {
			let file1 = file.next();
			if (this.alreadySetupFiles.inst.has(file1.name)) {
				continue;
			};
			file1.setup(this);
		};
		let file1 = EsMap.adaptIterator(this.files.inst.values());
		while (file1.hasNext()) {
			let file = file1.next();
			this.topLevelAstNodes = [];
			result.set(file.name, AstNode.Group(file.transform(root, this).concat(this.topLevelAstNodes)));
		};
		return result;
	}
	addTopLevelAstNode(node) {
		this.topLevelAstNodes.push(node);
	}
	static get __name__() {
		return "mcl.Compiler"
	}
	get __class__() {
		return Compiler
	}
}

