import {Exception} from "../haxe/Exception.js"
import {Register} from "../genes/Register.js"
import {Std} from "../Std.js"
import {Reflect as Reflect__1} from "../Reflect.js"

const $global = Register.$global

export const AstStringifier = Register.global("$hxClasses")["mcl.AstStringifier"] = 
class AstStringifier extends Register.inherits() {
	new() {
		this.tabs = [""];
		this.indent = 0;
		this.segments = [];
	}
	tab() {
		let tab;
		if (this.tabs.length > this.indent) {
			tab = this.tabs[this.indent];
		} else {
			let s = this.tabs[this.tabs.length - 1];
			let _g = this.tabs.length - 1;
			let _g1 = this.indent;
			while (_g < _g1) {
				let i = _g++;
				this.tabs[i] = s;
				s += "\t";
			};
			tab = s;
		};
		this.segments.push(tab);
	}
	inc() {
		this.indent++;
	}
	dec() {
		this.indent--;
	}
	literal(s) {
		this.segments.push(s);
	}
	write(node, indent, hideBlock) {
		if (indent == null) {
			indent = true;
		};
		if (hideBlock == null) {
			hideBlock = false;
		};
		if (!indent && this.segments[this.segments.length - 1].endsWith("\\")) {
			this.segments.push("\n");
			indent = true;
		};
		switch (node._hx_index) {
			case 0:
				let pos = node.pos;
				let value = node.value;
				let continuations = node.continuations;
				let isMacro = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro) {
					this.segments.push("$");
				};
				this.segments.push(value);
				if (continuations.length > 0) {
					throw Exception.thrown("continuations not supported");
				};
				this.segments.push("\n");
				break
			case 1:
				let pos1 = node.pos;
				let name = node.name;
				let body = node.body;
				let appendTo = node.appendTo;
				if (indent) {
					this.tab();
				};
				this.segments.push("function ");
				this.segments.push(name);
				if (appendTo != null) {
					this.segments.push(" ");
					this.segments.push(appendTo);
				};
				this.segments.push("{\n");
				this.inc();
				let _g = 0;
				while (_g < body.length) {
					let child = body[_g];
					++_g;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}\n");
				break
			case 2:
				let pos2 = node.pos;
				let name1 = node.name;
				let body1 = node.body;
				throw Exception.thrown("template def not supported");
				break
			case 3:
				let pos3 = node.pos;
				let name2 = node.name;
				let body2 = node.body;
				if (indent) {
					this.tab();
				};
				this.segments.push("dir ");
				this.segments.push(name2);
				this.segments.push("{\n");
				this.inc();
				let _g1 = 0;
				while (_g1 < body2.length) {
					let child = body2[_g1];
					++_g1;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}\n");
				break
			case 4:
				let pos4 = node.pos;
				let name3 = node.name;
				if (indent) {
					this.tab();
				};
				this.segments.push("import ");
				this.segments.push(name3);
				this.segments.push("\n");
				break
			case 5:
				let pos5 = node.pos;
				let expression = node.expression;
				let as = node.as;
				let body3 = node.body;
				if (indent) {
					this.tab();
				};
				this.segments.push("REPEAT(" + expression + ") as " + Std.string(as) + " {");
				this.inc();
				let _g2 = 0;
				while (_g2 < body3.length) {
					let child = body3[_g2];
					++_g2;
					this.write(child);
				};
				this.dec();
				this.segments.push("}\n");
				break
			case 6:
				let pos6 = node.pos;
				let expression1 = node.expression;
				let body4 = node.body;
				let elseExpressions = node.elseExpressions;
				if (indent) {
					this.tab();
				};
				this.segments.push("IF(" + expression1 + ") {");
				this.inc();
				let _g3 = 0;
				while (_g3 < body4.length) {
					let child = body4[_g3];
					++_g3;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}");
				let _g4 = 0;
				while (_g4 < elseExpressions.length) {
					let elseExpression = elseExpressions[_g4];
					++_g4;
					this.segments.push(" ELSE " + ((elseExpression.condition == null) ? "IF(" + elseExpression.condition + ")" : "") + " {");
					this.inc();
					let _g = 0;
					let _g1 = elseExpression.node;
					while (_g < _g1.length) {
						let child = _g1[_g];
						++_g;
						this.write(child);
					};
					this.dec();
					this.tab();
					this.segments.push("}");
				};
				this.segments.push("\n");
				break
			case 7:
				let pos7 = node.pos;
				let value1 = node.value;
				throw Exception.thrown("multi line script not supported");
				break
			case 8:
				let pos8 = node.pos;
				let name4 = node.name;
				let body5 = node.body;
				let data = node.data;
				let isMacro1 = node.isMacro;
				let isInline = node.isInline;
				if (indent) {
					this.tab();
				};
				if (isMacro1 && !hideBlock) {
					this.segments.push("$");
				};
				if (!hideBlock) {
					this.segments.push("block");
				};
				if (name4 != null && name4 != "") {
					this.segments.push(" ");
					this.segments.push(name4);
					this.segments.push(" ");
				};
				this.segments.push("{" + ((data == null) ? "" : " " + data) + "\n");
				this.inc();
				let _g5 = 0;
				while (_g5 < body5.length) {
					let child = body5[_g5];
					++_g5;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}");
				if (indent) {
					this.segments.push("\n");
				};
				break
			case 9:
				let pos9 = node.pos;
				let body6 = node.body;
				if (indent) {
					this.tab();
				};
				this.segments.push("tick {\n");
				this.inc();
				let _g6 = 0;
				while (_g6 < body6.length) {
					let child = body6[_g6];
					++_g6;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}\n");
				break
			case 10:
				let pos10 = node.pos;
				let body7 = node.body;
				if (indent) {
					this.tab();
				};
				this.segments.push("load {\n");
				this.inc();
				let _g7 = 0;
				while (_g7 < body7.length) {
					let child = body7[_g7];
					++_g7;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}\n");
				break
			case 11:
				let pos11 = node.pos;
				let execute = node.execute;
				let data1 = node.data;
				let body8 = node.body;
				let continuations1 = node.continuations;
				let isMacro2 = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro2) {
					this.segments.push("$");
				};
				this.segments.push(execute);
				this.segments.push(" {" + ((data1 == null) ? "" : " " + data1) + "\n");
				this.inc();
				let _g8 = 0;
				while (_g8 < body8.length) {
					let child = body8[_g8];
					++_g8;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}");
				let i = 0;
				let lastI = continuations1.length - 1;
				let _g9 = 0;
				while (_g9 < continuations1.length) {
					let continuation = continuations1[_g9];
					++_g9;
					if (continuation._hx_index == 8) {
						let _g = continuation.pos;
						let _g1 = continuation.name;
						let _g2 = continuation.body;
						let _g3 = continuation.data;
						let _g4 = continuation.isMacro;
						let _g5 = continuation.isInline;
						if (_g1 == null) {
							let pos = _g;
							let body = _g2;
							let data = _g3;
							let isMacro = _g4;
							let isInline = _g5;
							this.segments.push(" else " + ((isMacro) ? "$" : "") + "run ");
							this.write(continuation, false, true);
						} else if (_g1 == "") {
							let pos = _g;
							let body = _g2;
							let data = _g3;
							let isMacro = _g4;
							let isInline = _g5;
							this.segments.push(" else " + ((isMacro) ? "$" : "") + "run ");
							this.write(continuation, false, true);
						} else {
							this.segments.push(" else ");
							this.write(continuation, false, true);
						};
					} else {
						this.segments.push(" else ");
						this.write(continuation, false, true);
					};
					++i;
				};
				if (indent) {
					this.segments.push("\n");
				};
				break
			case 12:
				let pos12 = node.pos;
				let delay = node.delay;
				let type = node.type;
				let body9 = node.body;
				let isMacro3 = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro3) {
					this.segments.push("$");
				};
				this.segments.push("schedule ");
				this.segments.push(delay);
				this.segments.push(" ");
				this.segments.push(type);
				this.segments.push(" {\n");
				this.inc();
				let _g10 = 0;
				while (_g10 < body9.length) {
					let child = body9[_g10];
					++_g10;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}\n");
				break
			case 15:
				let pos13 = node.pos;
				let value2 = node.value;
				if (indent) {
					this.tab();
				};
				this.segments.push("# ");
				this.segments.push(value2);
				this.segments.push("\n");
				break
			case 16:
				let pos14 = node.pos;
				let name5 = node.name;
				let info = node.info;
				this.tab();
				switch (info._hx_index) {
					case 0:
						let subType = info.subType;
						let replace = info.replace;
						let entries = info.entries;
						this.segments.push("tag ");
						this.segments.push(subType);
						this.segments.push(" ");
						this.segments.push(name5);
						if (replace) {
							this.segments.push(" replace");
						};
						this.segments.push(" {\n");
						this.inc();
						let _g11 = 0;
						while (_g11 < entries.length) {
							let entry = entries[_g11];
							++_g11;
							this.write(entry);
						};
						this.dec();
						this.tab();
						this.segments.push("}\n");
						break
					case 11:
						let subType1 = info.subType;
						let name6 = info.name;
						let entries1 = info.entries;
						this.segments.push("worldgen ");
						this.segments.push(name6);
						this.segments.push(" {\n");
						this.inc();
						let _g12 = 0;
						while (_g12 < entries1.length) {
							let entry = entries1[_g12];
							++_g12;
							this.write(entry);
						};
						this.dec();
						this.tab();
						this.segments.push("}\n");
						break
					default:
					let node1 = info;
					let entries2 = Reflect__1.getProperty(node1, "entries");
					this.segments.push(Std.string(node1));
					
				};
				break
			case 18:
				let pos15 = node.pos;
				let name7 = node.name;
				let time = node.time;
				let body10 = node.body;
				if (indent) {
					this.tab();
				};
				this.segments.push("clock ");
				this.segments.push(name7);
				this.segments.push(" ");
				this.segments.push(time);
				this.segments.push(" {\n");
				this.inc();
				let _g13 = 0;
				while (_g13 < body10.length) {
					let child = body10[_g13];
					++_g13;
					this.write(child);
				};
				this.dec();
				this.tab();
				this.segments.push("}\n");
				break
			case 19:
				let pos16 = node.pos;
				let command = node.command;
				let value3 = node.value;
				let isMacro4 = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro4) {
					this.segments.push("$");
				};
				this.segments.push(command);
				this.segments.push(" ");
				this.write(value3, false);
				this.segments.push("\n");
				break
			case 20:
				let pos17 = node.pos;
				let name8 = node.name;
				let data2 = node.data;
				let isMacro5 = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro5) {
					this.segments.push("$");
				};
				this.segments.push("function ");
				this.segments.push(name8);
				if (data2 != null && data2 != "") {
					this.segments.push(" ");
					this.segments.push(data2);
				};
				this.segments.push("\n");
				break
			case 21:
				let pos18 = node.pos;
				let command1 = node.command;
				if (indent) {
					this.tab();
				};
				this.segments.push("eq " + command1);
				this.segments.push("\n");
				break
			case 22:
				let pos19 = node.pos;
				let delay1 = node.delay;
				let target = node.target;
				let mode = node.mode;
				let isMacro6 = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro6) {
					this.segments.push("$");
				};
				this.segments.push("schedule function ");
				this.segments.push(target);
				this.segments.push(" ");
				this.segments.push(delay1);
				this.segments.push(" ");
				this.segments.push(mode);
				this.segments.push("\n");
				break
			case 23:
				let pos20 = node.pos;
				let value4 = node.value;
				let isMacro7 = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro7) {
					this.segments.push("$");
				};
				this.segments.push("return run ");
				this.inc();
				this.write(value4, false, true);
				this.dec();
				this.segments.push("\n");
				break
			case 24:
				let pos21 = node.pos;
				let target1 = node.target;
				let isMacro8 = node.isMacro;
				if (indent) {
					this.tab();
				};
				if (isMacro8) {
					this.segments.push("$");
				};
				this.segments.push("schedule clear ");
				this.segments.push(target1);
				this.segments.push("\n");
				break
			case 25:
				break
			case 26:
				let body11 = node.body;
				let isInline1 = indent == false;
				let _g14 = 0;
				while (_g14 < body11.length) {
					let child = body11[_g14];
					++_g14;
					if (!indent && !isInline1) {
						throw Exception.thrown("Group should not have multiple children if the location is inline");
					};
					this.write(child, indent);
					isInline1 = false;
				};
				break
			default:
			throw Exception.thrown("unknown node type: " + Std.string(node));
			
		};
	}
	toString(node) {
		this.write(node);
		return this.segments.join("");
	}
	static stringify(node) {
		return new AstStringifier().toString(node);
	}
	static get __name__() {
		return "mcl.AstStringifier"
	}
	get __class__() {
		return AstStringifier
	}
}

