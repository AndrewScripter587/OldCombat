import {ValueType} from "../haxpression/ValueType.js"
import {Parser} from "../haxpression/Parser.js"
import {ExpressionType} from "../haxpression/ExpressionType.js"
import {Expression} from "../haxpression/Expression.js"
import {StringMap} from "../haxe/ds/StringMap.js"
import {Exception} from "../haxe/Exception.js"
import {EsMap} from "../genes/util/EsMap.js"
import {Register} from "../genes/Register.js"
import {Std} from "../Std.js"
import {HxOverrides} from "../HxOverrides.js"

const $global = Register.$global

export const FlattenedType = 
Register.global("$hxEnums")["mcl.FlattenedType"] = 
{
	__ename__: "mcl.FlattenedType",
	
	FLiteral: Object.assign((value) => ({_hx_index: 0, __enum__: "mcl.FlattenedType", "value": value, "@kind": "FLiteral"}), {_hx_name: "FLiteral", __params__: ["value"]}),
	FIdentifier: Object.assign((name) => ({_hx_index: 1, __enum__: "mcl.FlattenedType", "name": name, "@kind": "FIdentifier"}), {_hx_name: "FIdentifier", __params__: ["name"]}),
	FUnary: Object.assign((operant, operand) => ({_hx_index: 2, __enum__: "mcl.FlattenedType", "operant": operant, "operand": operand, "@kind": "FUnary"}), {_hx_name: "FUnary", __params__: ["operant", "operand"]}),
	FBinary: Object.assign((operant, left, right) => ({_hx_index: 3, __enum__: "mcl.FlattenedType", "operant": operant, "left": left, "right": right, "@kind": "FBinary"}), {_hx_name: "FBinary", __params__: ["operant", "left", "right"]}),
	FAdd: Object.assign((item) => ({_hx_index: 4, __enum__: "mcl.FlattenedType", "item": item, "@kind": "FAdd"}), {_hx_name: "FAdd", __params__: ["item"]}),
	FMul: Object.assign((item) => ({_hx_index: 5, __enum__: "mcl.FlattenedType", "item": item, "@kind": "FMul"}), {_hx_name: "FMul", __params__: ["item"]}),
	FCall: Object.assign((callee, args) => ({_hx_index: 6, __enum__: "mcl.FlattenedType", "callee": callee, "args": args, "@kind": "FCall"}), {_hx_name: "FCall", __params__: ["callee", "args"]}),
	FConditional: Object.assign((test, consequent, alternate) => ({_hx_index: 7, __enum__: "mcl.FlattenedType", "test": test, "consequent": consequent, "alternate": alternate, "@kind": "FConditional"}), {_hx_name: "FConditional", __params__: ["test", "consequent", "alternate"]}),
	FArray: Object.assign((items) => ({_hx_index: 8, __enum__: "mcl.FlattenedType", "items": items, "@kind": "FArray"}), {_hx_name: "FArray", __params__: ["items"]}),
	FCompound: Object.assign((items) => ({_hx_index: 9, __enum__: "mcl.FlattenedType", "items": items, "@kind": "FCompound"}), {_hx_name: "FCompound", __params__: ["items"]})
}
FlattenedType.__constructs__ = [FlattenedType.FLiteral, FlattenedType.FIdentifier, FlattenedType.FUnary, FlattenedType.FBinary, FlattenedType.FAdd, FlattenedType.FMul, FlattenedType.FCall, FlattenedType.FConditional, FlattenedType.FArray, FlattenedType.FCompound]
FlattenedType.__empty_constructs__ = []

export const McMath = Register.global("$hxClasses")["mcl.McMath"] = 
class McMath {
	static flatten(exp) {
		switch (exp._hx_index) {
			case 0:
				let value = exp.value;
				return FlattenedType.FLiteral(value);
				break
			case 1:
				let name = exp.name;
				return FlattenedType.FIdentifier(name);
				break
			case 2:
				let operant = exp._operator;
				let operand = exp.operand;
				return FlattenedType.FUnary(operant, McMath.flatten(operand));
				break
			case 3:
				let operant1 = exp._operator;
				let left = exp.left;
				let right = exp.right;
				if (operant1 == "+") {
					let entries = new Array();
					let literals = 0;
					let flattenAdd = null;
					flattenAdd = function (exp) {
						switch (exp._hx_index) {
							case 0:
								let value = exp.value;
								switch (value._hx_index) {
									case 0:
										let v = value.v;
										if (v == Math.floor(v)) {
											literals += Math.floor(v);
										} else {
											entries.push(McMath.flatten(exp));
										};
										break
									case 1:
										let v1 = value.v;
										literals += v1;
										break
									default:
									entries.push(McMath.flatten(exp));
									
								};
								break
							case 3:
								if (exp._operator == "+") {
									let left = exp.left;
									let right = exp.right;
									flattenAdd(left);
									flattenAdd(right);
								} else {
									entries.push(McMath.flatten(exp));
								};
								break
							default:
							entries.push(McMath.flatten(exp));
							
						};
					};
					flattenAdd(exp);
					if (literals != 0) {
						entries.push(FlattenedType.FLiteral(ValueType.VInt(literals)));
					};
					return FlattenedType.FAdd(entries);
				};
				if (operant1 == "*") {
					let entries = new Array();
					let literals = 1;
					let flattenMul = null;
					flattenMul = function (exp) {
						switch (exp._hx_index) {
							case 0:
								let value = exp.value;
								switch (value._hx_index) {
									case 0:
										let v = value.v;
										if (v == Math.floor(v)) {
											literals *= Math.floor(v);
										} else {
											entries.push(McMath.flatten(exp));
										};
										break
									case 1:
										let v1 = value.v;
										literals *= v1;
										break
									default:
									entries.push(McMath.flatten(exp));
									
								};
								break
							case 3:
								if (exp._operator == "*") {
									let left = exp.left;
									let right = exp.right;
									flattenMul(left);
									flattenMul(right);
								} else {
									entries.push(McMath.flatten(exp));
								};
								break
							default:
							entries.push(McMath.flatten(exp));
							
						};
					};
					flattenMul(exp);
					if (literals != 1) {
						entries.push(FlattenedType.FLiteral(ValueType.VInt(literals)));
					};
					return FlattenedType.FMul(entries);
				};
				return FlattenedType.FBinary(operant1, McMath.flatten(left), McMath.flatten(right));
				break
			case 4:
				let callee = exp.callee;
				let args = exp["arguments"];
				let f = McMath.flatten;
				let result = new Array(args.length);
				let _g = 0;
				let _g1 = args.length;
				while (_g < _g1) {
					let i = _g++;
					result[i] = f(args[i]);
				};
				return FlattenedType.FCall(callee, result);
				break
			case 5:
				let test = exp.test;
				let consequent = exp.consequent;
				let alternate = exp.alternate;
				return FlattenedType.FConditional(McMath.flatten(test), McMath.flatten(consequent), McMath.flatten(alternate));
				break
			case 6:
				let items = exp.items;
				let f1 = McMath.flatten;
				let result1 = new Array(items.length);
				let _g2 = 0;
				let _g3 = items.length;
				while (_g2 < _g3) {
					let i = _g2++;
					result1[i] = f1(items[i]);
				};
				return FlattenedType.FArray(result1);
				break
			case 7:
				let items1 = exp.items;
				let f2 = McMath.flatten;
				let result2 = new Array(items1.length);
				let _g4 = 0;
				let _g5 = items1.length;
				while (_g4 < _g5) {
					let i = _g4++;
					result2[i] = f2(items1[i]);
				};
				return FlattenedType.FCompound(result2);
				break
			
		};
	}
	static organize(exp) {
		switch (exp._hx_index) {
			case 0:
				let value = exp.value;
				switch (value._hx_index) {
					case 0:
						let v = value.v;
						return ExpressionType.ELiteral(ValueType.VFloat(v));
						break
					case 1:
						let v1 = value.v;
						return ExpressionType.ELiteral(ValueType.VInt(v1));
						break
					case 2:
						let v2 = value.v;
						return ExpressionType.ELiteral(ValueType.VBool(v2));
						break
					case 3:
						let v3 = value.v;
						return ExpressionType.ELiteral(ValueType.VString(v3));
						break
					default:
					throw Exception.thrown("unsupported literal");
					
				};
				break
			case 1:
				let name = exp.name;
				return ExpressionType.EIdentifier(name);
				break
			case 2:
				let operant = exp._operator;
				let operand = exp.operand;
				return ExpressionType.EUnary(operant, McMath.organize(operand));
				break
			case 3:
				let _g = exp._operator;
				let _g1 = exp.left;
				let _g2 = exp.right;
				if (_g1._hx_index == 0) {
					let a = _g1.value;
					let operant = _g;
					let right = _g2;
					let v;
					switch (a._hx_index) {
						case 0:
							let v1 = a.v;
							if (v1 == Math.floor(v1)) {
								v = Math.floor(v1);
							} else {
								return ExpressionType.EBinary(operant, ExpressionType.ELiteral(a), McMath.organize(right));
							};
							break
						case 1:
							let v2 = a.v;
							v = v2;
							break
						default:
						return ExpressionType.EBinary(operant, ExpressionType.ELiteral(a), McMath.organize(right));
						
					};
					if (operant == "+") {
						return ExpressionType.EBinary(operant, McMath.organize(right), ExpressionType.ELiteral(ValueType.VInt(v)));
					};
					if (operant == "-") {
						return ExpressionType.EBinary("+", McMath.organize(right), ExpressionType.ELiteral(ValueType.VInt(-v)));
					};
					if (operant == "*") {
						return ExpressionType.EBinary(operant, McMath.organize(right), ExpressionType.ELiteral(ValueType.VInt(v)));
					};
					return ExpressionType.EBinary(operant, ExpressionType.ELiteral(a), McMath.organize(right));
				} else if (_g == "-") {
					if (_g2._hx_index == 0) {
						let left = _g1;
						let value = _g2.value;
						let v;
						switch (value._hx_index) {
							case 0:
								let v1 = value.v;
								if (v1 == Math.floor(v1)) {
									v = Math.floor(v1);
								} else {
									return ExpressionType.EBinary("-", McMath.organize(left), ExpressionType.ELiteral(value));
								};
								break
							case 1:
								let v2 = value.v;
								v = v2;
								break
							default:
							return ExpressionType.EBinary("-", McMath.organize(left), ExpressionType.ELiteral(value));
							
						};
						return ExpressionType.EBinary("+", McMath.organize(left), ExpressionType.ELiteral(ValueType.VInt(-v)));
					} else {
						let left = _g1;
						let operant = _g;
						let right = _g2;
						return ExpressionType.EBinary(operant, McMath.organize(left), McMath.organize(right));
					};
				} else {
					let left = _g1;
					let operant = _g;
					let right = _g2;
					return ExpressionType.EBinary(operant, McMath.organize(left), McMath.organize(right));
				};
				break
			case 4:
				let name1 = exp.callee;
				let args = exp["arguments"];
				let f = McMath.organize;
				let result = new Array(args.length);
				let _g3 = 0;
				let _g4 = args.length;
				while (_g3 < _g4) {
					let i = _g3++;
					result[i] = f(args[i]);
				};
				return ExpressionType.ECall(name1, result);
				break
			case 5:
				let test = exp.test;
				let consequent = exp.consequent;
				let alternate = exp.alternate;
				return ExpressionType.EConditional(McMath.organize(test), McMath.organize(consequent), McMath.organize(alternate));
				break
			case 6:
				let items = exp.items;
				let f1 = McMath.organize;
				let result1 = new Array(items.length);
				let _g5 = 0;
				let _g6 = items.length;
				while (_g5 < _g6) {
					let i = _g5++;
					result1[i] = f1(items[i]);
				};
				return ExpressionType.EArray(result1);
				break
			case 7:
				let items1 = exp.items;
				let f2 = McMath.organize;
				let result2 = new Array(items1.length);
				let _g7 = 0;
				let _g8 = items1.length;
				while (_g7 < _g8) {
					let i = _g7++;
					result2[i] = f2(items1[i]);
				};
				return ExpressionType.ECompound(result2);
				break
			
		};
	}
	static compile(eq, context) {
		let _g = 0;
		let _g1 = eq.length;
		while (_g < _g1) {
			let i = _g++;
			if (eq.charAt(i) == "@" && eq.charAt(i + 1) != "s" && eq.charAt(i + 2) != "[") {
				throw Exception.thrown("only unrestricted @s selectors are allowed in equations to avoid unexpected behavior.");
			};
		};
		let skip = function () {
			let idx = 0;
			while (eq.charAt(idx) == " " && idx < eq.length) ++idx;
			eq = eq.substring(idx);
		};
		let collect = function () {
			let value = "";
			let idx = 0;
			while (eq.charAt(idx) != " " && idx < eq.length) {
				value += eq.charAt(idx);
				++idx;
			};
			eq = eq.substring(idx);
			return value;
		};
		let lhs = collect();
		skip();
		lhs += " " + collect();
		skip();
		let sep = collect();
		skip();
		let rhs = eq;
		let variables = new StringMap();
		let idx = 0;
		let isAlphaNumeric = function (c) {
			let code = c.charCodeAt(0);
			if (!(code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code == 46 || code == 95 || code == 36 || code == 35)) {
				return code == 64;
			} else {
				return true;
			};
		};
		let varnameIdx = 0;
		let getNextVarName = function () {
			varnameIdx += 1;
			return "var" + varnameIdx;
		};
		let newEquation = "";
		while (idx < rhs.length) {
			let c = rhs.charAt(idx);
			let code = HxOverrides.cca(c, 0);
			if (code == 64 || code >= 97 && code <= 122 || code >= 65 && code <= 90) {
				let name = "";
				while (idx < rhs.length && isAlphaNumeric(rhs.charAt(idx))) {
					name += rhs.charAt(idx);
					++idx;
				};
				++idx;
				name += " ";
				while (idx < rhs.length && isAlphaNumeric(rhs.charAt(idx))) {
					name += rhs.charAt(idx);
					++idx;
				};
				if (!variables.inst.has(name)) {
					let value = getNextVarName();
					variables.inst.set(name, value);
				};
				newEquation += variables.inst.get(name);
			} else {
				newEquation += c;
				++idx;
			};
		};
		let x = McMath.flatten(McMath.organize(Expression.toExpressionType(Expression.simplify(Parser.parse(newEquation)))));
		let _g2 = new StringMap();
		let map = variables;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			_g2.inst.set(v, k);
		};
		return McMath.render(x, lhs, _g2, sep, context);
	}
	static render(x, result, variables, finalOp, context) {
		let commands = [];
		let idx = 0;
		let unsafeToModify_inst = new Map();
		let $const = context.compiler.config.eqConstScoreboardName;
		let temp = context.compiler.config.eqVarScoreboardName;
		let constantValues_inst = new Map();
		let c = function (v, remove) {
			if (remove == null) {
				remove = false;
			};
			if (remove) {
				let count = constantValues_inst.get(v);
				--count;
				if (count <= 0) {
					constantValues_inst["delete"](v);
				} else {
					constantValues_inst.set(v, count);
				};
			} else {
				let count = constantValues_inst.get(v);
				if (count == null) {
					count = 1;
				} else {
					++count;
				};
				constantValues_inst.set(v, count);
			};
		};
		let map = variables;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			unsafeToModify_inst.set(v, true);
		};
		let isSafeToModify = function (s) {
			if (unsafeToModify_inst.has(s)) {
				return false;
			};
			if (s.endsWith(" " + $const)) {
				return false;
			};
			return true;
		};
		let mkTemp = function (from, alt) {
			if (alt != null && isSafeToModify(alt)) {
				commands.push("scoreboard players operation " + alt + " = " + from);
				return alt;
			};
			idx += 1;
			let id = "tmp" + (idx - 1) + " " + temp;
			if (from.endsWith(" " + $const)) {
				c(Std.parseInt(from.substring(0, from.length - 6)), true);
				commands.push("scoreboard players set " + id + " " + from.substring(0, from.length - 6));
			} else {
				commands.push("scoreboard players operation " + id + " = " + from);
			};
			return id;
		};
		let makeSafe = function (v, alt) {
			if (isSafeToModify(v)) {
				return v;
			};
			return mkTemp(v, alt);
		};
		let isConstant = function (v) {
			if (v._hx_index == 0) {
				let _g = v.value;
				return true;
			} else {
				return false;
			};
		};
		let isVariable = function (v) {
			if (v._hx_index == 1) {
				let _g = v.name;
				return true;
			} else {
				return false;
			};
		};
		let getVariable = function (v) {
			if (v._hx_index == 1) {
				let name = v.name;
				return variables.inst.get(name);
			} else {
				throw Exception.thrown("not a variable");
			};
		};
		let getValue = function (v) {
			if (v._hx_index == 0) {
				let value = v.value;
				switch (value._hx_index) {
					case 0:
						let v1 = value.v;
						return v1;
						break
					case 1:
						let v2 = value.v;
						return v2;
						break
					default:
					throw Exception.thrown("unsupported literal");
					
				};
			};
			throw Exception.thrown("not a constant");
		};
		let getConstant = function (v) {
			let val = Math.floor(getValue(v));
			c(val);
			return "" + val + " " + $const;
		};
		let renderNode = null;
		renderNode = function (node, output) {
			switch (node._hx_index) {
				case 0:
					let id = node.value;
					switch (id._hx_index) {
						case 0:
							let v = id.v;
							c(Math.floor(v));
							return "" + Math.floor(v) + " " + $const;
							break
						case 1:
							let v1 = id.v;
							c(v1);
							return "" + v1 + " " + $const;
							break
						default:
						throw Exception.thrown("unsupported literal");
						
					};
					break
				case 1:
					let id1 = node.name;
					throw Exception.thrown("NO NO NO NO NO2");
					break
				case 2:
					let operant = node.operant;
					let operand = node.operand;
					let l = (isVariable(operand)) ? makeSafe(getVariable(operand), output) : (isConstant(operand)) ? makeSafe(getConstant(operand), output) : renderNode(operand, output);
					if (operant == "-") {
						let r = makeSafe(l);
						c(-1);
						commands.push("scoreboard players operation " + r + " *= -1 " + $const);
						return r;
					};
					return l;
					break
				case 3:
					let operant1 = node.operant;
					let left = node.left;
					let right = node.right;
					let l1 = (isVariable(left)) ? makeSafe(getVariable(left), output) : (isConstant(left)) ? makeSafe(getConstant(left), output) : renderNode(left, output);
					let r = (isVariable(right)) ? getVariable(right) : (isConstant(right)) ? getConstant(right) : renderNode(right, null);
					commands.push("scoreboard players operation " + l1 + " " + operant1 + "= " + r);
					return l1;
					break
				case 4:
					let items = node.item;
					let l2 = (isVariable(items[0])) ? makeSafe(getVariable(items[0]), output) : (isConstant(items[0])) ? makeSafe(getConstant(items[0]), output) : renderNode(items[0], output);
					let _g = 1;
					let _g1 = items.length;
					while (_g < _g1) {
						let i = _g++;
						if (isVariable(items[i])) {
							commands.push("scoreboard players operation " + l2 + " += " + getVariable(items[i]));
						} else if (isConstant(items[i])) {
							let v = getValue(items[i]);
							if (v > 0) {
								commands.push("scoreboard players add " + l2 + " " + v);
							} else if (v < 0) {
								commands.push("scoreboard players remove " + l2 + " " + -v);
							};
						} else {
							let r = renderNode(items[i], null);
							commands.push("scoreboard players operation " + l2 + " += " + r);
						};
					};
					return l2;
					break
				case 5:
					let items1 = node.item;
					let l3 = (isVariable(items1[0])) ? makeSafe(getVariable(items1[0]), output) : (isConstant(items1[0])) ? makeSafe(getConstant(items1[0]), output) : renderNode(items1[0], output);
					let _g2 = 1;
					let _g3 = items1.length;
					while (_g2 < _g3) {
						let i = _g2++;
						let r = (isVariable(items1[i])) ? getVariable(items1[i]) : (isConstant(items1[i])) ? getConstant(items1[i]) : renderNode(items1[i], null);
						commands.push("scoreboard players operation " + l3 + " *= " + r);
					};
					return l3;
					break
				case 6:
					let callee = node.callee;
					let args = node.args;
					throw Exception.thrown("unsupported call");
					break
				case 7:
					let test = node.test;
					let consequent = node.consequent;
					let alternate = node.alternate;
					throw Exception.thrown("unsupported conditional");
					break
				case 8:
					let items2 = node.items;
					throw Exception.thrown("unsupported array");
					break
				case 9:
					let items3 = node.items;
					throw Exception.thrown("unsupported compound");
					break
				
			};
		};
		if (isConstant(x) && finalOp == "=") {
			commands.push("scoreboard players set " + result + " " + getValue(x));
		} else if (isVariable(x)) {
			commands.push("scoreboard players operation " + result + " " + finalOp + " " + getVariable(x));
		} else {
			let stored = renderNode(x, result);
			if (result != stored) {
				commands.push("scoreboard players operation " + result + " " + finalOp + " " + stored);
			};
		};
		let tmp = commands.join("\n");
		let _g = [];
		let k = EsMap.adaptIterator(constantValues_inst.keys());
		while (k.hasNext()) {
			let k1 = k.next();
			_g.push(k1);
		};
		return {"commands": tmp, "constants": _g};
	}
	static get __name__() {
		return "mcl.McMath"
	}
	get __class__() {
		return McMath
	}
}

