import {CompilerContext} from "./Compiler"
import {ValueType} from "../haxpression/ValueType"
import {ExpressionType} from "../haxpression/ExpressionType"
import {IMap} from "../haxe/Constraints"

export declare namespace FlattenedType {
	export type FUnary = {"@kind": "FUnary", _hx_index: 2, operant: string, operand: FlattenedType, __enum__: "mcl.FlattenedType"}
	export const FUnary: (operant: string, operand: FlattenedType) => FlattenedType
	export type FMul = {"@kind": "FMul", _hx_index: 5, item: FlattenedType[], __enum__: "mcl.FlattenedType"}
	export const FMul: (item: FlattenedType[]) => FlattenedType
	export type FLiteral = {"@kind": "FLiteral", _hx_index: 0, value: ValueType, __enum__: "mcl.FlattenedType"}
	export const FLiteral: (value: ValueType) => FlattenedType
	export type FIdentifier = {"@kind": "FIdentifier", _hx_index: 1, name: string, __enum__: "mcl.FlattenedType"}
	export const FIdentifier: (name: string) => FlattenedType
	export type FConditional = {"@kind": "FConditional", _hx_index: 7, test: FlattenedType, consequent: FlattenedType, alternate: FlattenedType, __enum__: "mcl.FlattenedType"}
	export const FConditional: (test: FlattenedType, consequent: FlattenedType, alternate: FlattenedType) => FlattenedType
	export type FCompound = {"@kind": "FCompound", _hx_index: 9, items: FlattenedType[], __enum__: "mcl.FlattenedType"}
	export const FCompound: (items: FlattenedType[]) => FlattenedType
	export type FCall = {"@kind": "FCall", _hx_index: 6, callee: string, args: FlattenedType[], __enum__: "mcl.FlattenedType"}
	export const FCall: (callee: string, args: FlattenedType[]) => FlattenedType
	export type FBinary = {"@kind": "FBinary", _hx_index: 3, operant: string, left: FlattenedType, right: FlattenedType, __enum__: "mcl.FlattenedType"}
	export const FBinary: (operant: string, left: FlattenedType, right: FlattenedType) => FlattenedType
	export type FArray = {"@kind": "FArray", _hx_index: 8, items: FlattenedType[], __enum__: "mcl.FlattenedType"}
	export const FArray: (items: FlattenedType[]) => FlattenedType
	export type FAdd = {"@kind": "FAdd", _hx_index: 4, item: FlattenedType[], __enum__: "mcl.FlattenedType"}
	export const FAdd: (item: FlattenedType[]) => FlattenedType
}

export declare type FlattenedType = 
	| FlattenedType.FUnary
	| FlattenedType.FMul
	| FlattenedType.FLiteral
	| FlattenedType.FIdentifier
	| FlattenedType.FConditional
	| FlattenedType.FCompound
	| FlattenedType.FCall
	| FlattenedType.FBinary
	| FlattenedType.FArray
	| FlattenedType.FAdd

export declare class McMath {
	protected static flatten(exp: ExpressionType): FlattenedType
	protected static organize(exp: ExpressionType): ExpressionType
	static compile(eq: string, context: CompilerContext): {
		commands: string, 
		constants: number[]
	}
	protected static render(x: FlattenedType, result: string, variables: IMap<string, string>, finalOp: string, context: CompilerContext): {
		commands: string, 
		constants: number[]
	}
}
