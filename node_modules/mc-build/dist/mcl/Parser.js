import {ParserError} from "./error/ParserError.js"
import {Token} from "./Tokenizer.js"
import {AstNode, JsonTagType} from "./AstNode.js"
import {Register} from "../genes/Register.js"
import {StringTools} from "../StringTools.js"
import {Std} from "../Std.js"
import {EReg} from "../EReg.js"

const $global = Register.$global

export const ArrayInput = Register.global("$hxClasses")["mcl.ArrayInput"] = 
class ArrayInput extends Register.inherits() {
	new(array) {
		this.array = array;
		this.set_index(0);
	}
	get index() {
		return this.get_index()
	}
	set index(v) {
		this.set_index(v)
	}
	get_index() {
		return this._index;
	}
	set_index(i) {
		return this._index = i;
	}
	next() {
		if (this._index >= this.array.length) {
			throw new ParserError("Tried to read past the end of the token list");
		};
		let tmp = this.array;
		let lhs = this.get_index();
		this.set_index(lhs + 1);
		return tmp[lhs];
	}
	skip() {
		this.set_index(this.get_index() + 1);
	}
	peek() {
		return this.array[this.get_index()];
	}
	hasNext() {
		return this.get_index() < this.array.length;
	}
	insert(token) {
		let _this = this.array;
		let pos = this.get_index();
		_this.splice(pos, 0, token);
	}
	back() {
		this.set_index(this.get_index() - 1);
	}
	update(token) {
		this.array[this.get_index()] = token;
	}
	static get __name__() {
		return "mcl.ArrayInput"
	}
	get __class__() {
		return ArrayInput
	}
}


export const Parser = Register.global("$hxClasses")["mcl.Parser"] = 
class Parser {
	static format(template, ...data) {
		let regex_r = new RegExp("\\{\\}", "".split("u").join(""));
		let _g = 0;
		let _g1 = data.slice();
		while (_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			template = template.replace(regex_r, Std.string(field));
		};
		return template;
	}
	static toss(token, error) {
		switch (token._hx_index) {
			case 0:
				let v = token.v;
				let pos = token.pos;
				throw new ParserError(Parser.format(error, v, pos.file, pos.line, pos.col));
				break
			case 1:
				let pos1 = token.pos;
				let data = token.data;
				throw new ParserError(Parser.format(error, data, pos1.file, pos1.line, pos1.col));
				break
			case 2:
				let pos2 = token.pos;
				throw new ParserError(Parser.format(error, pos2.file, pos2.line, pos2.col));
				break
			
		};
	}
	static unreachable(token) {
		let tmp;
		switch (token._hx_index) {
			case 0:
				let v = token.v;
				let p = token.pos;
				tmp = Parser.format("Unexpected token '{}' at {}:{}:{}", v, p.file, p.line, p.col);
				break
			case 1:
				let p1 = token.pos;
				let d = token.data;
				tmp = Parser.format("Unexpected '{' with data '{}' at {}:{}:{}", d, p1.file, p1.line, p1.col);
				break
			case 2:
				let p2 = token.pos;
				tmp = Parser.format("Unexpected '}' at {}:{}:{}", p2.file, p2.line, p2.col);
				break
			
		};
		return new ParserError(tmp);
	}
	static expect(reader, match) {
		let token = reader.next();
		if (!match(token)) {
			throw Parser.unreachable(token);
		};
	}
	static expectThenData(reader, allowData) {
		if (allowData == null) {
			allowData = true;
		};
		let token = reader.peek();
		Parser.expect(reader, function (token) {
			return token._hx_index == 1;
		});
		if (token._hx_index == 1) {
			let _g = token.pos;
			let data = token.data;
			if (!allowData && data.length > 0) {
				throw Parser.unreachable(token);
			};
			return data;
		} else {
			return null;
		};
	}
	static block(reader, sub, allowData, onLastToken) {
		if (allowData == null) {
			allowData = true;
		};
		let data = Parser.expectThenData(reader, allowData);
		while (true) {
			if (!reader.hasNext()) {
				throw new ParserError("Unexpected end of file!");
			};
			let token = reader.peek();
			if (token._hx_index == 2) {
				let _g = token.pos;
				if (onLastToken != null) {
					onLastToken(token);
				};
				break;
			} else {
				sub();
			};
		};
		Parser.expect(reader, function (token) {
			return token._hx_index == 2;
		});
		if (data == "") {
			return null;
		} else {
			return data;
		};
	}
	static readFunction(name, reader, pos) {
		let commands = [];
		let appendTo = null;
		let segments = name.split(" ");
		if (segments.length == 2) {
			name = segments[0];
			appendTo = segments[1];
		} else if (segments.length == 1) {
			name = segments[0];
		};
		Parser.block(reader, function () {
			commands.push(Parser.innerParse(reader));
		}, false);
		return AstNode.FunctionDef(pos, name, commands, appendTo);
	}
	static innerParseTemplate(reader) {
		let _g = reader.peek();
		if (_g._hx_index == 0) {
			let _g1 = _g.v;
			let _g2 = _g.pos;
			switch (_g1) {
				case "load":
					let pos = _g2;
					reader.skip();
					let content = [];
					Parser.block(reader, function () {
						content.push(Parser.innerParse(reader));
					}, false);
					return AstNode.LoadBlock(pos, content);
					break
				case "tick":
					let pos1 = _g2;
					reader.skip();
					let content1 = [];
					Parser.block(reader, function () {
						content1.push(Parser.innerParse(reader));
					}, false);
					return AstNode.TickBlock(pos1, content1);
					break
				default:
				let v = _g1;
				let pos2 = _g2;
				if (v == "with" || v.startsWith("with ")) {
					reader.skip();
					let args = StringTools.trim(v.substring("with ".length));
					let content = [];
					Parser.block(reader, function () {
						content.push(Parser.innerParse(reader));
					}, false);
					return AstNode.TemplateOverload(pos2, args, content);
				} else {
					throw Parser.unreachable(reader.next());
				};
				
			};
		} else {
			throw Parser.unreachable(reader.next());
		};
	}
	static readTemplate(name, reader, pos) {
		let entries = [];
		Parser.block(reader, function () {
			entries.push(Parser.innerParseTemplate(reader));
		}, false);
		return AstNode.TemplateDef(pos, name, entries);
	}
	static pos(token) {
		switch (token._hx_index) {
			case 0:
				let _g = token.v;
				let pos = token.pos;
				return pos;
				break
			case 1:
				let _g1 = token.data;
				let pos1 = token.pos;
				return pos1;
				break
			case 2:
				let pos2 = token.pos;
				return pos2;
				break
			
		};
	}
	static json(reader) {
		let pos = Parser.pos(reader.peek());
		let depth = 0;
		let result = "";
		do {
			if (!reader.hasNext()) {
				throw new ParserError("Unexpected end of file!");
			};
			let token = reader.next();
			switch (token._hx_index) {
				case 0:
					let _g = token.pos;
					let v = token.v;
					result += v;
					break
				case 1:
					let _g1 = token.pos;
					let data = token.data;
					result += "{";
					result += data;
					++depth;
					break
				case 2:
					let _g2 = token.pos;
					--depth;
					result += "}";
					break
				
			};
		} while (depth > 0);
		return AstNode.Raw(pos, result, [], false);
	}
	static parseMcbFile(tokens) {
		let reader = new ArrayInput(tokens);
		let nodes = [];
		while (reader.hasNext()) nodes.push(Parser.parseTLD(reader));
		return nodes;
	}
	static parseMcbtFile(tokens) {
		let reader = new ArrayInput(tokens);
		let nodes = [];
		while (reader.hasNext()) {
			let token = reader.next();
			let tmp;
			if (token._hx_index == 0) {
				let v = token.v;
				let pos = token.pos;
				if (v.startsWith("template ")) {
					let name = StringTools.trim(v.substring("template ".length));
					tmp = Parser.readTemplate(name, reader, pos);
				} else if (v.startsWith("#")) {
					tmp = AstNode.Comment(pos, v);
				} else if (v.startsWith("import ")) {
					tmp = AstNode.Import(pos, v.substring("import ".length));
				} else {
					throw Parser.unreachable(token);
				};
			} else {
				throw Parser.unreachable(token);
			};
			nodes.push(tmp);
		};
		return nodes;
	}
	static parserCompilerLoop(v, pos, reader, handler) {
		let content = [];
		Parser.block(reader, function () {
			content.push(handler());
		});
		if (Parser.loopRegExp.match(v)) {
			let loop = Parser.loopRegExp.matched(1);
			let as = Parser.loopRegExp.matched(2);
			let tmp;
			if (as.length == 0) {
				tmp = null;
			} else {
				let _g = [];
				let _g1 = 0;
				let _g2 = as.split(",");
				while (_g1 < _g2.length) {
					let e = _g2[_g1];
					++_g1;
					_g.push(StringTools.trim(e));
				};
				tmp = _g;
			};
			return AstNode.CompileTimeLoop(pos, loop, tmp, content);
		};
		return AstNode.CompileTimeLoop(pos, v, null, content);
	}
	static parseTLD(reader) {
		let _g = reader.next();
		if (_g._hx_index == 0) {
			let v = _g.v;
			let pos = _g.pos;
			if (v.startsWith("function ")) {
				let name = StringTools.trim(v.substring("function ".length));
				return Parser.readFunction(name, reader, pos);
			} else if (v.startsWith("clock ")) {
				let time = StringTools.trim(v.substring("clock ".length));
				if (time.indexOf(" ") == -1) {
					throw new ParserError(Parser.format("\"Expected a name and a time for the clock command\" at {}:{}:{}", pos.file, pos.line, pos.col));
				};
				let name = StringTools.trim(time.substring(0, time.indexOf(" ") + 1));
				time = StringTools.trim(time.substring(time.indexOf(" ")));
				let content = [];
				Parser.block(reader, function () {
					content.push(Parser.innerParse(reader));
				});
				return AstNode.ClockExpr(pos, name, time, content);
			} else if (v.startsWith("import ")) {
				return AstNode.Import(pos, v.substring("import ".length));
			} else if (v.startsWith("dir ") && reader.peek()._hx_index == 1) {
				let content = [];
				let data = Parser.block(reader, function () {
					content.push(Parser.parseTLD(reader));
				}, false);
				if (data != null) {
					throw Parser.unreachable(Token.Literal(v, pos));
				};
				return AstNode.Directory(pos, v.substring("dir ".length), content);
			} else if (v.startsWith("<%%")) {
				let content = [];
				while (true) {
					if (!reader.hasNext()) {
						throw new ParserError("Unexpected end of file!");
					};
					let _g = reader.peek();
					if (_g._hx_index == 0) {
						let _g1 = _g.pos;
						if (_g.v == "%%>") {
							reader.skip();
							break;
						};
					};
					content.push(reader.next());
				};
				return AstNode.MultiLineScript(pos, content);
			} else if (v.startsWith("#")) {
				return AstNode.Comment(pos, v);
			} else if (v.startsWith("REPEAT")) {
				return Parser.parserCompilerLoop(v, pos, reader, function () {
					return Parser.parseTLD(reader);
				});
			} else if (v.startsWith("IF")) {
				return Parser.parseCompileTimeIf(v, pos, reader, function () {
					return Parser.parseTLD(reader);
				});
			} else if (v.startsWith("tag ")) {
				let sections = StringTools.trim(v.substring("tag ".length)).split(" ");
				let type = sections.shift();
				let name = sections.shift();
				let replace = sections.shift() == "replace";
				let content = [];
				Parser.block(reader, function () {
					content.push(Parser.innerParse(reader));
				});
				return AstNode.JsonFile(pos, name, JsonTagType.Tag(type, replace, content));
			} else if (v.startsWith("advancement ") || v.startsWith("enchantment ") || v.startsWith("item_modifier ") || v.startsWith("loot_table ") || v.startsWith("predicate ") || v.startsWith("recipe ") || v.startsWith("chat_type ") || v.startsWith("damage_type ") || v.startsWith("dimension ") || v.startsWith("dimension_type ")) {
				return Parser.readPlainJsonFile(v, pos, reader);
			} else if (v.startsWith("worldgen ")) {
				let name = StringTools.trim(v.substring("worldgen ".length));
				let subtype = name.substring(0, name.indexOf(" "));
				name = name.substring(name.indexOf(" ") + 1);
				let content = [];
				Parser.block(reader, function () {
					content.push(Parser.innerParse(reader));
				});
				return AstNode.JsonFile(pos, name, JsonTagType.WorldGen(subtype, name, content));
			} else {
				throw Parser.unreachable(Token.Literal(v, pos));
			};
		} else {
			let node = _g;
			throw Parser.unreachable(node);
		};
	}
	static readPlainJsonFile(v, pos, reader) {
		let _g = [];
		let _g1 = 0;
		let _g2 = v.split(" ");
		while (_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if (v != "") {
				_g.push(v);
			};
		};
		let bits = _g;
		let type = bits.shift();
		let name = bits.shift();
		let content = [];
		Parser.block(reader, function () {
			content.push(Parser.json(reader));
		});
		let tmp;
		if (type == null) {
			throw Parser.unreachable(Token.Literal(v, pos));
		} else {
			switch (type) {
				case "advancement":
					tmp = JsonTagType.Advancement(content);
					break
				case "chat_type":
					tmp = JsonTagType.ChatType(content);
					break
				case "damage_type":
					tmp = JsonTagType.DamageType(content);
					break
				case "dimension":
					tmp = JsonTagType.Dimension(content);
					break
				case "dimension_type":
					tmp = JsonTagType.DimensionType(content);
					break
				case "enchantment":
					tmp = JsonTagType.Enchantment(content);
					break
				case "item_modifier":
					tmp = JsonTagType.ItemModifier(content);
					break
				case "loot_table":
					tmp = JsonTagType.LootTable(content);
					break
				case "predicate":
					tmp = JsonTagType.Predicate(content);
					break
				case "recipe":
					tmp = JsonTagType.Recipe(content);
					break
				default:
				throw Parser.unreachable(Token.Literal(v, pos));
				
			};
		};
		return AstNode.JsonFile(pos, name, tmp);
	}
	static innerParse(reader) {
		let token = reader.peek();
		switch (token._hx_index) {
			case 0:
				let v = token.v;
				let pos = token.pos;
				reader.next();
				let isMacroArg = v.charAt(0) == "$";
				if (isMacroArg) {
					v = v.substring(1);
				};
				if (v == "<%%") {
					let content = [];
					while (true) {
						if (!reader.hasNext()) {
							throw new ParserError("Unexpected end of file!");
						};
						let _g = reader.peek();
						if (_g._hx_index == 0) {
							let _g1 = _g.pos;
							if (_g.v == "%%>") {
								reader.skip();
								break;
							};
						};
						content.push(reader.next());
					};
					return AstNode.MultiLineScript(pos, content);
				} else if (v.startsWith("IF")) {
					return Parser.parseCompileTimeIf(v, pos, reader, function () {
						return Parser.innerParse(reader);
					});
				} else if (v.startsWith("function ")) {
					let target = v.substring("function ".length);
					let end = target.indexOf(" ");
					let name = target.substring(0, (end == -1) ? target.length : end);
					let data = target.substring(name.length + 1);
					return AstNode.FunctionCall(pos, name, data, isMacroArg);
				} else if (v.startsWith("schedule ")) {
					let name = StringTools.trim(v.substring("schedule ".length));
					if (name.startsWith("function ")) {
						let target = name.substring("function ".length);
						let end = target.indexOf(" ");
						let funcName = target.substring(0, (end == -1) ? target.length : end);
						let delay = (end == -1) ? null : target.substring(funcName.length + 1);
						let mode = "replace";
						if (delay.endsWith(" append")) {
							mode = "append";
							delay = delay.substring(0, delay.length - " append".length);
						};
						if (delay.endsWith(" replace")) {
							mode = "replace";
							delay = delay.substring(0, delay.length - " replace".length);
						};
						if (delay == null) {
							throw new ParserError(Parser.format("\"Expected delay after function name in schedule command\" at {}:{}:{}", pos.file, pos.line, pos.col));
						};
						return AstNode.ScheduleCall(pos, delay, funcName, mode, isMacroArg);
					};
					if (name.startsWith("clear ")) {
						return AstNode.ScheduleClear(pos, name.substring("clear ".length), isMacroArg);
					};
					let delayIdx = name.indexOf(" ");
					let delay = (delayIdx == -1) ? name : name.substring(0, delayIdx);
					let mode = "append";
					if (name.endsWith(" append")) {
						mode = "append";
						name = name.substring(0, name.length - " append".length);
					};
					if (name.endsWith(" replace")) {
						mode = "replace";
						name = name.substring(0, name.length - " replace".length);
					};
					let content = [];
					if (reader.peek()._hx_index != 1) {
						throw new ParserError("Expected { after delay in schedule block command");
					};
					Parser.block(reader, function () {
						content.push(Parser.innerParse(reader));
					});
					return AstNode.ScheduleBlock(pos, delay, mode, content, isMacroArg);
				} else if (v.startsWith("execute") && (v.charAt("execute".length) == " " || v.charAt("execute".length) == "<")) {
					if (reader.hasNext() && reader.peek()._hx_index == 1) {
						let content = [];
						if (!v.endsWith("run") && Parser.executeRegExp.match(v)) {
							let p = Parser.executeRegExp.matchedPos();
							let subPos = {"file": pos.file, "line": pos.line, "col": pos.col + p.pos + p.len};
							let continuationToken = Token.Literal(StringTools.ltrim(v.substring(p.pos + p.len)), subPos);
							reader.insert(continuationToken);
							return AstNode.Execute(pos, StringTools.rtrim(v.substring(0, p.pos + 3)), Parser.innerParse(reader), isMacroArg);
						};
						let data = Parser.block(reader, function () {
							content.push(Parser.innerParse(reader));
						});
						let extraBlocks = [];
						_hx_loop2: while (reader.hasNext()) {
							let _g = reader.peek();
							if (_g._hx_index == 0) {
								let _g1 = _g.v;
								let _g2 = _g.pos;
								switch (_g1) {
									case "else $run":
										let pos = _g2;
										reader.skip();
										let elseContent = [];
										let elseData = Parser.block(reader, function () {
											elseContent.push(Parser.innerParse(reader));
										});
										extraBlocks.push(AstNode.Block(pos, null, elseContent, elseData, true, false));
										break
									case "else run":
										let pos1 = _g2;
										reader.skip();
										let elseContent1 = [];
										let elseData1 = Parser.block(reader, function () {
											elseContent1.push(Parser.innerParse(reader));
										});
										extraBlocks.push(AstNode.Block(pos1, null, elseContent1, elseData1, false, false));
										break
									default:
									let v = _g1;
									let pos2 = _g2;
									if (v.startsWith("else $") && v.endsWith("run")) {
										reader.skip();
										let executeCommand = StringTools.trim(v.substring("else $".length));
										let elseContent = [];
										let elseData = Parser.block(reader, function () {
											elseContent.push(Parser.innerParse(reader));
										});
										pos2.col += 5;
										extraBlocks.push(AstNode.ExecuteBlock(pos2, executeCommand, elseData, elseContent, null, true));
									} else {
										let v = _g1;
										let pos = _g2;
										if (v.startsWith("else ") && v.endsWith("run")) {
											reader.skip();
											let executeCommand = StringTools.trim(v.substring("else ".length));
											let elseContent = [];
											let elseData = Parser.block(reader, function () {
												elseContent.push(Parser.innerParse(reader));
											});
											pos.col += 5;
											extraBlocks.push(AstNode.ExecuteBlock(pos, executeCommand, elseData, elseContent, null, false));
										} else {
											break _hx_loop2;
										};
									};
									
								};
							} else {
								break;
							};
						};
						return AstNode.ExecuteBlock(pos, v, data, content, (extraBlocks.length > 0) ? extraBlocks : null, isMacroArg);
					} else {
						if (!Parser.executeRegExp.match(v)) {
							return Parser.readRaw(pos, v, reader, isMacroArg);
						};
						let p = Parser.executeRegExp.matchedPos();
						let subPos = {"file": pos.file, "line": pos.line, "col": pos.col + p.pos + p.len};
						let continuationToken = Token.Literal(StringTools.ltrim(v.substring(p.pos + p.len)), subPos);
						reader.insert(continuationToken);
						return AstNode.Execute(pos, StringTools.rtrim(v.substring(0, p.pos + 3)), Parser.innerParse(reader), isMacroArg);
					};
				} else if (v.startsWith("REPEAT")) {
					return Parser.parserCompilerLoop(v, pos, reader, function () {
						return Parser.innerParse(reader);
					});
				} else if (v.startsWith("#")) {
					return AstNode.Comment(pos, v);
				} else if (v == "block" || v.startsWith("block ")) {
					let name = StringTools.trim(v.substring("block ".length));
					let content = [];
					let data = Parser.block(reader, function () {
						content.push(Parser.innerParse(reader));
					});
					return AstNode.Block(pos, name, content, data, isMacroArg, false);
				} else if (v.startsWith("return run")) {
					let subCommand = StringTools.trim(v.substring("return run ".length));
					let pos1 = {"file": pos.file, "line": pos.line, "col": pos.col + "return run ".length};
					let _g = reader.peek();
					if (_g._hx_index == 1) {
						let pos = _g.pos;
						let data = _g.data;
						let content = [];
						let data1 = Parser.block(reader, function () {
							content.push(Parser.innerParse(reader));
						});
						return AstNode.ReturnRun(pos, AstNode.Block(pos, null, content, data1, false, false), isMacroArg);
					} else {
						reader.back();
						reader.update(Token.Literal(subCommand, pos1));
						return AstNode.ReturnRun(pos1, Parser.innerParse(reader), isMacroArg);
					};
				} else if (v == "tick") {
					let content = [];
					Parser.block(reader, function () {
						content.push(Parser.innerParse(reader));
					}, false);
					return AstNode.TickBlock(pos, content);
				} else if (v == "load") {
					let content = [];
					Parser.block(reader, function () {
						content.push(Parser.innerParse(reader));
					}, false);
					return AstNode.LoadBlock(pos, content);
				} else if (v.startsWith("eq ")) {
					return AstNode.EqCommand(pos, v.substring("eq ".length));
				} else {
					return Parser.readRaw(pos, v, reader, isMacroArg);
				};
				break
			case 1:
				let _g = token.data;
				let pos1 = token.pos;
				let content = [];
				let data = Parser.block(reader, function () {
					content.push(Parser.innerParse(reader));
				});
				return AstNode.Block(pos1, null, content, data, false, false);
				break
			default:
			throw Parser.unreachable(token);
			
		};
	}
	static readRaw(pos, v, reader, isMacro) {
		if (!reader.hasNext()) {
			return AstNode.Raw(pos, v, [], isMacro);
		};
		let content = [];
		let line = pos.line;
		_hx_loop1: while (true) {
			if (!reader.hasNext()) {
				throw new ParserError("Unexpected end of file!");
			};
			let _g = reader.peek();
			switch (_g._hx_index) {
				case 0:
					let v1 = _g.v;
					let pos = _g.pos;
					if (pos.line == line) {
						reader.skip();
						content.push(AstNode.Raw(pos, v1, [], false));
					} else {
						break _hx_loop1;
					};
					break
				case 1:
					let pos1 = _g.pos;
					let data = _g.data;
					if (pos1.line == line) {
						let blockContent = [];
						let blockData = Parser.block(reader, function () {
							blockContent.push(Parser.innerParse(reader));
						});
						content.push(AstNode.Block(pos1, null, blockContent, blockData, false, false));
					} else {
						break _hx_loop1;
					};
					break
				case 2:
					let pos2 = _g.pos;
					if (pos2.line == line) {
						throw Parser.unreachable(Token.Literal(v, pos2));
					} else {
						break _hx_loop1;
					};
					break
				default:
				break _hx_loop1;
				
			};
		};
		return AstNode.Raw(pos, v, content, isMacro);
	}
	static parseCompileTimeIf(v, pos, reader, arg) {
		let exp = StringTools.trim(v.substring("IF".length));
		let content = [];
		Parser.block(reader, function () {
			content.push(arg());
		}, false);
		let elseDatas = [];
		while (true) {
			if (!reader.hasNext()) {
				throw new ParserError("Unexpected end of file!");
			};
			let _g = reader.peek();
			if (_g._hx_index == 0) {
				let v = _g.v;
				let pos = _g.pos;
				if (v == "ELSE" || v.startsWith("ELSE ")) {
					reader.skip();
					let condition = (v == "ELSE") ? null : StringTools.trim(v.substring("ELSE ".length));
					if (condition != null) {
						if (condition.startsWith("IF")) {
							condition = StringTools.trim(condition.substring("IF".length));
						};
					} else {
						condition = null;
					};
					let elseContent = [];
					Parser.block(reader, function () {
						elseContent.push(arg());
					}, false);
					elseDatas.push({"condition": condition, "node": elseContent});
				} else {
					break;
				};
			} else {
				break;
			};
		};
		return AstNode.CompileTimeIf(pos, exp, content, elseDatas);
	}
	static get __name__() {
		return "mcl.Parser"
	}
	get __class__() {
		return Parser
	}
}


Parser.loopRegExp = new EReg("(REPEAT\\s*\\(.+?\\))\\s\\s*as\\s\\s*([a-zA-Z,\\s]+)", "")
Parser.executeRegExp = new EReg("\\b(run\\s+?)\\b", "")