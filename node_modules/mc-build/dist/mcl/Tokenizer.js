import {Register} from "../genes/Register.js"
import {StringTools} from "../StringTools.js"

const $global = Register.$global

export const Token = 
Register.global("$hxEnums")["mcl.Token"] = 
{
	__ename__: "mcl.Token",
	
	Literal: Object.assign((v, pos) => ({_hx_index: 0, __enum__: "mcl.Token", "v": v, "pos": pos, "@kind": "Literal"}), {_hx_name: "Literal", __params__: ["v", "pos"]}),
	BracketOpen: Object.assign((pos, data) => ({_hx_index: 1, __enum__: "mcl.Token", "pos": pos, "data": data, "@kind": "BracketOpen"}), {_hx_name: "BracketOpen", __params__: ["pos", "data"]}),
	BracketClose: Object.assign((pos) => ({_hx_index: 2, __enum__: "mcl.Token", "pos": pos, "@kind": "BracketClose"}), {_hx_name: "BracketClose", __params__: ["pos"]})
}
Token.__constructs__ = [Token.Literal, Token.BracketOpen, Token.BracketClose]
Token.__empty_constructs__ = []

export const Brackets = 
Register.global("$hxEnums")["mcl.Brackets"] = 
{
	__ename__: "mcl.Brackets",
	
	Curly: {_hx_name: "Curly", _hx_index: 0, __enum__: "mcl.Brackets", "@kind": "Curly"},
	Square: {_hx_name: "Square", _hx_index: 1, __enum__: "mcl.Brackets", "@kind": "Square"},
	Round: {_hx_name: "Round", _hx_index: 2, __enum__: "mcl.Brackets", "@kind": "Round"}
}
Brackets.__constructs__ = [Brackets.Curly, Brackets.Square, Brackets.Round]
Brackets.__empty_constructs__ = [Brackets.Curly, Brackets.Square, Brackets.Round]

export const Tokenizer = Register.global("$hxClasses")["mcl.Tokenizer"] = 
class Tokenizer {
	static tokenize(code, file) {
		let isInMultilineComment = false;
		let indents = [];
		let _g = [];
		let _g1 = 0;
		let _g2 = code.split("\n");
		while (_g1 < _g2.length) {
			let line = _g2[_g1];
			++_g1;
			let indent = 0;
			while (true) {
				let tmp;
				switch (line.charAt(0)) {
					case "\t":case " ":
						line = line.substring(1);
						++indent;
						tmp = true;
						break
					default:
					tmp = false;
					
				};
				if (!tmp) {
					break;
				};
			};
			indents.push(indent);
			_g.push(line);
		};
		let lines = _g;
		let result = [];
		let lineNum = 0;
		let colNum = 0;
		let lineIdx = 0;
		while (lineIdx < lines.length) {
			let line = lines[lineIdx];
			let indent = indents[lineNum];
			while (true) {
				while (line.charAt(line.length - 1) == "\n" || line.charAt(line.length - 1) == "\r") line = line.substring(0, line.length - 1);
				if (line.endsWith(" \\")) {
					line = StringTools.rtrim(line.substring(0, line.length - 2));
					line += " " + StringTools.trim(lines[++lineIdx]);
					++lineNum;
				} else {
					break;
				};
			};
			++lineIdx;
			++lineNum;
			if (line == "###") {
				isInMultilineComment = !isInMultilineComment;
				continue;
			};
			if (isInMultilineComment) {
				result.push(Token.Literal("### " + line, {"line": lineNum, "col": colNum + indent, "file": file}));
				continue;
			};
			if (line.charAt(0) == "#") {
				result.push(Token.Literal(line, {"line": lineNum, "col": colNum + indent, "file": file}));
				continue;
			};
			if (line.charAt(0) == "}") {
				result.push(Token.BracketClose({"line": lineNum, "col": colNum + indent, "file": file}));
				line = line.substring(1);
			};
			let i = 0;
			let braces = [];
			let done = false;
			while (i < line.length) {
				let idx = line.length - i - 1;
				let c = line.charAt(idx);
				if (c == "}") {
					braces.push(Brackets.Curly);
				} else if (c == "{") {
					if (braces.length == 0) {
						let content = StringTools.trim(line.substring(0, idx));
						if (content.length > 0) {
							result.push(Token.Literal(content, {"line": lineNum, "col": colNum + indent, "file": file}));
						};
						let tmp = StringTools.trim(line.substring(idx + 1));
						result.push(Token.BracketOpen({"line": lineNum, "col": colNum + indent + idx, "file": file}, tmp));
						done = true;
						break;
					};
					braces.pop();
				};
				++i;
			};
			let trimmed = StringTools.trim(line);
			if (done || trimmed.length == 0) {
				continue;
			};
			result.push(Token.Literal(StringTools.trim(trimmed), {"line": lineNum, "col": colNum + indent, "file": file}));
		};
		return result;
	}
	static get __name__() {
		return "mcl.Tokenizer"
	}
	get __class__() {
		return Tokenizer
	}
}

