import {TemplateArgument} from "./args/TemplateArgument"
import {PosInfo, Token} from "./Tokenizer"
import {TagManager} from "./TagManager"
import {LibStore} from "./LibStore"
import {UserConfig, Config} from "./Config"
import {AstNode, JsonTagType} from "./AstNode"
import {IntMap} from "../haxe/ds/IntMap"
import {IMap} from "../haxe/Constraints"
import {Map as Map__1} from "../Map"
import {Io} from "../Io"

export declare class ErrorUtil {
	static format(message: string, pos: PosInfo): string
	static formatWithStack(message: string, stack: PosInfo[]): string
	static formatContext(message: string, pos: PosInfo, context: CompilerContext): string
}

export declare class UidTracker {
	constructor()
	protected uid: number
	get(): number
}

export declare class McTemplate {
	constructor(name: string, body: AstNode[], file: McFile)
	protected name: string
	protected body: AstNode[]
	protected overloads: Map__1<TemplateArgument[], AstNode[]>
	protected loadBlock: null | AstNode[]
	protected tickBlock: null | AstNode[]
	protected file: McFile
	protected hasBeenUsed: boolean
	protected compileArgs(args: string, pos: PosInfo): TemplateArgument[]
	protected parse(nodes: AstNode[]): void
	protected inject(context: CompilerContext, into: McFile): void
	protected injectTransform(context: CompilerContext, into: McFile): AstNode
	protected jsValueCache: IntMap<any>
	process(file: McFile, context: CompilerContext, pos: PosInfo, value: string, extras: null | AstNode[]): void
	transform(file: McFile, context: CompilerContext, pos: PosInfo, value: string, extras: null | AstNode[]): AstNode
}

export declare class VariableMap {
	constructor(parent: null | VariableMap, variables?: null | Map__1<string, any>)
	protected parent: null | VariableMap
	protected variables: Map__1<string, any>
	protected _cache: null | Map__1<string, any>
	get(): Map__1<string, any>
	static globals: VariableMap
	static fromObject(obj: any): VariableMap
}

export type BaseNameInfo = {
	namespace: string, 
	path: string[]
}

export type CompilerContext = {
	append: (arg0: string) => void, 
	baseNamespaceInfo: BaseNameInfo, 
	compiler: Compiler, 
	currentFunction: null | string[], 
	functions: string[], 
	globalVariables: VariableMap, 
	isTemplate: boolean, 
	namespace: string, 
	path: string[], 
	replacements: VariableMap, 
	requireTemplateKeyword: boolean, 
	stack: PosInfo[], 
	templates: Map__1<string, McTemplate>, 
	uidIndex: UidTracker, 
	variables: VariableMap
}

export declare namespace ImportFileType {
	export type IMcFile = {"@kind": "IMcFile", _hx_index: 0, f: McFile, __enum__: "mcl.ImportFileType"}
	export const IMcFile: (f: McFile) => ImportFileType
	export type IJsFile = {"@kind": "IJsFile", _hx_index: 1, f: any, __enum__: "mcl.ImportFileType"}
	export const IJsFile: (f: any) => ImportFileType
}

export declare type ImportFileType = 
	| ImportFileType.IMcFile
	| ImportFileType.IJsFile

export declare class McFile {
	constructor(name: string, ast: AstNode[])
	name: string
	protected ast: AstNode[]
	templates: Map__1<string, McTemplate>
	protected exportedTemplates: Map__1<string, McTemplate>
	protected imports: Map__1<string, McFile>
	protected ext: string
	protected loadCommands: string[]
	protected tickCommands: string[]
	protected fileJs: any
	protected functionsDir: string
	protected tagsDir: string
	getTemplates(): Map__1<string, McTemplate>
	setup(compiler: Compiler): void
	createAnonymousFunction(pos: PosInfo, body: AstNode[], data: null | string, context: CompilerContext, name: null | string, isMacro: boolean): string
	embedTransform(context: CompilerContext, pos: PosInfo, varmap: Map__1<string, any>, body: AstNode[], useTld?: boolean): AstNode
	embed(context: CompilerContext, pos: PosInfo, varmap: Map__1<string, any>, body: AstNode[], useTld?: boolean): void
	protected transformTemplate(context: CompilerContext, pos: PosInfo, value: string, extras: null | AstNode[], isMacro: boolean): AstNode
	protected processTemplate(context: CompilerContext, pos: PosInfo, value: string, extras: null | AstNode[], isMacro: boolean): void
	protected compileInline(context: CompilerContext, code: string, isTLD?: boolean): void
	protected transformInline(context: CompilerContext, code: string, isTLD?: boolean): AstNode
	protected processMlScript(context: CompilerContext, pos: PosInfo, tokens: Token[], isTLD?: boolean): void
	protected processMlScriptTransform(context: CompilerContext, pos: PosInfo, tokens: Token[], isTLD?: boolean): AstNode
	protected transformCommand(node: AstNode, context: CompilerContext): AstNode
	protected evaluateFunctionHandle(handle: string, context: CompilerContext, pos: PosInfo, isMacro: boolean): string
	protected compileCommand(node: AstNode, context: CompilerContext): void
	protected compileFunction(pos: PosInfo, name: string, body: AstNode[], appendTo: null | string, context: CompilerContext): void
	protected compileDirectory(pos: PosInfo, name: string, body: AstNode[], context: CompilerContext): void
	protected transformTld(node: AstNode, context: CompilerContext): AstNode
	protected compileTld(node: AstNode, context: CompilerContext): void
	protected compileJsonFileImpl(pos: PosInfo, name: string, info: JsonTagType, entries: AstNode[], context: CompilerContext): void
	protected compileJsonFile(pos: PosInfo, name: string, info: JsonTagType, context: CompilerContext): void
	processCompilerLoop(expression: string, as: null | string[], context: CompilerContext, body: AstNode[], pos: PosInfo, handler: ((arg0: CompilerContext, arg1: AstNode) => void)): void
	protected stringifyJsonTag(pos: PosInfo, name: string, value: AstNode[], context: CompilerContext): string
	protected injectValues(target: null | string, context: CompilerContext, pos: PosInfo): string
	protected transformCompileTimeIf(expression: string, body: AstNode[], elseExpression: {
		condition: null | string, 
		node: AstNode[]
	}[], pos: PosInfo, newContext: CompilerContext, processNode: ((arg0: AstNode) => AstNode), isContinuation?: boolean): AstNode
	protected compileTimeIf(expression: string, body: AstNode[], elseExpression: {
		condition: null | string, 
		node: AstNode[]
	}[], pos: PosInfo, newContext: CompilerContext, processNode: ((arg0: AstNode) => void), isContinuation?: boolean): void
	transform(vars: VariableMap, compiler: Compiler): AstNode[]
	compile(vars: VariableMap, compiler: Compiler): void
	static invokeExpressionInline(expression: string, context: CompilerContext, pos: PosInfo): any
}

export declare class Compiler {
	constructor(baseDir: string, config: UserConfig, lib?: null | LibStore)
	io: Io
	protected files: Map__1<string, McFile>
	protected alreadySetupFiles: IMap<string, boolean>
	protected libStore: null | LibStore
	baseDir: string
	tags: TagManager
	packNamespace: string
	config: Config
	disableRequire: boolean
	templateParsingEnabled: boolean
	addFile(name: string, ast: AstNode[]): void
	resolve(baseFile: string, resolutionPath: string): ImportFileType
	getInitialPathInfo(p: string): {
		namespace: string, 
		path: string[]
	}
	success: boolean
	compile(root: VariableMap): void
	transform(root: VariableMap): Map<string, AstNode>
	protected topLevelAstNodes: AstNode[]
	addTopLevelAstNode(node: AstNode): void
}
