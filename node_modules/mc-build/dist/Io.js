import {FileSystem} from "./sys/FileSystem.js"
import {Helper} from "./js/node/buffer/Buffer.js"
import {Path} from "./haxe/io/Path.js"
import {StringMap} from "./haxe/ds/StringMap.js"
import {Sha1} from "./haxe/crypto/Sha1.js"
import {Resource} from "./haxe/Resource.js"
import {Exception} from "./haxe/Exception.js"
import {EsMap} from "./genes/util/EsMap.js"
import {Register} from "./genes/Register.js"
import * as Fs from "fs"
import {Buffer} from "buffer"

const $global = Register.$global

export const Io = function() {};
Io.__isInterface__ = true;

export const RevertTracker = Register.global("$hxClasses")["RevertTracker"] = 
class RevertTracker extends Register.inherits() {
	new() {
		this.filesTracked = new StringMap();
	}
	track(path) {
		if (FileSystem.exists(path)) {
			let this1 = this.filesTracked;
			let value = Helper.bytesOfBuffer(Fs.readFileSync(path));
			this1.inst.set(path, value);
		} else {
			this.filesTracked.inst.set(path, null);
		};
	}
	revert() {
		let map = this.filesTracked;
		let _g_map = map;
		let _g_keys = map.keys();
		while (_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let k = _g_key;
			let v = _g_value;
			if (v == null) {
				Fs.unlinkSync(k);
			} else {
				FileSystem.createDirectory(Path.directory(k));
				let data = v.b;
				Fs.writeFileSync(k, Buffer.from(data.buffer, data.byteOffset, v.length));
			};
		};
		this.filesTracked = new StringMap();
	}
	static get __name__() {
		return "RevertTracker"
	}
	get __class__() {
		return RevertTracker
	}
}


export const SyncIo = Register.global("$hxClasses")["SyncIo"] = 
class SyncIo extends Register.inherits() {
	new() {
		this.existingDirectories = new StringMap();
		this.revertMap = new RevertTracker();
		this.fileData = new StringMap();
	}
	reportFilesRemoved(oldFiles) {
		let _g = [];
		let file = EsMap.adaptIterator(oldFiles.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (!this.fileData.inst.has(file1)) {
				_g.push(file1);
			};
		};
		return _g;
	}
	reportFilesAdded(oldFiles) {
		let _g = [];
		let file = EsMap.adaptIterator(this.fileData.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (!oldFiles.inst.has(file1)) {
				_g.push(file1);
			};
		};
		return _g;
	}
	reportFilesChanged(oldFiles) {
		let _g = [];
		let file = EsMap.adaptIterator(this.fileData.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (oldFiles.inst.has(file1) && oldFiles.inst.get(file1) != this.fileData.inst.get(file1)) {
				_g.push(file1);
			};
		};
		return _g;
	}
	reportFileMetadata() {
		return this.fileData;
	}
	write(path, content) {
		let this1 = this.fileData;
		let value = Sha1.encode(content);
		this1.inst.set(path, value);
		this.revertMap.track(path);
		let dir = Path.directory(path);
		if (!this.existingDirectories.inst.has(dir)) {
			FileSystem.createDirectory(dir);
			this.existingDirectories.inst.set(dir, true);
		};
		Fs.writeFileSync(path, content);
	}
	cleanup() {
	}
	finished() {
		return true;
	}
	static get __name__() {
		return "SyncIo"
	}
	static get __interfaces__() {
		return [Io]
	}
	get __class__() {
		return SyncIo
	}
}


export const ThreadedIo = Register.global("$hxClasses")["ThreadedIo"] = 
class ThreadedIo extends Register.inherits() {
	new() {
		this.terminated = false;
		this.pending = false;
		this.done = false;
		this.fileData = new StringMap();
		this.queue = [];
		this.enableLog = false;
		this.proc || (this.proc = require('node:worker_threads'));;
		this.thread = new this.proc.Worker(Resource.getString("io-worker"),{name:'IoWorker',eval:true,workerData:{ enableLog : false}});;
		let _gthis = this;
		this.thread.on("error", function (error) {
			_gthis.log("Worker error: " + error);
			_gthis.terminated = true;
			throw Exception.thrown(error);
		});
		this.thread.on("exit", function (code) {
			_gthis.log("Worker stopped with exit code " + code);
			return _gthis.terminated = true;
		});
		this.thread.on("message", function () {
			_gthis.flush();
		});
	}
	reportFilesRemoved(oldFiles) {
		let _g = [];
		let file = EsMap.adaptIterator(oldFiles.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (!this.fileData.inst.has(file1)) {
				_g.push(file1);
			};
		};
		return _g;
	}
	reportFilesAdded(oldFiles) {
		let _g = [];
		let file = EsMap.adaptIterator(this.fileData.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (!oldFiles.inst.has(file1)) {
				_g.push(file1);
			};
		};
		return _g;
	}
	reportFilesChanged(oldFiles) {
		let _g = [];
		let file = EsMap.adaptIterator(this.fileData.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (oldFiles.inst.has(file1) && oldFiles.inst.get(file1) != this.fileData.inst.get(file1)) {
				_g.push(file1);
			};
		};
		return _g;
	}
	reportFileMetadata() {
		return this.fileData;
	}
	log(msg) {
		if (this.enableLog) {
			console.log("src/Io.hx:153:","[ThreadedIo | " + process.uptime() + "] " + msg);
		};
	}
	flush() {
		this.log("flush");
		if (this.queue.length == 0) {
			if (!this.done) {
				this.pending = false;
			} else {
				this.log("Terminating worker thread");
				this.thread.terminate();
			};
			return;
		};
		let packet = this.queue;
		this.queue = [];
		this.pending = true;
		this.log("Posting " + packet.length + " entries to worker thread");
		this.thread.postMessage(packet);
	}
	write(path, content) {
		let this1 = this.fileData;
		let value = Sha1.encode(content);
		this1.inst.set(path, value);
		this.log("write " + path);
		if (this.done) {
			throw Exception.thrown("Cannot write after cleanup()");
		};
		this.queue.push({"p": path, "c": content});
		if (!this.pending) {
			this.flush();
		};
	}
	cleanup() {
		this.log("cleanup");
		this.done = true;
		if (!this.pending) {
			this.flush();
		};
	}
	finished() {
		return this.terminated;
	}
	static get __name__() {
		return "ThreadedIo"
	}
	static get __interfaces__() {
		return [Io]
	}
	get __class__() {
		return ThreadedIo
	}
}


export const MultiThreadIo = Register.global("$hxClasses")["MultiThreadIo"] = 
class MultiThreadIo extends Register.inherits() {
	new(count) {
		this.fileData = new StringMap();
		this.idx = 0;
		this.threads = [];
		if ((count & count - 1) != 0) {
			throw Exception.thrown("Thread count must be a power of two");
		};
		this.mask = count - 1;
		let _g = 0;
		let _g1 = count;
		while (_g < _g1) {
			let i = _g++;
			this.threads.push(new ThreadedIo());
		};
	}
	reportFilesRemoved(oldFiles) {
		let result = [];
		let files = this.reportFileMetadata();
		let file = EsMap.adaptIterator(oldFiles.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (!files.inst.has(file1)) {
				result.push(file1);
			};
		};
		return result;
	}
	reportFilesAdded(oldFiles) {
		let files = this.reportFileMetadata();
		let result = [];
		let file = EsMap.adaptIterator(files.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (!oldFiles.inst.has(file1)) {
				result.push(file1);
			};
		};
		return result;
	}
	reportFilesChanged(oldFiles) {
		let data = this.reportFileMetadata();
		let result = [];
		let file = EsMap.adaptIterator(data.inst.keys());
		while (file.hasNext()) {
			let file1 = file.next();
			if (oldFiles.inst.has(file1) && oldFiles.inst.get(file1) != data.inst.get(file1)) {
				result.push(file1);
			};
		};
		return result;
	}
	reportFileMetadata() {
		let _g = 0;
		let _g1 = this.threads;
		while (_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			let file = EsMap.adaptIterator(t.reportFileMetadata().inst.keys());
			while (file.hasNext()) {
				let file1 = file.next();
				let this1 = this.fileData;
				let value = t.reportFileMetadata().inst.get(file1);
				this1.inst.set(file1, value);
			};
		};
		return this.fileData;
	}
	cleanup() {
		let _g = 0;
		let _g1 = this.threads;
		while (_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			t.cleanup();
		};
	}
	write(path, content) {
		this.threads[this.idx++ & this.mask].write(path, content);
	}
	finished() {
		let _g = 0;
		let _g1 = this.threads;
		while (_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			if (!t.finished()) {
				return false;
			};
		};
		return true;
	}
	static isPowerOfTwo(x) {
		return (x & x - 1) == 0;
	}
	static get __name__() {
		return "MultiThreadIo"
	}
	static get __interfaces__() {
		return [Io]
	}
	get __class__() {
		return MultiThreadIo
	}
}

