import {Boot} from "./js/Boot.js"
import {Exception} from "./haxe/Exception.js"
import {Register} from "./genes/Register.js"
import {Reflect as Reflect__1} from "./Reflect.js"

const $global = Register.$global

export const ValueType = 
Register.global("$hxEnums")["ValueType"] = 
{
	__ename__: "ValueType",
	
	TNull: {_hx_name: "TNull", _hx_index: 0, __enum__: "ValueType", "@kind": "TNull"},
	TInt: {_hx_name: "TInt", _hx_index: 1, __enum__: "ValueType", "@kind": "TInt"},
	TFloat: {_hx_name: "TFloat", _hx_index: 2, __enum__: "ValueType", "@kind": "TFloat"},
	TBool: {_hx_name: "TBool", _hx_index: 3, __enum__: "ValueType", "@kind": "TBool"},
	TObject: {_hx_name: "TObject", _hx_index: 4, __enum__: "ValueType", "@kind": "TObject"},
	TFunction: {_hx_name: "TFunction", _hx_index: 5, __enum__: "ValueType", "@kind": "TFunction"},
	TClass: Object.assign((c) => ({_hx_index: 6, __enum__: "ValueType", "c": c, "@kind": "TClass"}), {_hx_name: "TClass", __params__: ["c"]}),
	TEnum: Object.assign((e) => ({_hx_index: 7, __enum__: "ValueType", "e": e, "@kind": "TEnum"}), {_hx_name: "TEnum", __params__: ["e"]}),
	TUnknown: {_hx_name: "TUnknown", _hx_index: 8, __enum__: "ValueType", "@kind": "TUnknown"}
}
ValueType.__constructs__ = [ValueType.TNull, ValueType.TInt, ValueType.TFloat, ValueType.TBool, ValueType.TObject, ValueType.TFunction, ValueType.TClass, ValueType.TEnum, ValueType.TUnknown]
ValueType.__empty_constructs__ = [ValueType.TNull, ValueType.TInt, ValueType.TFloat, ValueType.TBool, ValueType.TObject, ValueType.TFunction, ValueType.TUnknown]

/**
The Haxe Reflection API allows retrieval of type information at runtime.

This class complements the more lightweight Reflect class, with a focus on
class and enum instances.

@see https://haxe.org/manual/types.html
@see https://haxe.org/manual/std-reflection.html
*/
export const Type = Register.global("$hxClasses")["Type"] = 
class Type {
	
	/**
	Creates an instance of class `cl`, using `args` as arguments to the
	class constructor.
	
	This function guarantees that the class constructor is called.
	
	Default values of constructors arguments are not guaranteed to be
	taken into account.
	
	If `cl` or `args` are null, or if the number of elements in `args` does
	not match the expected number of constructor arguments, or if any
	argument has an invalid type,  or if `cl` has no own constructor, the
	result is unspecified.
	
	In particular, default values of constructor arguments are not
	guaranteed to be taken into account.
	*/
	static createInstance(cl, args) {
		let ctor = Function.prototype.bind.apply(cl, [null].concat(args));
		return new (ctor);
	}
	
	/**
	Creates an instance of enum `e` by calling its constructor `constr` with
	arguments `params`.
	
	If `e` or `constr` is null, or if enum `e` has no constructor named
	`constr`, or if the number of elements in `params` does not match the
	expected number of constructor arguments, or if any argument has an
	invalid type, the result is unspecified.
	*/
	static createEnum(e, constr, params) {
		let f = Reflect__1.field(e, constr);
		if (f == null) {
			throw Exception.thrown("No such constructor " + constr);
		};
		if (Reflect__1.isFunction(f)) {
			if (params == null) {
				throw Exception.thrown("Constructor " + constr + " need parameters");
			};
			return f.apply(e, params);
		};
		if (params != null && params.length != 0) {
			throw Exception.thrown("Constructor " + constr + " does not need parameters");
		};
		return f;
	}
	
	/**
	Returns the runtime type of value `v`.
	
	The result corresponds to the type `v` has at runtime, which may vary
	per platform. Assumptions regarding this should be minimized to avoid
	surprises.
	*/
	static typeof(v) {
		switch (typeof(v)) {
			case "boolean":
				return ValueType.TBool;
				break
			case "function":
				if (v.__name__ || v.__ename__) {
					return ValueType.TObject;
				};
				return ValueType.TFunction;
				break
			case "number":
				if (Math.ceil(v) == v % 2147483648.0) {
					return ValueType.TInt;
				};
				return ValueType.TFloat;
				break
			case "object":
				if (v == null) {
					return ValueType.TNull;
				};
				let e = v.__enum__;
				if (e != null) {
					return ValueType.TEnum(Register.global("$hxEnums")[e]);
				};
				let c = Boot.getClass(v);
				if (c != null) {
					return ValueType.TClass(c);
				};
				return ValueType.TObject;
				break
			case "string":
				return ValueType.TClass(String);
				break
			case "undefined":
				return ValueType.TNull;
				break
			default:
			return ValueType.TUnknown;
			
		};
	}
	
	/**
	Recursively compares two enum instances `a` and `b` by value.
	
	Unlike `a == b`, this function performs a deep equality check on the
	arguments of the constructors, if exists.
	
	If `a` or `b` are null, the result is unspecified.
	*/
	static enumEq(a, b) {
		if (a == b) {
			return true;
		};
		try {
			let e = a.__enum__;
			if (e == null || e != b.__enum__) {
				return false;
			};
			if (a._hx_index != b._hx_index) {
				return false;
			};
			let enm = Register.global("$hxEnums")[e];
			let params = enm.__constructs__[a._hx_index].__params__;
			let _g = 0;
			while (_g < params.length) {
				let f = params[_g];
				++_g;
				if (!Type.enumEq(a[f], b[f])) {
					return false;
				};
			};
		}catch (_g) {
			return false;
		};
		return true;
	}
	static get __name__() {
		return "Type"
	}
	get __class__() {
		return Type
	}
}

