import {Iterators} from "./utils/Iterators.js"
import {Arrays} from "./utils/Arrays.js"
import {ValueType} from "./ValueType.js"
import {Value} from "./Value.js"
import {StringMap} from "../haxe/ds/StringMap.js"
import {EsMap} from "../genes/util/EsMap.js"
import {Register} from "../genes/Register.js"

const $global = Register.$global

export const BinaryOperations = Register.global("$hxClasses")["haxpression.BinaryOperations"] = 
class BinaryOperations {
	static evaluate(_operator, left, right) {
		return BinaryOperations.map.inst.get(_operator).operation(left, right);
	}
	static addOperator(_operator, precedence, operation) {
		let this1 = BinaryOperations.map;
		let value = {"precedence": precedence, "operation": BinaryOperations.wrapOperation(operation)};
		this1.inst.set(_operator, value);
	}
	static hasOperator(_operator) {
		return BinaryOperations.map.inst.has(_operator);
	}
	static getOperatorPrecedence(_operator) {
		return BinaryOperations.map.inst.get(_operator).precedence;
	}
	static getMaxOperatorLength() {
		return Arrays.reduce(Iterators.toArray(EsMap.adaptIterator(BinaryOperations.map.inst.keys())), function (maxLength, key) {
			if (key.length > maxLength) {
				return key.length;
			} else {
				return maxLength;
			};
		}, 0);
	}
	static wrapOperation(operation) {
		return function (left, right) {
			if (Value.isNA(left) || Value.isNA(right)) {
				return Value.fromValueType(ValueType.VNA);
			} else if (Value.isNM(left) || Value.isNM(right)) {
				return Value.fromValueType(ValueType.VNM);
			} else {
				return operation(left, right);
			};
		};
	}
	static get __name__() {
		return "haxpression.BinaryOperations"
	}
	get __class__() {
		return BinaryOperations
	}
}


;{
	BinaryOperations.map = new StringMap();
	BinaryOperations.addOperator("||", 1, function (left, right) {
		return Value.fromBool(Value.toBool(left) || Value.toBool(right));
	});
	BinaryOperations.addOperator("&&", 2, function (left, right) {
		return Value.fromBool(Value.toBool(left) && Value.toBool(right));
	});
	BinaryOperations.addOperator("|", 3, function (left, right) {
		return Value.fromInt(Value.toInt(left) | Value.toInt(right));
	});
	BinaryOperations.addOperator("^", 4, function (left, right) {
		return Value.fromInt(Value.toInt(left) ^ Value.toInt(right));
	});
	BinaryOperations.addOperator("&", 5, function (left, right) {
		return Value.fromInt(Value.toInt(left) & Value.toInt(right));
	});
	BinaryOperations.addOperator("==", 6, function (left, right) {
		return Value.fromBool(Value.toFloat(left) == Value.toFloat(right));
	});
	BinaryOperations.addOperator("!=", 6, function (left, right) {
		return Value.fromBool(Value.toFloat(left) != Value.toFloat(right));
	});
	BinaryOperations.addOperator("<", 7, function (left, right) {
		return Value.fromBool(Value.toFloat(left) < Value.toFloat(right));
	});
	BinaryOperations.addOperator(">", 7, function (left, right) {
		return Value.fromBool(Value.toFloat(left) > Value.toFloat(right));
	});
	BinaryOperations.addOperator("<=", 7, function (left, right) {
		return Value.fromBool(Value.toFloat(left) <= Value.toFloat(right));
	});
	BinaryOperations.addOperator(">=", 7, function (left, right) {
		return Value.fromBool(Value.toFloat(left) >= Value.toFloat(right));
	});
	BinaryOperations.addOperator("<<", 8, function (left, right) {
		return Value.fromInt(Value.toInt(left) << Value.toInt(right));
	});
	BinaryOperations.addOperator(">>", 8, function (left, right) {
		return Value.fromInt(Value.toInt(left) >> Value.toInt(right));
	});
	BinaryOperations.addOperator(">>>", 8, function (left, right) {
		return Value.fromInt(Value.toInt(left) >>> Value.toInt(right));
	});
	BinaryOperations.addOperator("+", 9, function (left, right) {
		return Value.fromFloat(Value.toFloat(left) + Value.toFloat(right));
	});
	BinaryOperations.addOperator("-", 9, function (left, right) {
		return Value.fromFloat(Value.toFloat(left) - Value.toFloat(right));
	});
	BinaryOperations.addOperator("*", 10, function (left, right) {
		return Value.fromFloat(Value.toFloat(left) * Value.toFloat(right));
	});
	BinaryOperations.addOperator("/", 10, function (left, right) {
		return Value.fromFloat(Value.toFloat(left) / Value.toFloat(right));
	});
	BinaryOperations.addOperator("%", 10, function (left, right) {
		return Value.fromFloat(Value.toFloat(left) % Value.toFloat(right));
	});
	BinaryOperations.addOperator("**", 11, function (left, right) {
		return Value.fromFloat(Math.pow(Value.toFloat(left), Value.toFloat(right)));
	});
}
