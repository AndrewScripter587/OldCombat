import {Iterators} from "./utils/Iterators.js"
import {Arrays} from "./utils/Arrays.js"
import {ValueType} from "./ValueType.js"
import {Value} from "./Value.js"
import {StringMap} from "../haxe/ds/StringMap.js"
import {EsMap} from "../genes/util/EsMap.js"
import {Register} from "../genes/Register.js"

const $global = Register.$global

export const UnaryOperations = Register.global("$hxClasses")["haxpression.UnaryOperations"] = 
class UnaryOperations {
	static evaluate(_operator, value) {
		return UnaryOperations.map.inst.get(_operator).operation(value);
	}
	static addOperator(_operator, operation) {
		let this1 = UnaryOperations.map;
		let value = {"operation": UnaryOperations.wrapOperation(operation)};
		this1.inst.set(_operator, value);
	}
	static hasOperator(_operator) {
		return UnaryOperations.map.inst.has(_operator);
	}
	static getMaxOperatorLength() {
		return Arrays.reduce(Iterators.toArray(EsMap.adaptIterator(UnaryOperations.map.inst.keys())), function (maxLength, key) {
			if (key.length > maxLength) {
				return key.length;
			} else {
				return maxLength;
			};
		}, 0);
	}
	static wrapOperation(operation) {
		return function (value) {
			if (Value.isNA(value)) {
				return Value.fromValueType(ValueType.VNA);
			} else if (Value.isNM(value)) {
				return Value.fromValueType(ValueType.VNM);
			} else {
				return operation(value);
			};
		};
	}
	static get __name__() {
		return "haxpression.UnaryOperations"
	}
	get __class__() {
		return UnaryOperations
	}
}


;{
	UnaryOperations.map = new StringMap();
	UnaryOperations.addOperator("-", function (value) {
		return Value.fromFloat(Value.toFloat(value) * -1);
	});
	UnaryOperations.addOperator("+", function (value) {
		return Value.fromFloat(Value.toFloat(value));
	});
	UnaryOperations.addOperator("!", function (value) {
		return Value.fromBool(!Value.toBool(value));
	});
	UnaryOperations.addOperator("~", function (value) {
		return Value.fromInt(~Value.toInt(value));
	});
}
