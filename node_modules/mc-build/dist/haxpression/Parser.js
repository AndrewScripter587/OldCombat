import {Chars} from "./utils/Chars.js"
import {ValueType} from "./ValueType.js"
import {UnaryOperations} from "./UnaryOperations.js"
import {ExpressionType} from "./ExpressionType.js"
import {Expression} from "./Expression.js"
import {Error as Error__1} from "./Error.js"
import {BinaryOperations} from "./BinaryOperations.js"
import {Exception} from "../haxe/Exception.js"
import {Register} from "../genes/Register.js"
import {HxOverrides} from "../HxOverrides.js"

const $global = Register.$global

export const Parser = Register.global("$hxClasses")["haxpression.Parser"] = 
class Parser extends Register.inherits() {
	new(inputString) {
		this.inputString = inputString;
		this.index = 0;
		this.length = inputString.length;
		this.expressions = [];
	}
	internalParse() {
		while (this.index < this.length) {
			let charCode = this.charCodeAt(this.index);
			if (charCode == Chars.SEMICOLON_CODE || charCode == Chars.COMMA_CODE) {
				this.index++;
			} else {
				let expression = this.gobbleExpression();
				if (expression != null) {
					this.expressions.push(expression);
				} else if (this.index < this.length) {
					throw Exception.thrown(new Error__1("unexpected internal parse \"" + this.charAt(this.index) + "\"", this.inputString, this.index));
				};
			};
		};
		if (this.expressions.length == 1) {
			return this.expressions[0];
		} else {
			let _this = this.expressions;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while (_g < _g1) {
				let i = _g++;
				result[i] = Expression.toExpressionType(_this[i]);
			};
			return Expression.fromExpressionType(ExpressionType.ECompound(result));
		};
	}
	charAt(index) {
		return this.inputString.charAt(index);
	}
	charCodeAt(index) {
		return HxOverrides.cca(this.inputString, index);
	}
	gobbleSpaces() {
		let charCode = this.charCodeAt(this.index);
		while (this.index < this.length && Chars.isWhiteSpace(charCode)) charCode = this.charCodeAt(++this.index);
	}
	gobbleExpression() {
		let expression = this.gobbleBinaryExpression();
		this.gobbleSpaces();
		if (this.charCodeAt(this.index) == Chars.QUESTION_MARK_CODE) {
			this.index++;
			let consequent = this.gobbleExpression();
			if (consequent == null) {
				throw Exception.thrown(new Error__1("expected a \"consequent\" expression for ternary conditional expression", this.inputString, this.index));
			};
			this.gobbleSpaces();
			if (this.charCodeAt(this.index) == Chars.COLON_CODE) {
				this.index++;
				let alternate = this.gobbleExpression();
				if (alternate == null) {
					throw Exception.thrown(new Error__1("expected an \"alternate\" expression for ternary conditional expression", this.inputString, this.index));
				};
				return Expression.fromExpressionType(ExpressionType.EConditional(Expression.toExpressionType(expression), Expression.toExpressionType(consequent), Expression.toExpressionType(alternate)));
			};
		};
		return expression;
	}
	gobbleBinaryOperator() {
		this.gobbleSpaces();
		let toCheck = HxOverrides.substr(this.inputString, this.index, BinaryOperations.getMaxOperatorLength());
		let toCheckLength = toCheck.length;
		while (toCheckLength > 0) {
			if (BinaryOperations.hasOperator(toCheck)) {
				this.index += toCheckLength;
				return toCheck;
			};
			--toCheckLength;
			toCheck = HxOverrides.substr(toCheck, 0, toCheckLength);
		};
		return null;
	}
	gobbleBinaryExpression() {
		let $char;
		let expression;
		let binaryOperator;
		let precedence;
		let stack;
		let left;
		let right;
		let left1 = this.gobbleToken();
		let binaryOperator1 = this.gobbleBinaryOperator();
		if (binaryOperator1 == null) {
			return left1;
		};
		let binaryOperatorInfo = {"_operator": binaryOperator1, "precedence": BinaryOperations.getOperatorPrecedence(binaryOperator1)};
		let right1 = this.gobbleToken();
		if (right1 == null) {
			throw Exception.thrown(new Error__1("expected expression after binary _operator: \"" + binaryOperator1 + "\"", this.inputString, this.index));
		};
		let stack1 = [left1, binaryOperatorInfo, right1];
		while (true) {
			binaryOperator1 = this.gobbleBinaryOperator();
			if (!(binaryOperator1 != null)) {
				break;
			};
			precedence = BinaryOperations.getOperatorPrecedence(binaryOperator1);
			if (precedence == 0) {
				break;
			};
			binaryOperatorInfo = {"_operator": binaryOperator1, "precedence": precedence};
			while (stack1.length > 2 && precedence <= stack1[stack1.length - 2].precedence) {
				right1 = stack1.pop();
				binaryOperator1 = stack1.pop()._operator;
				left1 = stack1.pop();
				let expression = ExpressionType.EBinary(binaryOperator1, Expression.toExpressionType(left1), Expression.toExpressionType(right1));
				stack1.push(expression);
			};
			expression = this.gobbleToken();
			if (expression == null) {
				throw Exception.thrown(new Error__1("expected expression after binary _operator: \"" + binaryOperator1 + "\"", this.inputString, this.index));
			};
			stack1.push(binaryOperatorInfo);
			stack1.push(expression);
		};
		let i = stack1.length - 1;
		expression = stack1[i];
		while (i > 1) {
			expression = Expression.fromExpressionType(ExpressionType.EBinary(stack1[i - 1]._operator, stack1[i - 2], Expression.toExpressionType(expression)));
			i -= 2;
		};
		return expression;
	}
	gobbleToken() {
		this.gobbleSpaces();
		let charCode = this.charCodeAt(this.index);
		if (Chars.isDecimalDigit(charCode) || charCode == Chars.PERIOD_CODE) {
			return this.gobbleNumericLiteral();
		} else if (charCode == Chars.SINGLE_QUOTE_CODE || charCode == Chars.DOUBLE_QUOTE_CODE) {
			return this.gobbleStringLiteral();
		} else if (Chars.isIdentifierStart(charCode) || charCode == Chars.OPEN_PAREN_CODE) {
			return this.gobbleVariable();
		} else if (charCode == Chars.OPEN_BRACKET_CODE) {
			return this.gobbleArray();
		} else {
			let toCheck = HxOverrides.substr(this.inputString, this.index, UnaryOperations.getMaxOperatorLength());
			let toCheckLength = toCheck.length;
			while (toCheckLength > 0) {
				if (UnaryOperations.hasOperator(toCheck)) {
					this.index += toCheckLength;
					return Expression.fromExpressionType(ExpressionType.EUnary(toCheck, Expression.toExpressionType(this.gobbleToken())));
				};
				--toCheckLength;
				toCheck = HxOverrides.substr(toCheck, 0, toCheckLength);
			};
			return null;
		};
	}
	gobbleNumericLiteral() {
		let numberString = "";
		while (this.index < this.length && Chars.isDecimalDigit(this.charCodeAt(this.index))) numberString += this.charAt(this.index++);
		if (this.charCodeAt(this.index) == Chars.PERIOD_CODE) {
			numberString += this.charAt(this.index++);
			while (this.index < this.length && Chars.isDecimalDigit(this.charCodeAt(this.index))) numberString += this.charAt(this.index++);
		};
		let $char = this.charAt(this.index);
		if ($char == "e" || $char == "E") {
			numberString += this.charAt(this.index++);
			$char = this.charAt(this.index);
			if ($char == "+" || $char == "-") {
				numberString += this.charAt(this.index++);
			};
			while (this.index < this.length && Chars.isDecimalDigit(this.charCodeAt(this.index))) numberString += this.charAt(this.index++);
			if (!Chars.isDecimalDigit(this.charCodeAt(this.index - 1))) {
				throw Exception.thrown(new Error__1("expected exponent in numeric literal: \"" + numberString + this.charAt(this.index) + "\"", this.inputString, this.index));
			};
		};
		if (this.index >= this.length) {
			return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VFloat(parseFloat(numberString))));
		};
		let charCode = this.charCodeAt(this.index);
		if (Chars.isIdentifierStart(charCode)) {
			throw Exception.thrown(new Error__1("variable names cannot start with a number: \"" + numberString + this.charAt(this.index) + "\"", this.inputString, this.index));
		} else if (charCode == Chars.PERIOD_CODE) {
			throw Exception.thrown(new Error__1("unexpected period in numeric literal: \"" + numberString + this.charAt(this.index) + "\"", this.inputString, this.index));
		};
		return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VFloat(parseFloat(numberString))));
	}
	gobbleStringLiteral() {
		let str = "";
		let quote = this.charAt(this.index++);
		let closed = false;
		while (this.index < this.length) {
			let $char = this.charAt(this.index++);
			if ($char == quote) {
				closed = true;
				break;
			} else if ($char == "\\") {
				$char = this.charAt(this.index++);
				switch ($char) {
					case "n":
						str += "\n";
						break
					case "r":
						str += "\r";
						break
					case "t":
						str += "\t";
						break
					case "v":
						str += "\x0B";
						break
					
				};
			} else {
				str += $char;
			};
		};
		if (!closed) {
			throw Exception.thrown(new Error__1("unclosed quote after: \"" + str + "\"", this.inputString, this.index));
		};
		return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VString(str)));
	}
	gobbleIdentifier() {
		let charCode = this.charCodeAt(this.index);
		let start = this.index;
		if (Chars.isIdentifierStart(charCode)) {
			this.index++;
		} else {
			throw Exception.thrown(new Error__1("unexpected " + this.charAt(this.index), this.inputString, this.index));
		};
		while (this.index < this.length) {
			charCode = this.charCodeAt(this.index);
			if (Chars.isIdentifierPart(charCode)) {
				this.index++;
			} else {
				break;
			};
		};
		let identifier = this.inputString.substring(start, this.index);
		switch (identifier.toLowerCase()) {
			case "false":
				return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VBool(false)));
				break
			case "na":
				return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNA));
				break
			case "nm":
				return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNM));
				break
			case "null":
				return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNA));
				break
			case "true":
				return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VBool(true)));
				break
			case "undefined":
				return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNA));
				break
			default:
			return Expression.fromExpressionType(ExpressionType.EIdentifier(identifier));
			
		};
	}
	gobbleArguments(terminationCharCode) {
		let expressions = [];
		let sawTermination = false;
		while (this.index < this.length) {
			this.gobbleSpaces();
			let charCode = this.charCodeAt(this.index);
			if (charCode == terminationCharCode) {
				sawTermination = true;
				this.index++;
				break;
			} else if (charCode == Chars.COMMA_CODE) {
				this.index++;
			} else {
				let expression = this.gobbleExpression();
				if (expression == null || Expression.isCompound(expression)) {
					throw Exception.thrown(new Error__1("expected comma between arguments", this.inputString, this.index));
				};
				expressions.push(expression);
			};
		};
		if (!sawTermination) {
			let $char = String.fromCodePoint(terminationCharCode);
			throw Exception.thrown(new Error__1("expected termination character: \"" + $char + "\"", this.inputString, this.index));
		};
		return expressions;
	}
	gobbleVariable() {
		let charCode = this.charCodeAt(this.index);
		let expression;
		if (charCode == Chars.OPEN_PAREN_CODE) {
			expression = this.gobbleGroup();
		} else {
			expression = this.gobbleIdentifier();
		};
		this.gobbleSpaces();
		if (this.index < this.length) {
			charCode = this.charCodeAt(this.index);
			while (this.index < this.length && (charCode == Chars.PERIOD_CODE || charCode == Chars.OPEN_BRACKET_CODE || charCode == Chars.OPEN_PAREN_CODE)) {
				this.index++;
				if (charCode == Chars.PERIOD_CODE) {
					throw Exception.thrown(new Error__1("member access expressions like \"a.b\" are not supported", this.inputString, this.index));
				} else if (charCode == Chars.OPEN_BRACKET_CODE) {
					throw Exception.thrown(new Error__1("member access expressions like \"a[\"b\"]\" are not supported", this.inputString, this.index));
				} else if (charCode == Chars.OPEN_PAREN_CODE) {
					let callee;
					let _g = Expression.toExpressionType(expression);
					if (_g._hx_index == 1) {
						let name = _g.name;
						callee = name;
					} else {
						throw Exception.thrown(new Error__1("expected function name identifier for function call expression", this.inputString, this.index));
					};
					let _this = this.gobbleArguments(Chars.CLOSE_PAREN_CODE);
					let result = new Array(_this.length);
					let _g1 = 0;
					let _g2 = _this.length;
					while (_g1 < _g2) {
						let i = _g1++;
						result[i] = Expression.toExpressionType(_this[i]);
					};
					let $arguments = result;
					expression = Expression.fromExpressionType(ExpressionType.ECall(callee, $arguments));
				};
				this.gobbleSpaces();
				charCode = this.charCodeAt(this.index);
			};
		};
		return expression;
	}
	gobbleGroup() {
		this.index++;
		let expression = this.gobbleExpression();
		if (this.charCodeAt(this.index) == Chars.CLOSE_PAREN_CODE) {
			this.index++;
			return expression;
		} else {
			throw Exception.thrown(new Error__1("unclosed (", this.inputString, this.index));
		};
	}
	gobbleArray() {
		this.index++;
		let _this = this.gobbleArguments(Chars.CLOSE_BRACKET_CODE);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while (_g < _g1) {
			let i = _g++;
			result[i] = Expression.toExpressionType(_this[i]);
		};
		let items = result;
		return Expression.fromExpressionType(ExpressionType.EArray(items));
	}
	static parse(input) {
		let parser = new Parser(input);
		return parser.internalParse();
	}
	static get __name__() {
		return "haxpression.Parser"
	}
	get __class__() {
		return Parser
	}
}

