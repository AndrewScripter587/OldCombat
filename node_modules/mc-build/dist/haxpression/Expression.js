import {ValueType} from "./ValueType.js"
import {Value} from "./Value.js"
import {UnaryOperations} from "./UnaryOperations.js"
import {ExpressionTypes} from "./ExpressionTypes.js"
import {ExpressionType} from "./ExpressionType.js"
import {Error as Error__1} from "./Error.js"
import {CallOperations} from "./CallOperations.js"
import {BinaryOperations} from "./BinaryOperations.js"
import {StringMap} from "../haxe/ds/StringMap.js"
import {Exception} from "../haxe/Exception.js"
import {Register} from "../genes/Register.js"

const $global = Register.$global

export const Expression = Register.global("$hxClasses")["haxpression._Expression.Expression"] = 
class Expression {
	static fromExpressionType(expressionType) {
		return expressionType;
	}
	static toExpressionType(this1) {
		return this1;
	}
	static simplify(this1) {
		switch (this1._hx_index) {
			case 0:
				let value = this1.value;
				return Expression.fromExpressionType(ExpressionType.ELiteral(value));
				break
			case 1:
				let name = this1.name;
				return Expression.fromExpressionType(ExpressionType.EIdentifier(name));
				break
			case 2:
				let _operator = this1._operator;
				let operand = this1.operand;
				if (Expression.canEvaluate(Expression.fromExpressionType(operand))) {
					return Expression.fromExpressionType(ExpressionType.ELiteral(Value.toValueType(UnaryOperations.evaluate(_operator, Expression.evaluate(Expression.fromExpressionType(operand))))));
				} else {
					return Expression.fromExpressionType(ExpressionType.EUnary(_operator, Expression.toExpressionType(Expression.simplify(Expression.fromExpressionType(operand)))));
				};
				break
			case 3:
				let _operator1 = this1._operator;
				let left = this1.left;
				let right = this1.right;
				if (Expression.canEvaluate(Expression.fromExpressionType(left)) && Expression.canEvaluate(Expression.fromExpressionType(right))) {
					return Expression.fromExpressionType(ExpressionType.ELiteral(Value.toValueType(BinaryOperations.evaluate(_operator1, Expression.evaluate(Expression.fromExpressionType(left)), Expression.evaluate(Expression.fromExpressionType(right))))));
				} else {
					return Expression.fromExpressionType(ExpressionType.EBinary(_operator1, Expression.toExpressionType(Expression.simplify(Expression.fromExpressionType(left))), Expression.toExpressionType(Expression.simplify(Expression.fromExpressionType(right)))));
				};
				break
			case 4:
				let callee = this1.callee;
				let $arguments = this1["arguments"];
				if (ExpressionTypes.canEvaluateAll($arguments)) {
					return Expression.fromExpressionType(ExpressionType.ELiteral(Value.toValueType(CallOperations.evaluate(callee, ExpressionTypes.evaluate($arguments)))));
				} else {
					return Expression.fromExpressionType(ExpressionType.ECall(callee, ExpressionTypes.simplify($arguments)));
				};
				break
			case 5:
				let test = this1.test;
				let consequent = this1.consequent;
				let alternate = this1.alternate;
				if (Expression.canEvaluate(Expression.fromExpressionType(test))) {
					if (Value.toBool(Expression.evaluate(Expression.fromExpressionType(test)))) {
						return Expression.simplify(Expression.fromExpressionType(consequent));
					} else {
						return Expression.simplify(Expression.fromExpressionType(alternate));
					};
				} else {
					return Expression.fromExpressionType(ExpressionType.EConditional(Expression.toExpressionType(Expression.simplify(Expression.fromExpressionType(test))), Expression.toExpressionType(Expression.simplify(Expression.fromExpressionType(consequent))), Expression.toExpressionType(Expression.simplify(Expression.fromExpressionType(alternate)))));
				};
				break
			case 6:
				let items = this1.items;
				return Expression.fromExpressionType(ExpressionType.EArray(ExpressionTypes.simplify(items)));
				break
			case 7:
				let items1 = this1.items;
				return Expression.fromExpressionType(ExpressionType.ECompound(ExpressionTypes.simplify(items1)));
				break
			
		};
	}
	static canEvaluate(this1) {
		switch (this1._hx_index) {
			case 0:
				let value = this1.value;
				return true;
				break
			case 1:
				let name = this1.name;
				return false;
				break
			case 2:
				let _operator = this1._operator;
				let operand = this1.operand;
				return Expression.canEvaluate(Expression.fromExpressionType(operand));
				break
			case 3:
				let _operator1 = this1._operator;
				let left = this1.left;
				let right = this1.right;
				if (Expression.canEvaluate(Expression.fromExpressionType(left))) {
					return Expression.canEvaluate(Expression.fromExpressionType(right));
				} else {
					return false;
				};
				break
			case 4:
				let callee = this1.callee;
				let $arguments = this1["arguments"];
				return CallOperations.canEvaluate(callee, $arguments);
				break
			case 5:
				let test = this1.test;
				let consequent = this1.consequent;
				let alternate = this1.alternate;
				if (!Expression.canEvaluate(Expression.fromExpressionType(test))) {
					return false;
				} else if (Value.toBool(Expression.evaluate(Expression.fromExpressionType(test)))) {
					return Expression.canEvaluate(Expression.fromExpressionType(consequent));
				} else {
					return Expression.canEvaluate(Expression.fromExpressionType(alternate));
				};
				break
			case 6:
				let items = this1.items;
				return ExpressionTypes.canEvaluateAll(items);
				break
			case 7:
				let items1 = this1.items;
				return ExpressionTypes.canEvaluateAll(items1);
				break
			
		};
	}
	static evaluate(this1, variables) {
		if (variables == null) {
			variables = new StringMap();
		};
		switch (this1._hx_index) {
			case 0:
				let value = this1.value;
				return Value.fromValueType(value);
				break
			case 1:
				let name = this1.name;
				if (!variables.inst.has(name)) {
					throw Exception.thrown(new Error__1("cannot evaluate expression with unset variable: " + name));
				};
				return variables.inst.get(name);
				break
			case 2:
				let _operator = this1._operator;
				let operand = this1.operand;
				let operandValue = Expression.evaluate(Expression.fromExpressionType(operand), variables);
				return UnaryOperations.evaluate(_operator, operandValue);
				break
			case 3:
				let _operator1 = this1._operator;
				let left = this1.left;
				let right = this1.right;
				let leftValue = Expression.evaluate(Expression.fromExpressionType(left), variables);
				let rightValue = Expression.evaluate(Expression.fromExpressionType(right), variables);
				return BinaryOperations.evaluate(_operator1, leftValue, rightValue);
				break
			case 4:
				let callee = this1.callee;
				let $arguments = this1["arguments"];
				return CallOperations.evaluate(callee, ExpressionTypes.evaluate($arguments, variables));
				break
			case 5:
				let test = this1.test;
				let consequent = this1.consequent;
				let alternate = this1.alternate;
				if (Value.toBool(Expression.evaluate(Expression.fromExpressionType(test), variables))) {
					return Expression.evaluate(Expression.fromExpressionType(consequent), variables);
				} else {
					return Expression.evaluate(Expression.fromExpressionType(alternate), variables);
				};
				break
			case 6:
				let items = this1.items;
				if (items.length == 0) {
					return Value.fromValueType(ValueType.VNA);
				} else {
					let values = ExpressionTypes.evaluate(items, variables);
					return values[values.length - 1];
				};
				break
			case 7:
				let items1 = this1.items;
				if (items1.length == 0) {
					return Value.fromValueType(ValueType.VNA);
				} else {
					let values = ExpressionTypes.evaluate(items1, variables);
					return values[values.length - 1];
				};
				break
			
		};
	}
	static isCompound(this1) {
		let _g = Expression.toExpressionType(this1);
		if (_g._hx_index == 7) {
			let _g1 = _g.items;
			return true;
		} else {
			return false;
		};
	}
	static get __name__() {
		return "haxpression._Expression.Expression_Impl_"
	}
	get __class__() {
		return Expression
	}
}

