#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse = require_parse();
    var utils = require_utils();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/index.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var { Readable } = require("stream");
    var sysPath = require("path");
    var { promisify } = require("util");
    var picomatch = require_picomatch2();
    var readdir = promisify(fs.readdir);
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var realpath = promisify(fs.realpath);
    var BANG = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
    var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    var normalizeFilter = (filter) => {
      if (filter === void 0)
        return;
      if (typeof filter === "function")
        return filter;
      if (typeof filter === "string") {
        const glob = picomatch(filter.trim());
        return (entry) => glob(entry.basename);
      }
      if (Array.isArray(filter)) {
        const positive = [];
        const negative = [];
        for (const item of filter) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG) {
            negative.push(picomatch(trimmed.slice(1)));
          } else {
            positive.push(picomatch(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry) => positive.some((f) => f(entry.basename)) && !negative.some((f) => f(entry.basename));
          }
          return (entry) => !negative.some((f) => f(entry.basename));
        }
        return (entry) => positive.some((f) => f(entry.basename));
      }
    };
    var ReaddirpStream = class _ReaddirpStream extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path) => true,
          directoryFilter: (path) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options.highWaterMark || 4096
        });
        const opts = { ..._ReaddirpStream.defaultOptions, ...options };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        if (wantBigintFsStats) {
          this._stat = (path) => statMethod(path, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath.resolve(root);
        this._isDirent = "Dirent" in fs && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path, depth, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));
              for (const entry of await Promise.all(slice)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path, depth) {
        let files;
        try {
          files = await readdir(path, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path };
      }
      async _formatEntry(dirent, path) {
        let entry;
        try {
          const basename = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath.resolve(sysPath.join(path, basename));
          entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        const stats = entry && entry[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await realpath(full);
            const entryRealPathStats = await lstat(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp = (root, options = {}) => {
      let type = options.entryType || options.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options.root = root;
      return new ReaddirpStream(options);
    };
    var readdirpPromise = (root, options = {}) => {
      return new Promise((resolve, reject) => {
        const files = [];
        readdirp(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve(files)).on("error", (error) => reject(error));
      });
    };
    readdirp.promise = readdirpPromise;
    readdirp.ReaddirpStream = ReaddirpStream;
    readdirp.default = readdirp;
    module2.exports = readdirp;
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/normalize-path/index.js"(exports, module2) {
    module2.exports = function(path, stripTrailing) {
      if (typeof path !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path === "\\" || path === "/")
        return "/";
      var len = path.length;
      if (len <= 1)
        return path;
      var prefix = "";
      if (len > 4 && path[3] === "\\") {
        var ch = path[2];
        if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
          path = path.slice(2);
          prefix = "//";
        }
      }
      var segs = path.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "node_modules/anymatch/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var picomatch = require_picomatch2();
    var normalizePath = require_normalize_path();
    var BANG = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher, options) => {
      if (typeof matcher === "function") {
        return matcher;
      }
      if (typeof matcher === "string") {
        const glob = picomatch(matcher, options);
        return (string) => matcher === string || glob(string);
      }
      if (matcher instanceof RegExp) {
        return (string) => matcher.test(string);
      }
      return (string) => false;
    };
    var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path = normalizePath(_path, false);
      for (let index = 0; index < negPatterns.length; index++) {
        const nglob = negPatterns[index];
        if (nglob(path)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path].concat(args.slice(1));
      for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (isList ? pattern(...applied) : pattern(path)) {
          return returnIndex ? index : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options === "boolean" ? { returnIndex: options } : options;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch.default = anymatch;
    module2.exports = anymatch;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      const node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = (ast, options = {}) => {
      const stringify = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils2();
    var compile = (ast, options = {}) => {
      const walk = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix, node.value);
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils2();
    var append = (queue = "", stash = "", enclose = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          const child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/binary-extensions/binary-extensions.json"(exports, module2) {
    module2.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "node_modules/binary-extensions/index.js"(exports, module2) {
    module2.exports = require_binary_extensions();
  }
});

// node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/is-binary-path/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var binaryExtensions = require_binary_extensions2();
    var extensions = new Set(binaryExtensions);
    module2.exports = (filePath) => extensions.has(path.extname(filePath).slice(1).toLowerCase());
  }
});

// node_modules/chokidar/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/chokidar/lib/constants.js"(exports) {
    "use strict";
    var { sep } = require("path");
    var { platform } = process;
    var os2 = require("os");
    exports.EV_ALL = "all";
    exports.EV_READY = "ready";
    exports.EV_ADD = "add";
    exports.EV_CHANGE = "change";
    exports.EV_ADD_DIR = "addDir";
    exports.EV_UNLINK = "unlink";
    exports.EV_UNLINK_DIR = "unlinkDir";
    exports.EV_RAW = "raw";
    exports.EV_ERROR = "error";
    exports.STR_DATA = "data";
    exports.STR_END = "end";
    exports.STR_CLOSE = "close";
    exports.FSEVENT_CREATED = "created";
    exports.FSEVENT_MODIFIED = "modified";
    exports.FSEVENT_DELETED = "deleted";
    exports.FSEVENT_MOVED = "moved";
    exports.FSEVENT_CLONED = "cloned";
    exports.FSEVENT_UNKNOWN = "unknown";
    exports.FSEVENT_TYPE_FILE = "file";
    exports.FSEVENT_TYPE_DIRECTORY = "directory";
    exports.FSEVENT_TYPE_SYMLINK = "symlink";
    exports.KEY_LISTENERS = "listeners";
    exports.KEY_ERR = "errHandlers";
    exports.KEY_RAW = "rawEmitters";
    exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
    exports.DOT_SLASH = `.${sep}`;
    exports.BACK_SLASH_RE = /\\/g;
    exports.DOUBLE_SLASH_RE = /\/\//;
    exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports.REPLACER_RE = /^\.[/\\]/;
    exports.SLASH = "/";
    exports.SLASH_SLASH = "//";
    exports.BRACE_START = "{";
    exports.BANG = "!";
    exports.ONE_DOT = ".";
    exports.TWO_DOTS = "..";
    exports.STAR = "*";
    exports.GLOBSTAR = "**";
    exports.ROOT_GLOBSTAR = "/**/*";
    exports.SLASH_GLOBSTAR = "/**";
    exports.DIR_SUFFIX = "Dir";
    exports.ANYMATCH_OPTS = { dot: true };
    exports.STRING_TYPE = "string";
    exports.FUNCTION_TYPE = "function";
    exports.EMPTY_STR = "";
    exports.EMPTY_FN = () => {
    };
    exports.IDENTITY_FN = (val) => val;
    exports.isWindows = platform === "win32";
    exports.isMacos = platform === "darwin";
    exports.isLinux = platform === "linux";
    exports.isIBMi = os2.type() === "OS400";
  }
});

// node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "node_modules/chokidar/lib/nodefs-handler.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var isBinaryPath = require_is_binary_path();
    var {
      isWindows,
      isLinux,
      EMPTY_FN,
      EMPTY_STR,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE,
      EV_ADD,
      EV_ADD_DIR,
      EV_ERROR,
      STR_DATA,
      STR_END,
      BRACE_START,
      STAR
    } = require_constants3();
    var THROTTLE_MODE_WATCH = "watch";
    var open = promisify(fs.open);
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var close = promisify(fs.close);
    var fsrealpath = promisify(fs.realpath);
    var statMethods = { lstat, stat };
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set = cont[key];
      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path);
        emitRaw(rawEvent, evPath, { watchedPath: path });
        if (evPath && path !== evPath) {
          fsWatchBroadcast(
            sysPath.resolve(path, evPath),
            KEY_LISTENERS,
            sysPath.join(path, evPath)
          );
        }
      };
      try {
        return fs.watch(path, options, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path, fullPath, options, handlers) => {
      const { listener, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(
          path,
          options,
          listener,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path,
          options,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher)
          return;
        watcher.on(EV_ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows && error.code === "EPERM") {
            try {
              const fd = await open(path, "r");
              await close(fd);
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path, fullPath, options, handlers) => {
      const { listener, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      let listeners = /* @__PURE__ */ new Set();
      let rawEmitters = /* @__PURE__ */ new Set();
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        listeners = cont.listeners;
        rawEmitters = cont.rawEmitters;
        fs.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options,
          watcher: fs.watchFile(fullPath, options, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path);
        const basename = sysPath.basename(path);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath.resolve(path);
        const options = { persistent: opts.persistent };
        if (!listener)
          listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path, absolutePath, options, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path, absolutePath, options, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname2 = sysPath.dirname(file);
        const basename = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname2);
        let prevStats = stats;
        if (parent.has(basename))
          return;
        const listener = async (path, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat(file);
              if (this.fsw.closed)
                return;
              const at = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path);
                prevStats = newStats2;
                this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname2, basename);
            }
          } else if (parent.has(basename)) {
            const at = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at || at <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD, file, 0))
            return;
          this.fsw._emit(EV_ADD, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry, directory, path, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path);
          } catch (e) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE, path, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD, path, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, EMPTY_STR);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry),
          depth: 0
        }).on(STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const item = entry.path;
          let path = sysPath.join(directory, item);
          current.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path = sysPath.join(dir, sysPath.relative(dir, path));
            this._addToNodeFs(path, initialAdd, wh, depth + 1);
          }
        }).on(EV_ERROR, this._boundHandleError);
        return new Promise(
          (resolve) => stream.once(STR_END, () => {
            if (this.fsw.closed) {
              stream = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve();
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path, depth);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path);
            const targetPath = follow ? await fsrealpath(path) : path;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path) : path;
            if (this.fsw.closed)
              return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path;
          }
        }
      }
    };
    module2.exports = NodeFsHandler;
  }
});

// node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "node_modules/chokidar/lib/fsevents-handler.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var fsevents;
    try {
      fsevents = require("fsevents");
    } catch (error) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj = Number.parseInt(mtch[1], 10);
        const min = Number.parseInt(mtch[2], 10);
        if (maj === 8 && min < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD,
      EV_CHANGE,
      EV_ADD_DIR,
      EV_UNLINK,
      EV_ERROR,
      STR_DATA,
      STR_END,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      // FSEVENT_CLONED,
      FSEVENT_UNKNOWN,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE,
      EMPTY_FN,
      IDENTITY_FN
    } = require_constants3();
    var Depth = (value) => isNaN(value) ? {} : { depth: value };
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var realpath = promisify(fs.realpath);
    var statMethods = { stat, lstat };
    var FSEventsWatchers = /* @__PURE__ */ new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path, callback) => {
      const stop = fsevents.watch(path, callback);
      return { stop };
    };
    function setFSEventsListener(path, realPath, listener, rawEmitter) {
      let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
      const parentPath = sysPath.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath.resolve(path);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
          listener(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list) => {
              list(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate = (path) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path, root) => {
      let i = 0;
      while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root)
        i++;
      return i;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler = class {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path, stats)) {
          ipaths.add(path);
          if (stats && stats.isDirectory()) {
            ipaths.add(path + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path);
        ipaths.delete(path + ROOT_GLOBSTAR);
      }
      addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat(path);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error) {
          if (error.code === "EACCES") {
            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path))
          return;
        if (event === EV_UNLINK) {
          const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory);
          }
        } else {
          if (event === EV_ADD) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path);
          if (eventName === EV_ADD_DIR)
            this._addToFsEvents(path, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path = transform(sysPath.join(
            watchPath,
            sysPath.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path))
            return;
          const parent = sysPath.dirname(path);
          const item = sysPath.basename(path);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE) {
              let stats;
              try {
                stats = await stat(path);
              } catch (error) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path.replace(linkTarget, linkPath);
            } else if (path !== DOT_SLASH) {
              aliasedPath = sysPath.join(linkPath, path);
            }
            return transform(aliasedPath);
          }, false, curDepth);
        } catch (error) {
          if (this.fsw._handleError(error)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
        const base = sysPath.basename(pp);
        if (isDir)
          this.fsw._getWatchedDir(pp);
        if (dirObj.has(base))
          return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
        }
      }
      initWatch(realPath, path, wh, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path, transform, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter)
              this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry) => wh.filterPath(entry),
              directoryFilter: (entry) => wh.filterDir(entry),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry.stats.isDirectory() && !wh.filterPath(entry))
                return;
              const joinedPath = sysPath.join(wh.watchPath, entry.path);
              const { fullPath } = entry;
              if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error) {
          if (!error || this.fsw._handleError(error)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform === FUNCTION_TYPE) {
            this.initWatch(void 0, path, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh.watchPath);
            } catch (e) {
            }
            this.initWatch(realPath, path, wh, processPath);
          }
        }
      }
    };
    module2.exports = FsEventsHandler;
    module2.exports.canUse = canUse;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports) {
    "use strict";
    var { EventEmitter } = require("events");
    var fs = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var readdirp = require_readdirp();
    var anymatch = require_anymatch().default;
    var globParent = require_glob_parent();
    var isGlob = require_is_glob();
    var braces = require_braces();
    var normalizePath = require_normalize_path();
    var NodeFsHandler = require_nodefs_handler();
    var FsEventsHandler = require_fsevents_handler();
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows,
      isMacos,
      isIBMi
    } = require_constants3();
    var stat = promisify(fs.stat);
    var readdir = promisify(fs.readdir);
    var arrify = (value = []) => Array.isArray(value) ? value : [value];
    var flatten = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));
    var normalizeIgnored = (cwd = EMPTY_STR) => (path) => {
      if (typeof path !== STRING_TYPE)
        return path;
      return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
    };
    var getAbsolutePath = (path, cwd) => {
      if (sysPath.isAbsolute(path)) {
        return path;
      }
      if (path.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path.slice(1));
      }
      return sysPath.join(cwd, path);
    };
    var undef = (opts, key) => opts[key] === void 0;
    var DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path;
        if (path === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry.fullPath;
      }
      entryPath(entry) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
        );
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
        expandedPath.forEach((path2) => {
          parts.push(sysPath.relative(this.watchPath, path2).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    var FSWatcher = class extends EventEmitter {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path) => {
            const absPath = getAbsolutePath(path, cwd);
            if (disableGlobbing || !isGlob(path)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path) => {
          if (path.startsWith(BANG)) {
            this._ignoredPaths.add(path.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path);
          this._ignoredPaths.delete(path + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path) => {
              const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
              if (res)
                this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path) => {
          if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
            if (cwd)
              path = sysPath.join(cwd, path);
            path = sysPath.resolve(path);
          }
          this._closePath(path);
          this._ignoredPaths.add(path);
          if (this._watched.has(path)) {
            this._ignoredPaths.add(path + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise)
            closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows)
          path = sysPath.normalize(path);
        if (opts.cwd)
          path = sysPath.relative(opts.cwd, path);
        const args = [event, path];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path))) {
          pw.lastChange = /* @__PURE__ */ new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path2) => {
                this.emit(...entry);
                this.emit(EV_ALL, ...entry);
                this._pendingUnlinks.delete(path2);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error);
        }
        return error || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path);
          const count = item ? item.count : 0;
          action.delete(path);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path;
        if (this.options.cwd && !sysPath.isAbsolute(path)) {
          fullPath = sysPath.join(this.options.cwd, path);
        }
        const now = /* @__PURE__ */ new Date();
        const awaitWriteFinish = (prevStat) => {
          fs.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(/* @__PURE__ */ new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path)) {
          this._pendingWrites.set(path, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path, stats) {
        if (this.options.atomic && DOT_RE.test(path))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path2) => typeof path2 === STRING_TYPE && !isGlob(path2)).map((path2) => path2 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path, stats]);
      }
      _isntIgnored(path, stat2) {
        return !this._isIgnored(path, stat2);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path, depth) {
        const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory) {
        const path = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);
        if (!this._throttle("remove", path, 100))
          return;
        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path))
          this._emit(eventName, path);
        if (!this.options.useFsEvents) {
          this._closePath(path);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path) {
        this._closeFile(path);
        const dir = sysPath.dirname(path);
        this._getWatchedDir(dir).remove(sysPath.basename(path));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path) {
        const closers = this._closers.get(path);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path);
        if (!list) {
          list = [];
          this._closers.set(path, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream = readdirp(root, options);
        this._streams.add(stream);
        stream.once(STR_CLOSE, () => {
          stream = void 0;
        });
        stream.once(STR_END, () => {
          if (stream) {
            this._streams.delete(stream);
            stream = void 0;
          }
        });
        return stream;
      }
    };
    exports.FSWatcher = FSWatcher;
    var watch2 = (paths, options) => {
      const watcher = new FSWatcher(options);
      watcher.add(paths);
      return watcher;
    };
    exports.watch = watch2;
  }
});

// bin/mcb.js
var mcb_exports = {};
__export(mcb_exports, {
  AppMain: () => AppMain,
  Compiler: () => Compiler,
  Globals: () => Globals,
  MultiThreadIo: () => MultiThreadIo,
  Parser: () => Parser,
  RevertTracker: () => RevertTracker,
  SyncIo: () => SyncIo,
  TemplateArgument: () => TemplateArgument,
  ThreadedIo: () => ThreadedIo,
  Tokenizer: () => Tokenizer
});
module.exports = __toCommonJS(mcb_exports);

// bin/genes/Register.js
var Register = class _Register {
  static global(name) {
    if (_Register.globals[name]) {
      return _Register.globals[name];
    } else {
      return _Register.globals[name] = {};
    }
    ;
  }
  static createStatic(obj, name, get) {
    let value = null;
    Object.defineProperty(obj, name, { "enumerable": true, "get": function() {
      if (get != null) {
        value = get();
        get = null;
      }
      ;
      return value;
    }, "set": function(v) {
      if (get != null) {
        value = get();
        get = null;
      }
      ;
      value = v;
    } });
  }
  static iterator(a) {
    if (!Array.isArray(a)) {
      return typeof a.iterator === "function" ? a.iterator.bind(a) : a.iterator;
    } else {
      let a1 = a;
      return function() {
        return _Register.mkIter(a1);
      };
    }
    ;
  }
  static getIterator(a) {
    if (!Array.isArray(a)) {
      return a.iterator();
    } else {
      return _Register.mkIter(a);
    }
    ;
  }
  static mkIter(a) {
    return new ArrayIterator(a);
  }
  static extend(superClass) {
    function res() {
      this.new.apply(this, arguments);
    }
    Object.setPrototypeOf(res.prototype, superClass.prototype);
    return res;
  }
  static inherits(resolve, defer) {
    if (defer == null) {
      defer = false;
    }
    ;
    function res() {
      if (defer && resolve && res.__init__)
        res.__init__();
      this.new.apply(this, arguments);
    }
    if (!defer) {
      if (resolve && resolve.__init__) {
        defer = true;
        res.__init__ = () => {
          if (resolve.__init__)
            resolve.__init__();
          Object.setPrototypeOf(res.prototype, resolve.prototype);
          res.__init__ = void 0;
        };
      } else if (resolve) {
        Object.setPrototypeOf(res.prototype, resolve.prototype);
      }
    } else {
      res.__init__ = () => {
        const superClass = resolve();
        if (superClass.__init__)
          superClass.__init__();
        Object.setPrototypeOf(res.prototype, superClass.prototype);
        res.__init__ = void 0;
      };
    }
    return res;
  }
  static bind(o, m) {
    if (m == null) {
      return null;
    }
    ;
    if (m.__id__ == null) {
      m.__id__ = _Register.fid++;
    }
    ;
    let f = null;
    if (o.hx__closures__ == null) {
      o.hx__closures__ = {};
    } else {
      f = o.hx__closures__[m.__id__];
    }
    ;
    if (f == null) {
      f = m.bind(o);
      o.hx__closures__[m.__id__] = f;
    }
    ;
    return f;
  }
  static get __name__() {
    return "genes.Register";
  }
  get __class__() {
    return _Register;
  }
};
Register.$global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : void 0;
Register.globals = {};
Register.fid = 0;
var ArrayIterator = Register.global("$hxClasses")["genes._Register.ArrayIterator"] = class ArrayIterator2 extends Register.inherits() {
  new(array) {
    this.current = 0;
    this.array = array;
  }
  hasNext() {
    return this.current < this.array.length;
  }
  next() {
    return this.array[this.current++];
  }
  static get __name__() {
    return "genes._Register.ArrayIterator";
  }
  get __class__() {
    return ArrayIterator2;
  }
};

// bin/mcli/internal/Data.js
var $global = Register.$global;
var Kind = Register.global("$hxEnums")["mcli.internal.Kind"] = {
  __ename__: "mcli.internal.Kind",
  Message: { _hx_name: "Message", _hx_index: 0, __enum__: "mcli.internal.Kind" },
  Flag: { _hx_name: "Flag", _hx_index: 1, __enum__: "mcli.internal.Kind" },
  VarHash: Object.assign((key, value, valueIsArray) => ({ _hx_index: 2, __enum__: "mcli.internal.Kind", "key": key, "value": value, "valueIsArray": valueIsArray }), { _hx_name: "VarHash", __params__: ["key", "value", "valueIsArray"] }),
  Var: Object.assign((t) => ({ _hx_index: 3, __enum__: "mcli.internal.Kind", "t": t }), { _hx_name: "Var", __params__: ["t"] }),
  Function: Object.assign((args, varArgs) => ({ _hx_index: 4, __enum__: "mcli.internal.Kind", "args": args, "varArgs": varArgs }), { _hx_name: "Function", __params__: ["args", "varArgs"] }),
  SubDispatch: { _hx_name: "SubDispatch", _hx_index: 5, __enum__: "mcli.internal.Kind" }
};
Kind.__constructs__ = [Kind.Message, Kind.Flag, Kind.VarHash, Kind.Var, Kind.Function, Kind.SubDispatch];
Kind.__empty_constructs__ = [Kind.Message, Kind.Flag, Kind.SubDispatch];

// bin/haxe/ValueException.js
var $global2 = Register.$global;
var ValueException = Register.global("$hxClasses")["haxe.ValueException"] = class ValueException2 extends Register.inherits(() => Exception, true) {
  new(value, previous, $native) {
    super.new(String(value), previous, $native);
    this.value = value;
  }
  /**
  Extract an originally thrown value.
  
  This method must return the same value on subsequent calls.
  Used internally for catching non-native exceptions.
  Do _not_ override unless you know what you are doing.
  */
  unwrap() {
    return this.value;
  }
  static get __name__() {
    return "haxe.ValueException";
  }
  static get __super__() {
    return Exception;
  }
  get __class__() {
    return ValueException2;
  }
};

// bin/haxe/Exception.js
var $global3 = Register.$global;
var Exception = Register.global("$hxClasses")["haxe.Exception"] = class Exception2 extends Register.inherits(() => Error, true) {
  new(message, previous, $native) {
    Error.call(this, message);
    this.message = message;
    this.__previousException = previous;
    this.__nativeException = $native != null ? $native : this;
  }
  unwrap() {
    return this.__nativeException;
  }
  /**
  Returns exception message.
  */
  toString() {
    return this.get_message();
  }
  get_message() {
    return this.message;
  }
  get_native() {
    return this.__nativeException;
  }
  static caught(value) {
    if (value instanceof Exception2) {
      return value;
    } else if (value instanceof Error) {
      return new Exception2(value.message, null, value);
    } else {
      return new ValueException(value, null, value);
    }
    ;
  }
  static thrown(value) {
    if (value instanceof Exception2) {
      return value.get_native();
    } else if (value instanceof Error) {
      return value;
    } else {
      let e = new ValueException(value);
      return e;
    }
    ;
  }
  static get __name__() {
    return "haxe.Exception";
  }
  static get __super__() {
    return Error;
  }
  get __class__() {
    return Exception2;
  }
};

// bin/HxOverrides.js
var $global4 = Register.$global;
var HxOverrides = Register.global("$hxClasses")["HxOverrides"] = class HxOverrides2 {
  static dateStr(date) {
    let m = date.getMonth() + 1;
    let d = date.getDate();
    let h = date.getHours();
    let mi = date.getMinutes();
    let s = date.getSeconds();
    return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
  }
  static strDate(s) {
    switch (s.length) {
      case 8:
        let k = s.split(":");
        let d = /* @__PURE__ */ new Date();
        d["setTime"](0);
        d["setUTCHours"](k[0]);
        d["setUTCMinutes"](k[1]);
        d["setUTCSeconds"](k[2]);
        return d;
        break;
      case 10:
        let k1 = s.split("-");
        return new Date(k1[0], k1[1] - 1, k1[2], 0, 0, 0);
        break;
      case 19:
        let k2 = s.split(" ");
        let y = k2[0].split("-");
        let t = k2[1].split(":");
        return new Date(y[0], y[1] - 1, y[2], t[0], t[1], t[2]);
        break;
      default:
        throw Exception.thrown("Invalid date format : " + s);
    }
    ;
  }
  static cca(s, index) {
    let x = s.charCodeAt(index);
    if (x != x) {
      return void 0;
    }
    ;
    return x;
  }
  static substr(s, pos, len) {
    if (len == null) {
      len = s.length;
    } else if (len < 0) {
      if (pos == 0) {
        len = s.length + len;
      } else {
        return "";
      }
      ;
    }
    ;
    return s.substr(pos, len);
  }
  static now() {
    return Date.now();
  }
  static get __name__() {
    return "HxOverrides";
  }
  get __class__() {
    return HxOverrides2;
  }
};
(typeof performance != "undefined" ? typeof performance.now == "function" : false) ? HxOverrides.now = performance.now.bind(performance) : null;

// bin/mcli/internal/Tools.js
var $global5 = Register.$global;
var Tools = Register.global("$hxClasses")["mcli.internal.Tools"] = class Tools2 {
  static toDashSep(s) {
    if (s.length <= 1) {
      return s;
    }
    ;
    let buf_b = "";
    let first = true;
    let _g = 0;
    let _g1 = s.length;
    while (_g < _g1) {
      let i = _g++;
      let chr = HxOverrides.cca(s, i);
      if (chr >= 65 && chr <= 90) {
        if (!first) {
          buf_b += String.fromCodePoint(45);
        }
        ;
        buf_b += String.fromCodePoint(chr - -32);
        first = true;
      } else {
        buf_b += String.fromCodePoint(chr);
        first = false;
      }
      ;
    }
    ;
    return buf_b;
  }
  static get __name__() {
    return "mcli.internal.Tools";
  }
  get __class__() {
    return Tools2;
  }
};

// bin/mcli/DispatchError.js
var $global6 = Register.$global;
var DispatchError = Register.global("$hxEnums")["mcli.DispatchError"] = {
  __ename__: "mcli.DispatchError",
  UnknownArgument: Object.assign((arg) => ({ _hx_index: 0, __enum__: "mcli.DispatchError", "arg": arg }), { _hx_name: "UnknownArgument", __params__: ["arg"] }),
  ArgumentFormatError: Object.assign((type, passed) => ({ _hx_index: 1, __enum__: "mcli.DispatchError", "type": type, "passed": passed }), { _hx_name: "ArgumentFormatError", __params__: ["type", "passed"] }),
  DecoderNotFound: Object.assign((type) => ({ _hx_index: 2, __enum__: "mcli.DispatchError", "type": type }), { _hx_name: "DecoderNotFound", __params__: ["type"] }),
  MissingOptionArgument: Object.assign((opt, name) => ({ _hx_index: 3, __enum__: "mcli.DispatchError", "opt": opt, "name": name }), { _hx_name: "MissingOptionArgument", __params__: ["opt", "name"] }),
  MissingArgument: { _hx_name: "MissingArgument", _hx_index: 4, __enum__: "mcli.DispatchError" },
  TooManyArguments: { _hx_name: "TooManyArguments", _hx_index: 5, __enum__: "mcli.DispatchError" }
};
DispatchError.__constructs__ = [DispatchError.UnknownArgument, DispatchError.ArgumentFormatError, DispatchError.DecoderNotFound, DispatchError.MissingOptionArgument, DispatchError.MissingArgument, DispatchError.TooManyArguments];
DispatchError.__empty_constructs__ = [DispatchError.MissingArgument, DispatchError.TooManyArguments];

// bin/Std.js
var $global7 = Register.$global;
var Std = Register.global("$hxClasses")["Std"] = class Std2 {
  /**
  Converts any value to a String.
  
  If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.
  
  If `s` is an instance of a class and that class or one of its parent classes has
  a `toString` method, that method is called. If no such method is present, the result
  is unspecified.
  
  If `s` is an enum constructor without argument, the constructor's name is returned. If
  arguments exists, the constructor's name followed by the String representations of
  the arguments is returned.
  
  If `s` is a structure, the field names along with their values are returned. The field order
  and the operator separating field names and values are unspecified.
  
  If s is null, "null" is returned.
  */
  static string(s) {
    return Boot.__string_rec(s, "");
  }
  /**
  Converts a `String` to an `Int`.
  
  Leading whitespaces are ignored.
  
  `x` may optionally start with a + or - to denote a postive or negative value respectively.
  
  If the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following
  digits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.
  
  Otherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary
  notations are not supported.
  
  Parsing continues until an invalid character is detected, in which case the result up to
  that point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.
  
  If `x` is `null`, the result is `null`.
  If `x` cannot be parsed as integer or is empty, the result is `null`.
  
  If `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal
  digit, the result is unspecified.
  */
  static parseInt(x) {
    let v = parseInt(x);
    if (isNaN(v)) {
      return null;
    }
    ;
    return v;
  }
  static get __name__() {
    return "Std";
  }
  get __class__() {
    return Std2;
  }
};
{
  Object.defineProperty(String.prototype, "__class__", { "value": Register.global("$hxClasses")["String"] = String, "enumerable": false, "writable": true });
  String.__name__ = true;
  Register.global("$hxClasses")["Array"] = Array;
  Array.__name__ = true;
  Date.prototype.__class__ = Register.global("$hxClasses")["Date"] = Date;
  Date.__name__ = "Date";
  Int = {};
  ;
  Dynamic = {};
  ;
  Float = Number;
  Bool = Boolean;
  Class = {};
  ;
  Enum = {};
  ;
}
var Int;
var Dynamic;
var Float;
var Bool;
var Class;
var Enum;

// bin/js/Boot.js
var $global8 = Register.$global;
var Boot = Register.global("$hxClasses")["js.Boot"] = class Boot2 {
  static getClass(o) {
    if (o == null) {
      return null;
    } else if (o instanceof Array) {
      return Array;
    } else {
      let cl = o.__class__;
      if (cl != null) {
        return cl;
      }
      ;
      let name = Boot2.__nativeClassName(o);
      if (name != null) {
        return Boot2.__resolveNativeClass(name);
      }
      ;
      return null;
    }
    ;
  }
  static __string_rec(o, s) {
    if (o == null) {
      return "null";
    }
    ;
    if (s.length >= 5) {
      return "<...>";
    }
    ;
    let t = typeof o;
    if (t == "function" && (o.__name__ || o.__ename__)) {
      t = "object";
    }
    ;
    switch (t) {
      case "function":
        return "<function>";
        break;
      case "object":
        if (o.__enum__) {
          let e = Register.global("$hxEnums")[o.__enum__];
          let con = e.__constructs__[o._hx_index];
          let n = con._hx_name;
          if (con.__params__) {
            s = s + "	";
            return n + "(" + function($this) {
              var $r0;
              let _g = [];
              {
                let _g1 = 0;
                let _g2 = con.__params__;
                while (true) {
                  if (!(_g1 < _g2.length)) {
                    break;
                  }
                  ;
                  let p = _g2[_g1];
                  _g1 = _g1 + 1;
                  _g.push(Boot2.__string_rec(o[p], s));
                }
                ;
              }
              ;
              $r0 = _g;
              return $r0;
            }(this).join(",") + ")";
          } else {
            return n;
          }
          ;
        }
        ;
        if (o instanceof Array) {
          let str2 = "[";
          s += "	";
          let _g = 0;
          let _g1 = o.length;
          while (_g < _g1) {
            let i = _g++;
            str2 += (i > 0 ? "," : "") + Boot2.__string_rec(o[i], s);
          }
          ;
          str2 += "]";
          return str2;
        }
        ;
        let tostr;
        try {
          tostr = o.toString;
        } catch (_g) {
          return "???";
        }
        ;
        if (tostr != null && tostr != Object.toString && typeof tostr == "function") {
          let s2 = o.toString();
          if (s2 != "[object Object]") {
            return s2;
          }
          ;
        }
        ;
        let str = "{\n";
        s += "	";
        let hasp = o.hasOwnProperty != null;
        let k = null;
        for (k in o) {
          ;
          if (hasp && !o.hasOwnProperty(k)) {
            continue;
          }
          ;
          if (k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
            continue;
          }
          ;
          if (str.length != 2) {
            str += ", \n";
          }
          ;
          str += s + k + " : " + Boot2.__string_rec(o[k], s);
        }
        ;
        s = s.substring(1);
        str += "\n" + s + "}";
        return str;
        break;
      case "string":
        return o;
        break;
      default:
        return String(o);
    }
    ;
  }
  static __interfLoop(cc, cl) {
    if (cc == null) {
      return false;
    }
    ;
    if (cc == cl) {
      return true;
    }
    ;
    let intf = cc.__interfaces__;
    if (intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
      let _g = 0;
      let _g1 = intf.length;
      while (_g < _g1) {
        let i = _g++;
        let i1 = intf[i];
        if (i1 == cl || Boot2.__interfLoop(i1, cl)) {
          return true;
        }
        ;
      }
      ;
    }
    ;
    return Boot2.__interfLoop(cc.__super__, cl);
  }
  static __instanceof(o, cl) {
    if (cl == null) {
      return false;
    }
    ;
    switch (cl) {
      case Array:
        return o instanceof Array;
        break;
      case "$hxCoreType__Bool":
        return typeof o == "boolean";
        break;
      case "$hxCoreType__Dynamic":
        return o != null;
        break;
      case "$hxCoreType__Float":
        return typeof o == "number";
        break;
      case "$hxCoreType__Int":
        if (typeof o == "number") {
          return (o | 0) === o;
        } else {
          return false;
        }
        ;
        break;
      case String:
        return typeof o == "string";
        break;
      default:
        if (o != null) {
          if (typeof cl == "function") {
            if (Boot2.__downcastCheck(o, cl)) {
              return true;
            }
            ;
          } else if (typeof cl == "object" && Boot2.__isNativeObj(cl)) {
            if (o instanceof cl) {
              return true;
            }
            ;
          }
          ;
        } else {
          return false;
        }
        ;
        if (cl == "$hxCoreType__Class" ? o.__name__ != null : false) {
          return true;
        }
        ;
        if (cl == "$hxCoreType__Enum" ? o.__ename__ != null : false) {
          return true;
        }
        ;
        return o.__enum__ != null ? Register.global("$hxEnums")[o.__enum__] == cl : false;
    }
    ;
  }
  static __downcastCheck(o, cl) {
    if (!(o instanceof cl)) {
      if (cl.__isInterface__) {
        return Boot2.__interfLoop(Boot2.getClass(o), cl);
      } else {
        return false;
      }
      ;
    } else {
      return true;
    }
    ;
  }
  static __cast(o, t) {
    if (o == null || Boot2.__instanceof(o, t)) {
      return o;
    } else {
      throw Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
    }
    ;
  }
  static __nativeClassName(o) {
    let name = Boot2.__toStr.call(o).slice(8, -1);
    if (name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
      return null;
    }
    ;
    return name;
  }
  static __isNativeObj(o) {
    return Boot2.__nativeClassName(o) != null;
  }
  static __resolveNativeClass(name) {
    return Register.$global[name];
  }
  static get __name__() {
    return "js.Boot";
  }
  get __class__() {
    return Boot2;
  }
};
Boot.__toStr = {}.toString;

// bin/haxe/Log.js
var $global9 = Register.$global;
var Log = Register.global("$hxClasses")["haxe.Log"] = class Log2 {
  /**
  Format the output of `trace` before printing it.
  */
  static formatOutput(v, infos) {
    let str = Std.string(v);
    if (infos == null) {
      return str;
    }
    ;
    let pstr = infos.fileName + ":" + infos.lineNumber;
    if (infos.customParams != null) {
      let _g = 0;
      let _g1 = infos.customParams;
      while (_g < _g1.length) {
        let v2 = _g1[_g];
        ++_g;
        str += ", " + Std.string(v2);
      }
      ;
    }
    ;
    return pstr + ": " + str;
  }
  /**
  Outputs `v` in a platform-dependent way.
  
  The second parameter `infos` is injected by the compiler and contains
  information about the position where the `trace()` call was made.
  
  This method can be rebound to a custom function:
  
  var oldTrace = haxe.Log.trace; // store old function
  haxe.Log.trace = function(v, ?infos) {
  // handle trace
  }
  ...
  haxe.Log.trace = oldTrace;
  
  If it is bound to null, subsequent calls to `trace()` will cause an
  exception.
  */
  static trace(v, infos) {
    let str = Log2.formatOutput(v, infos);
    if (typeof console != "undefined" && console.log != null) {
      console.log(str);
    }
    ;
  }
  static get __name__() {
    return "haxe.Log";
  }
  get __class__() {
    return Log2;
  }
};

// bin/StringTools.js
var $global10 = Register.$global;
var StringTools = Register.global("$hxClasses")["StringTools"] = class StringTools2 {
  /**
  Tells if the character in the string `s` at position `pos` is a space.
  
  A character is considered to be a space character if its character code
  is 9,10,11,12,13 or 32.
  
  If `s` is the empty String `""`, or if pos is not a valid position within
  `s`, the result is false.
  */
  static isSpace(s, pos) {
    let c = HxOverrides.cca(s, pos);
    if (!(c > 8 && c < 14)) {
      return c == 32;
    } else {
      return true;
    }
    ;
  }
  /**
  Removes leading space characters of `s`.
  
  This function internally calls `isSpace()` to decide which characters to
  remove.
  
  If `s` is the empty String `""` or consists only of space characters, the
  result is the empty String `""`.
  */
  static ltrim(s) {
    let l = s.length;
    let r = 0;
    while (r < l && StringTools2.isSpace(s, r))
      ++r;
    if (r > 0) {
      return HxOverrides.substr(s, r, l - r);
    } else {
      return s;
    }
    ;
  }
  /**
  Removes trailing space characters of `s`.
  
  This function internally calls `isSpace()` to decide which characters to
  remove.
  
  If `s` is the empty String `""` or consists only of space characters, the
  result is the empty String `""`.
  */
  static rtrim(s) {
    let l = s.length;
    let r = 0;
    while (r < l && StringTools2.isSpace(s, l - r - 1))
      ++r;
    if (r > 0) {
      return HxOverrides.substr(s, 0, l - r);
    } else {
      return s;
    }
    ;
  }
  /**
  Removes leading and trailing space characters of `s`.
  
  This is a convenience function for `ltrim(rtrim(s))`.
  */
  static trim(s) {
    return StringTools2.ltrim(StringTools2.rtrim(s));
  }
  /**
  Appends `c` to `s` until `s.length` is at least `l`.
  
  If `c` is the empty String `""` or if `l` does not exceed `s.length`,
  `s` is returned unchanged.
  
  If `c.length` is 1, the resulting String length is exactly `l`.
  
  Otherwise the length may exceed `l`.
  
  If `c` is null, the result is unspecified.
  */
  static rpad(s, c, l) {
    if (c.length <= 0) {
      return s;
    }
    ;
    let buf_b = "";
    buf_b += s == null ? "null" : "" + s;
    while (buf_b.length < l)
      buf_b += c == null ? "null" : "" + c;
    return buf_b;
  }
  /**
  Encodes `n` into a hexadecimal representation.
  
  If `digits` is specified, the resulting String is padded with "0" until
  its `length` equals `digits`.
  */
  static hex(n, digits) {
    let s = "";
    let hexChars = "0123456789ABCDEF";
    do {
      s = hexChars.charAt(n & 15) + s;
      n >>>= 4;
    } while (n > 0);
    if (digits != null) {
      while (s.length < digits)
        s = "0" + s;
    }
    ;
    return s;
  }
  static get __name__() {
    return "StringTools";
  }
  get __class__() {
    return StringTools2;
  }
};

// bin/StringBuf.js
var $global11 = Register.$global;
var StringBuf = Register.global("$hxClasses")["StringBuf"] = class StringBuf2 extends Register.inherits() {
  new() {
    this.b = "";
  }
  static get __name__() {
    return "StringBuf";
  }
  get __class__() {
    return StringBuf2;
  }
};

// bin/Reflect.js
var $global12 = Register.$global;
var Reflect2 = Register.global("$hxClasses")["Reflect"] = class Reflect3 {
  /**
  Returns the value of the field named `field` on object `o`.
  
  If `o` is not an object or has no field named `field`, the result is
  null.
  
  If the field is defined as a property, its accessors are ignored. Refer
  to `Reflect.getProperty` for a function supporting property accessors.
  
  If `field` is null, the result is unspecified.
  */
  static field(o, field) {
    try {
      return o[field];
    } catch (_g) {
      return null;
    }
    ;
  }
  /**
  Returns the value of the field named `field` on object `o`, taking
  property getter functions into account.
  
  If the field is not a property, this function behaves like
  `Reflect.field`, but might be slower.
  
  If `o` or `field` are null, the result is unspecified.
  */
  static getProperty(o, field) {
    let tmp;
    if (o == null) {
      return null;
    } else {
      let tmp1;
      if (o.__properties__) {
        tmp = o.__properties__["get_" + field];
        tmp1 = tmp;
      } else {
        tmp1 = false;
      }
      ;
      if (tmp1) {
        return o[tmp]();
      } else {
        return o[field];
      }
      ;
    }
    ;
  }
  /**
  Sets the field named `field` of object `o` to value `value`, taking
  property setter functions into account.
  
  If the field is not a property, this function behaves like
  `Reflect.setField`, but might be slower.
  
  If `field` is null, the result is unspecified.
  */
  static setProperty(o, field, value) {
    let tmp;
    let tmp1;
    if (o.__properties__) {
      tmp = o.__properties__["set_" + field];
      tmp1 = tmp;
    } else {
      tmp1 = false;
    }
    ;
    if (tmp1) {
      o[tmp](value);
    } else {
      o[field] = value;
    }
    ;
  }
  /**
  Returns the fields of structure `o`.
  
  This method is only guaranteed to work on anonymous structures. Refer to
  `Type.getInstanceFields` for a function supporting class instances.
  
  If `o` is null, the result is unspecified.
  */
  static fields(o) {
    let a = [];
    if (o != null) {
      let hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var f in o) {
        ;
        if (f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o, f)) {
          a.push(f);
        }
        ;
      }
      ;
    }
    ;
    return a;
  }
  /**
  Returns true if `f` is a function, false otherwise.
  
  If `f` is null, the result is false.
  */
  static isFunction(f) {
    if (typeof f == "function") {
      return !(f.__name__ || f.__ename__);
    } else {
      return false;
    }
    ;
  }
  /**
  Compares `a` and `b`.
  
  If `a` is less than `b`, the result is negative. If `b` is less than
  `a`, the result is positive. If `a` and `b` are equal, the result is 0.
  
  This function is only defined if `a` and `b` are of the same type.
  
  If that type is a function, the result is unspecified and
  `Reflect.compareMethods` should be used instead.
  
  For all other types, the result is 0 if `a` and `b` are equal. If they
  are not equal, the result depends on the type and is negative if:
  
  - Numeric types: a is less than b
  - String: a is lexicographically less than b
  - Other: unspecified
  
  If `a` and `b` are null, the result is 0. If only one of them is null,
  the result is unspecified.
  */
  static compare(a, b) {
    if (a == b) {
      return 0;
    } else if (a > b) {
      return 1;
    } else {
      return -1;
    }
    ;
  }
  /**
  Tells if `v` is an object.
  
  The result is true if `v` is one of the following:
  
  - class instance
  - structure
  - `Class<T>`
  - `Enum<T>`
  
  Otherwise, including if `v` is null, the result is false.
  */
  static isObject(v) {
    if (v == null) {
      return false;
    }
    ;
    let t = typeof v;
    if (!(t == "string" || t == "object" && v.__enum__ == null)) {
      if (t == "function") {
        return (v.__name__ || v.__ename__) != null;
      } else {
        return false;
      }
      ;
    } else {
      return true;
    }
    ;
  }
  static get __name__() {
    return "Reflect";
  }
  get __class__() {
    return Reflect3;
  }
};

// bin/Lambda.js
var $global13 = Register.$global;
var Lambda = Register.global("$hxClasses")["Lambda"] = class Lambda2 {
  /**
  Tells if `it` contains an element for which `f` is true.
  
  This function returns true as soon as an element is found for which a
  call to `f` returns true.
  
  If no such element is found, the result is false.
  
  If `f` is null, the result is unspecified.
  */
  static exists(it, f) {
    let x = Register.getIterator(it);
    while (x.hasNext()) {
      let x1 = x.next();
      if (f(x1)) {
        return true;
      }
      ;
    }
    ;
    return false;
  }
  static get __name__() {
    return "Lambda";
  }
  get __class__() {
    return Lambda2;
  }
};

// bin/mcli/Dispatch.js
var $global14 = Register.$global;
var Dispatch = Register.global("$hxClasses")["mcli.Dispatch"] = class Dispatch2 extends Register.inherits() {
  new(args) {
    this.args = args.slice();
    this.args.reverse();
    this.depth = 0;
  }
  errln(s) {
    Log.trace(s, null);
  }
  println(s) {
    Log.trace(s, null);
  }
  dispatch(v, handleExceptions) {
    if (handleExceptions == null) {
      handleExceptions = true;
    }
    ;
    this.depth++;
    try {
      this._dispatch(v, handleExceptions);
      this.depth--;
    } catch (_g) {
      let e = Exception.caught(_g).unwrap();
      this.depth--;
      throw Exception.thrown(e);
    }
    ;
  }
  _dispatch(v, handleExceptions) {
    if (handleExceptions) {
      try {
        this._dispatch(v, false);
      } catch (_g3) {
        let _g12 = Exception.caught(_g3).unwrap();
        if (Boot.__instanceof(_g12, DispatchError)) {
          let e = _g12;
          switch (e._hx_index) {
            case 0:
              let a = e.arg;
              this.errln("ERROR: Unknown argument: " + a);
              break;
            case 1:
              let t = e.type;
              let p = e.passed;
              this.errln("ERROR: Unrecognized format for " + t + ". Passed " + p);
              break;
            case 2:
              let t1 = e.type;
              this.errln("[mcli error] No Decoder found for type " + t1);
              break;
            case 3:
              let _g4 = e.opt;
              let _g22 = e.name;
              let opt = _g4;
              let name = _g22;
              if (opt == "--run-default") {
                this.errln("ERROR: The argument " + name + " is required");
              } else {
                let opt2 = _g4;
                let name2 = _g22;
                name2 = name2 != null ? " (" + name2 + ")" : "";
                this.errln("ERROR: The option " + opt2 + " requires an argument " + name2 + ", but no argument was passed");
              }
              ;
              break;
            case 4:
              this.errln("ERROR: Missing arguments");
              break;
            case 5:
              this.errln("ERROR: Too many arguments");
              break;
          }
          ;
          this.println(v.showUsage());
        } else {
          throw _g3;
        }
        ;
      }
      ;
      return;
    }
    ;
    let defs = v.getArguments();
    let names_inst = /* @__PURE__ */ new Map();
    let _g = 0;
    while (_g < defs.length) {
      let arg = defs[_g];
      ++_g;
      let _g12 = 0;
      let _g22 = Dispatch2.getAliases(arg);
      while (_g12 < _g22.length) {
        let a = _g22[_g12];
        ++_g12;
        names_inst.set(a, arg);
      }
      ;
    }
    ;
    let didCall = false;
    let defaultRan = false;
    let delays = [];
    let _gthis = this;
    let runArgument = function(arg, argDef2) {
      let _g3 = argDef2.kind;
      switch (_g3._hx_index) {
        case 0:
          throw Exception.thrown(DispatchError.UnknownArgument(arg));
          break;
        case 1:
          Reflect2.setProperty(v, argDef2.name, true);
          break;
        case 2:
          let key = _g3.key;
          let val = _g3.value;
          let arr = _g3.valueIsArray;
          let map = Reflect2.getProperty(v, argDef2.name);
          let n = _gthis.args.pop();
          let toAdd = [];
          while (n != null && Dispatch2.isArgument(n)) {
            toAdd.push(n);
            n = _gthis.args.pop();
          }
          ;
          if (n == null) {
            throw Exception.thrown(DispatchError.MissingOptionArgument(arg, key.name));
          }
          ;
          let kv = n.split("=");
          let k = Dispatch2.decode(kv[0], key.t);
          let v1 = null;
          if (kv[1] != null) {
            v1 = Dispatch2.decode(kv[1], val.t);
          }
          ;
          let oldv = map.get(k);
          if (oldv != null) {
            if (arr) {
              oldv.push(v1);
            }
            ;
          } else if (arr) {
            map.set(k, [v1]);
          } else {
            map.set(k, v1);
          }
          ;
          if (toAdd.length > 0) {
            toAdd.reverse();
            _gthis.args = _gthis.args.concat(toAdd);
          }
          ;
          break;
        case 3:
          let t = _g3.t;
          let n1 = _gthis.args.pop();
          let toAdd1 = [];
          while (n1 != null && Dispatch2.isArgument(n1)) {
            toAdd1.push(n1);
            n1 = _gthis.args.pop();
          }
          ;
          if (n1 == null) {
            throw Exception.thrown(DispatchError.MissingOptionArgument(arg));
          }
          ;
          let val1 = Dispatch2.decode(n1, t);
          Reflect2.setProperty(v, argDef2.name, val1);
          if (toAdd1.length > 0) {
            toAdd1.reverse();
            _gthis.args = _gthis.args.concat(toAdd1);
          }
          ;
          break;
        case 4:
          let fargs = _g3.args;
          let varArg = _g3.varArgs;
          didCall = true;
          let applied = [];
          let toAdd2 = [];
          let origArg = arg;
          let _g12 = 0;
          while (_g12 < fargs.length) {
            let fa = fargs[_g12];
            ++_g12;
            arg = _gthis.args.pop();
            while (arg != null && Dispatch2.isArgument(arg)) {
              toAdd2.push(arg);
              arg = _gthis.args.pop();
            }
            ;
            if (arg == null && !fa.opt) {
              throw Exception.thrown(DispatchError.MissingOptionArgument(origArg, fa.name));
            }
            ;
            applied.push(Dispatch2.decode(arg, fa.t));
          }
          ;
          if (varArg != null) {
            let va = [];
            while (_gthis.args.length > 0) {
              let arg2 = _gthis.args.pop();
              if (Dispatch2.isArgument(arg2)) {
                _gthis.args.push(arg2);
                break;
              } else {
                va.push(Dispatch2.decode(arg2, varArg));
              }
              ;
            }
            ;
            applied.push(va);
          }
          ;
          delays.push(function() {
            Reflect2.field(v, argDef2.name).apply(v, applied);
          });
          if (toAdd2.length != 0) {
            toAdd2.reverse();
            _gthis.args = _gthis.args.concat(toAdd2);
          }
          ;
          break;
        case 5:
          didCall = true;
          let _g22 = 0;
          while (_g22 < delays.length) {
            let d = delays[_g22];
            ++_g22;
            d();
          }
          ;
          delays = [];
          Reflect2.field(v, argDef2.name).apply(v, [_gthis]);
          break;
      }
      ;
    };
    let getDefaultAlias = function() {
      if (names_inst.has("--run-default")) {
        return "--run-default";
      } else if (names_inst.has("run-default")) {
        return "run-default";
      } else {
        return "";
      }
      ;
    };
    while (this.args.length > 0) {
      let arg = this.args.pop();
      let argDef2 = names_inst.get(arg);
      if (argDef2 == null) {
        if (!Dispatch2.isArgument(arg)) {
          if (!defaultRan && !v._preventDefault) {
            let key = getDefaultAlias();
            argDef2 = names_inst.get(key);
            if (argDef2 != null) {
              defaultRan = true;
            }
            ;
            this.args.push(arg);
          }
          ;
        } else if (arg.length > 2 && HxOverrides.cca(arg, 1) != 45) {
          let _this = HxOverrides.substr(arg, 1, null).split("");
          let result = new Array(_this.length);
          let _g3 = 0;
          let _g12 = _this.length;
          while (_g3 < _g12) {
            let i = _g3++;
            result[i] = "-" + _this[i];
          }
          ;
          let a = result;
          a.reverse();
          this.args = this.args.concat(a);
          continue;
        }
        ;
      }
      ;
      if (argDef2 == null) {
        if (arg != null) {
          if (didCall == false && !v._preventDefault || this.depth == 1) {
            throw Exception.thrown(DispatchError.UnknownArgument(arg));
          } else {
            this.args.push(arg);
            break;
          }
          ;
        } else {
          throw Exception.thrown(DispatchError.MissingArgument);
        }
        ;
      }
      ;
      runArgument(arg, argDef2);
    }
    ;
    let defaultAlias = getDefaultAlias();
    let argDef = names_inst.get(defaultAlias);
    let _g1 = 0;
    while (_g1 < delays.length) {
      let d = delays[_g1];
      ++_g1;
      d();
    }
    ;
    delays = [];
    if (argDef == null) {
      if (!didCall) {
        throw Exception.thrown(DispatchError.MissingArgument);
      }
      ;
    } else if (!didCall && !v._preventDefault) {
      runArgument(defaultAlias, argDef);
    } else if (!defaultRan && !v._preventDefault) {
      let _g3 = argDef.kind;
      if (_g3._hx_index == 4) {
        let _g12 = _g3.varArgs;
        let args = _g3.args;
        if (!Lambda.exists(args, function(a) {
          return !a.opt;
        })) {
          runArgument(defaultAlias, argDef);
        }
        ;
      }
      ;
    }
    ;
    let _g2 = 0;
    while (_g2 < delays.length) {
      let d = delays[_g2];
      ++_g2;
      d();
    }
    ;
  }
  /**
  Formats an argument definition to String.
  [argSize] maximum argument string length
  [screenSize] maxium characters until a line break should be forced
  */
  static argToString(arg, argSize, screenSize) {
    if (argSize == null) {
      argSize = 30;
    }
    ;
    if (screenSize == null) {
      screenSize = Dispatch2.getScreenSize();
    }
    ;
    let postfix = Dispatch2.getPostfix(arg);
    let versions = Dispatch2.getAliases(arg);
    if (versions.length == 0) {
      if (arg.description != null) {
        return arg.description;
      } else {
        return "";
      }
      ;
    }
    ;
    versions.sort(function(s1, s2) {
      return Reflect2.compare(s1.length, s2.length);
    });
    let desc = arg.description != null ? arg.description : "";
    let ret = new StringBuf();
    ret.b += "  ";
    let result = new Array(versions.length);
    let _g = 0;
    let _g1 = versions.length;
    while (_g < _g1) {
      let i = _g++;
      result[i] = versions[i];
    }
    ;
    let argsTxt = StringTools.rpad(result.join(", ") + postfix, " ", argSize);
    ret.b += argsTxt == null ? "null" : "" + argsTxt;
    if (argsTxt.length > argSize) {
      ret.b += "\n";
      let _g2 = 0;
      let _g12 = argSize;
      while (_g2 < _g12) {
        let i = _g2++;
        ret.b += " ";
      }
      ;
    }
    ;
    ret.b += "   ";
    if (arg.description != null) {
      ret.b += Std.string(arg.description);
    }
    ;
    let consolidated = ret.b;
    let inNewline = false;
    if (consolidated.length > screenSize) {
      ret = new StringBuf();
      let c = consolidated.split(" ");
      let ccount = 0;
      let _g2 = 0;
      while (_g2 < c.length) {
        let word = c[_g2];
        ++_g2;
        if (inNewline && word == "") {
          continue;
        } else {
          inNewline = false;
        }
        ;
        ccount += word.length + 1;
        if (ccount >= screenSize) {
          ret.b += String.fromCodePoint(10);
          let _g3 = 0;
          let _g12 = argSize + 7;
          while (_g3 < _g12) {
            let i = _g3++;
            ret.b += " ";
          }
          ;
          ccount = word.length + 1 + argSize + 8;
          inNewline = true;
          if (word == "") {
            continue;
          }
          ;
        }
        ;
        ret.b += word == null ? "null" : "" + word;
        ret.b += " ";
      }
      ;
      return ret.b;
    } else {
      return consolidated;
    }
    ;
  }
  /**
  With an argument definition array, it formats to show the standard usage help screen
  [screenSize] maximum number of characters before a line break is forced
  */
  static showUsageOf(args, screenSize) {
    if (screenSize == null) {
      screenSize = Dispatch2.getScreenSize();
    }
    ;
    let maxSize = 0;
    let _g = 0;
    while (_g < args.length) {
      let arg = args[_g];
      ++_g;
      if (arg.name == "runDefault") {
        continue;
      }
      ;
      let postfixSize = Dispatch2.getPostfix(arg).length;
      let size = arg.command.length + postfixSize + 3;
      if (arg.aliases != null) {
        let _g2 = 0;
        let _g12 = arg.aliases;
        while (_g2 < _g12.length) {
          let a = _g12[_g2];
          ++_g2;
          size += a.length + 3;
        }
        ;
      }
      ;
      if (size > maxSize) {
        maxSize = size;
      }
      ;
    }
    ;
    if (maxSize > screenSize / 2.5) {
      maxSize = screenSize / 2.5 | 0;
    }
    ;
    let buf_b = "";
    let _g1 = 0;
    while (_g1 < args.length) {
      let arg = args[_g1];
      ++_g1;
      if (arg.name == "runDefault") {
        continue;
      }
      ;
      let str = Dispatch2.argToString(arg, maxSize, screenSize);
      if (str.length > 0) {
        buf_b += str == null ? "null" : "" + str;
        buf_b += String.fromCodePoint(10);
      }
      ;
    }
    ;
    return buf_b;
  }
  static getScreenSize(defaultSize) {
    if (defaultSize == null) {
      defaultSize = 80;
    }
    ;
    return defaultSize;
  }
  static getAliases(arg) {
    let versions = arg.aliases != null ? arg.aliases.concat([arg.command]) : [arg.command];
    let _g = [];
    let _g1 = 0;
    let _g2 = versions;
    while (_g1 < _g2.length) {
      let v = _g2[_g1];
      ++_g1;
      if (v != null && v != "") {
        _g.push(v);
      }
      ;
    }
    ;
    versions = _g;
    let prefix = "-";
    if (arg.kind == Kind.SubDispatch || arg.kind == Kind.Message) {
      prefix = "";
    }
    ;
    let _g3 = [];
    let _g4 = 0;
    while (_g4 < versions.length) {
      let v = versions[_g4];
      ++_g4;
      _g3.push(v.length == 1 ? prefix + Tools.toDashSep(v) : prefix + prefix + Tools.toDashSep(v));
    }
    ;
    return _g3;
  }
  static getPostfix(arg) {
    let _g = arg.kind;
    switch (_g._hx_index) {
      case 2:
        let _g1 = _g.valueIsArray;
        let k = _g.key;
        let v = _g.value;
        return " " + k.name + "[=" + v.name + "]";
        break;
      case 3:
        let _g2 = _g.t;
        return " <" + arg.name + ">";
        break;
      case 4:
        let args = _g.args;
        let vargs = _g.varArgs;
        let postfix = "";
        let _g3 = 0;
        while (_g3 < args.length) {
          let arg2 = args[_g3];
          ++_g3;
          postfix += (arg2.opt ? " [" : " <") + Tools.toDashSep(arg2.name) + (arg2.opt ? "]" : ">");
        }
        ;
        if (vargs != null) {
          postfix += " [arg1 [arg2 ...[argN]]]";
        }
        ;
        return postfix;
        break;
      default:
        return "";
    }
    ;
  }
  static decode(a, type) {
    switch (type) {
      case "Float":
        let ret = parseFloat(a);
        if (isNaN(ret)) {
          throw Exception.thrown(DispatchError.ArgumentFormatError(type, a));
        }
        ;
        return ret;
        break;
      case "Int":
        let ret1 = Std.parseInt(a);
        if (ret1 == null) {
          throw Exception.thrown(DispatchError.ArgumentFormatError(type, a));
        }
        ;
        return ret1;
        break;
      case "String":
        return a;
        break;
      default:
        let d = Dispatch2.decoders != null ? Dispatch2.decoders.inst.get(type) : null;
        if (d == null) {
          let dt = Register.global("$hxClasses")[type];
          if (dt != null && Object.prototype.hasOwnProperty.call(dt, "fromString")) {
            d = dt;
          }
          ;
        }
        ;
        if (d == null) {
          let dt2 = Register.global("$hxClasses")[type + "Decoder"];
          if (dt2 != null && Object.prototype.hasOwnProperty.call(dt2, "fromString")) {
            d = dt2;
          }
          ;
        }
        ;
        if (d == null) {
          let e = Register.global("$hxEnums")[type];
          if (e != null) {
            let all = e.__empty_constructs__.slice();
            let tmp;
            if (all.length > 0) {
              let all1 = all.length;
              let _this = e.__constructs__;
              let result = new Array(_this.length);
              let _g = 0;
              let _g1 = _this.length;
              while (_g < _g1) {
                let i = _g++;
                result[i] = _this[i]._hx_name;
              }
              ;
              tmp = all1 == result.length;
            } else {
              tmp = false;
            }
            ;
            if (tmp) {
              let _g = 0;
              while (_g < all.length) {
                let v = all[_g];
                ++_g;
                if (a == Tools.toDashSep(Std.string(v))) {
                  return v;
                }
                ;
              }
              ;
              throw Exception.thrown(DispatchError.ArgumentFormatError(type, a));
            }
            ;
          }
          ;
        }
        ;
        if (d == null) {
          throw Exception.thrown(DispatchError.DecoderNotFound(type));
        }
        ;
        return d.fromString(a);
    }
    ;
  }
  static isArgument(str) {
    if (HxOverrides.cca(str, 0) == 45) {
      let code = HxOverrides.cca(str, 1);
      if (code >= 48 && code <= 57 || code == 46) {
        return false;
      } else {
        return true;
      }
      ;
    }
    ;
    return false;
  }
  static get __name__() {
    return "mcli.Dispatch";
  }
  get __class__() {
    return Dispatch2;
  }
};

// bin/mcli/CommandLine.js
var $global15 = Register.$global;
var CommandLine = Register.global("$hxClasses")["mcli.CommandLine"] = class CommandLine2 extends Register.inherits() {
  new() {
    this._preventDefault = false;
  }
  /**
  This function will be auto-generated by the build macro
  */
  getArguments() {
    return [];
  }
  /**
  Do not run default (`runDefault`)
  */
  preventDefault() {
    this._preventDefault = true;
  }
  showUsage() {
    return Dispatch.showUsageOf(this.getArguments());
  }
  toString() {
    return this.showUsage();
  }
  static get __name__() {
    return "mcli.CommandLine";
  }
  get __class__() {
    return CommandLine2;
  }
};

// bin/sys/FileSystem.js
var Path = __toESM(require("path"));
var Fs = __toESM(require("fs"));
var $global16 = Register.$global;
var FileSystem = Register.global("$hxClasses")["sys.FileSystem"] = class FileSystem2 {
  /**
  Returns `true` if the file or directory specified by `path` exists.
  */
  static exists(path) {
    try {
      Fs.accessSync(path);
      return true;
    } catch (_g) {
      return false;
    }
    ;
  }
  /**
  Returns `true` if the file or directory specified by `path` is a directory.
  
  If `path` is not a valid file system entry or if its destination is not
  accessible, an exception is thrown.
  */
  static isDirectory(path) {
    try {
      return Fs.statSync(path).isDirectory();
    } catch (_g) {
      return false;
    }
    ;
  }
  /**
  Creates a directory specified by `path`.
  
  This method is recursive: The parent directories don't have to exist.
  
  If the directory cannot be created, an exception is thrown.
  */
  static createDirectory(path) {
    try {
      Fs.mkdirSync(path);
    } catch (_g) {
      let e = Exception.caught(_g).unwrap();
      if (e.code == "ENOENT") {
        FileSystem2.createDirectory(Path.dirname(path));
        Fs.mkdirSync(path);
      } else {
        let stat;
        try {
          stat = Fs.statSync(path);
        } catch (_g2) {
          throw e;
        }
        ;
        if (!stat.isDirectory()) {
          throw e;
        }
        ;
      }
      ;
    }
    ;
  }
  /**
  Deletes the directory specified by `path`. Only empty directories can
  be deleted.
  
  If `path` does not denote a valid directory, or if that directory cannot
  be deleted, an exception is thrown.
  */
  static deleteDirectory(path) {
    if (FileSystem2.exists(path)) {
      let _g = 0;
      let _g1 = Fs.readdirSync(path);
      while (_g < _g1.length) {
        let file = _g1[_g];
        ++_g;
        let curPath = path + "/" + file;
        if (FileSystem2.isDirectory(curPath)) {
          FileSystem2.deleteDirectory(curPath);
        } else {
          Fs.unlinkSync(curPath);
        }
        ;
      }
      ;
      Fs.rmdirSync(path);
    }
    ;
  }
  static get __name__() {
    return "sys.FileSystem";
  }
  get __class__() {
    return FileSystem2;
  }
};

// bin/mcb/venv/Ps1Builder.js
var $global17 = Register.$global;
var Ps1Builder = Register.global("$hxClasses")["mcb.venv.Ps1Builder"] = class Ps1Builder2 {
  static build(name, call, variables) {
    let ps1 = "# Generated by mcb.venv\n";
    let map = variables;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      ps1 += ". { $env:" + k + '="' + v + '" }\n';
    }
    ;
    ps1 += ". " + call + "\n";
    return ps1;
  }
  static get __name__() {
    return "mcb.venv.Ps1Builder";
  }
  get __class__() {
    return Ps1Builder2;
  }
};

// bin/haxe/io/Path.js
var $global18 = Register.$global;
var Path2 = Register.global("$hxClasses")["haxe.io.Path"] = class Path3 extends Register.inherits() {
  new(path) {
    switch (path) {
      case ".":
      case "..":
        this.dir = path;
        this.file = "";
        return;
        break;
    }
    ;
    let c1 = path.lastIndexOf("/");
    let c2 = path.lastIndexOf("\\");
    if (c1 < c2) {
      this.dir = HxOverrides.substr(path, 0, c2);
      path = HxOverrides.substr(path, c2 + 1, null);
      this.backslash = true;
    } else if (c2 < c1) {
      this.dir = HxOverrides.substr(path, 0, c1);
      path = HxOverrides.substr(path, c1 + 1, null);
    } else {
      this.dir = null;
    }
    ;
    let cp = path.lastIndexOf(".");
    if (cp != -1) {
      this.ext = HxOverrides.substr(path, cp + 1, null);
      this.file = HxOverrides.substr(path, 0, cp);
    } else {
      this.ext = null;
      this.file = path;
    }
    ;
  }
  /**
  Returns a String representation of `this` path.
  
  If `this.backslash` is `true`, backslash is used as directory separator,
  otherwise slash is used. This only affects the separator between
  `this.dir` and `this.file`.
  
  If `this.directory` or `this.extension` is `null`, their representation
  is the empty String `""`.
  */
  toString() {
    return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
  }
  /**
  Returns the String representation of `path` without the file extension.
  
  If `path` is `null`, the result is unspecified.
  */
  static withoutExtension(path) {
    let s = new Path3(path);
    s.ext = null;
    return s.toString();
  }
  /**
  Returns the directory of `path`.
  
  If the directory is `null`, the empty String `""` is returned.
  
  If `path` is `null`, the result is unspecified.
  */
  static directory(path) {
    let s = new Path3(path);
    if (s.dir == null) {
      return "";
    }
    ;
    return s.dir;
  }
  /**
  Returns the extension of `path`.
  
  If `path` has no extension, the empty String `""` is returned.
  
  If `path` is `null`, the result is unspecified.
  */
  static extension(path) {
    let s = new Path3(path);
    if (s.ext == null) {
      return "";
    }
    ;
    return s.ext;
  }
  /**
  Joins all paths in `paths` together.
  
  If `paths` is empty, the empty String `""` is returned. Otherwise the
  paths are joined with a slash between them.
  
  If `paths` is `null`, the result is unspecified.
  */
  static join(paths) {
    let _g = [];
    let _g1 = 0;
    let _g2 = paths;
    while (_g1 < _g2.length) {
      let v = _g2[_g1];
      ++_g1;
      if (v != null && v != "") {
        _g.push(v);
      }
      ;
    }
    ;
    let paths1 = _g;
    if (paths1.length == 0) {
      return "";
    }
    ;
    let path = paths1[0];
    let _g3 = 1;
    let _g4 = paths1.length;
    while (_g3 < _g4) {
      let i = _g3++;
      path = Path3.addTrailingSlash(path);
      path += paths1[i];
    }
    ;
    return Path3.normalize(path);
  }
  /**
  Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).
  
  Also replaces backslashes `\` with slashes `/` and afterwards turns
  multiple slashes into a single one.
  
  If `path` is `null`, the result is unspecified.
  */
  static normalize(path) {
    let slash = "/";
    path = path.split("\\").join(slash);
    if (path == slash) {
      return slash;
    }
    ;
    let target = [];
    let _g = 0;
    let _g1 = path.split(slash);
    while (_g < _g1.length) {
      let token = _g1[_g];
      ++_g;
      if (token == ".." && target.length > 0 && target[target.length - 1] != "..") {
        target.pop();
      } else if (token == "") {
        if (target.length > 0 || HxOverrides.cca(path, 0) == 47) {
          target.push(token);
        }
        ;
      } else if (token != ".") {
        target.push(token);
      }
      ;
    }
    ;
    let tmp = target.join(slash);
    let acc_b = "";
    let colon = false;
    let slashes = false;
    let _g_offset = 0;
    let _g_s = tmp;
    while (_g_offset < _g_s.length) {
      let s = _g_s;
      let index = _g_offset++;
      let c = s.charCodeAt(index);
      if (c >= 55296 && c <= 56319) {
        c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
      }
      ;
      let c1 = c;
      if (c1 >= 65536) {
        ++_g_offset;
      }
      ;
      let c2 = c1;
      switch (c2) {
        case 47:
          if (!colon) {
            slashes = true;
          } else {
            let i2 = c2;
            colon = false;
            if (slashes) {
              acc_b += "/";
              slashes = false;
            }
            ;
            acc_b += String.fromCodePoint(i2);
          }
          ;
          break;
        case 58:
          acc_b += ":";
          colon = true;
          break;
        default:
          let i = c2;
          colon = false;
          if (slashes) {
            acc_b += "/";
            slashes = false;
          }
          ;
          acc_b += String.fromCodePoint(i);
      }
      ;
    }
    ;
    return acc_b;
  }
  /**
  Adds a trailing slash to `path`, if it does not have one already.
  
  If the last slash in `path` is a backslash, a backslash is appended to
  `path`.
  
  If the last slash in `path` is a slash, or if no slash is found, a slash
  is appended to `path`. In particular, this applies to the empty String
  `""`.
  
  If `path` is `null`, the result is unspecified.
  */
  static addTrailingSlash(path) {
    if (path.length == 0) {
      return "/";
    }
    ;
    let c1 = path.lastIndexOf("/");
    let c2 = path.lastIndexOf("\\");
    if (c1 < c2) {
      if (c2 != path.length - 1) {
        return path + "\\";
      } else {
        return path;
      }
      ;
    } else if (c1 != path.length - 1) {
      return path + "/";
    } else {
      return path;
    }
    ;
  }
  static get __name__() {
    return "haxe.io.Path";
  }
  get __class__() {
    return Path3;
  }
};

// bin/haxe/Constraints.js
var $global19 = Register.$global;
var IMap = function() {
};
IMap.__isInterface__ = true;

// bin/genes/util/EsMap.js
var $global20 = Register.$global;
var EsMap = Register.global("$hxClasses")["genes.util.EsMap"] = class EsMap2 extends Register.inherits() {
  new() {
    this.inst = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.inst.set(key, value);
  }
  get(key) {
    return this.inst.get(key);
  }
  keys() {
    return EsMap2.adaptIterator(this.inst.keys());
  }
  clear() {
    this.inst.clear();
  }
  static adaptIterator(from) {
    let value;
    let done;
    let queue = function() {
      let data = from.next();
      value = data.value;
      done = data.done;
    };
    return { "hasNext": function() {
      if (done == null) {
        queue();
      }
      ;
      return !done;
    }, "next": function() {
      if (done == null) {
        queue();
      }
      ;
      let pending = value;
      queue();
      return pending;
    } };
  }
  static get __name__() {
    return "genes.util.EsMap";
  }
  get __class__() {
    return EsMap2;
  }
};

// bin/haxe/ds/StringMap.js
var $global21 = Register.$global;
var StringMap = Register.global("$hxClasses")["haxe.ds.StringMap"] = class StringMap2 extends Register.inherits(EsMap) {
  new() {
    super.new();
  }
  static get __name__() {
    return "haxe.ds.StringMap";
  }
  static get __interfaces__() {
    return [IMap];
  }
  static get __super__() {
    return EsMap;
  }
  get __class__() {
    return StringMap2;
  }
};

// bin/mcb/venv/Venv.js
var Fs2 = __toESM(require("fs"));
var ChildProcess = __toESM(require("child_process"));
var $global22 = Register.$global;
var Venv = Register.global("$hxClasses")["mcb.venv.Venv"] = class Venv2 extends Register.inherits(CommandLine) {
  new() {
    super.new();
  }
  static create(name) {
    console.log("src/mcb/venv/Venv.hx:16:", "create " + name);
    let dir = Path2.directory(__filename);
    let venvVersionDir = Path2.join([dir, ".venv", "versions"]);
    FileSystem.createDirectory(venvVersionDir);
    let tempFile = Path2.join([venvVersionDir, ".npmres" + Math.random()]);
    console.log("src/mcb/venv/Venv.hx:21:", "Working...");
    let out = Std.string(ChildProcess.execSync("npm view mc-build versions --json"));
    let versions = JSON.parse(out);
    let cmd = "npm view mc-build versions --json > " + tempFile;
    let args = null;
    if (args == null) {
      ChildProcess.spawnSync(cmd, { "shell": true, "stdio": "inherit" });
    } else {
      ChildProcess.spawnSync(cmd, args, { "stdio": "inherit" });
    }
    ;
    Fs2.unlinkSync(tempFile);
    let shell = process.env["SHELL"];
    console.log("src/mcb/venv/Venv.hx:28:", "Shell: " + shell);
    if (versions.includes(name)) {
      let versionDir = Path2.join([venvVersionDir, name]);
      if (!FileSystem.exists(versionDir)) {
        console.log("src/mcb/venv/Venv.hx:32:", "Installing...");
        FileSystem.createDirectory(versionDir);
        ChildProcess.execSync("npm init -y", { "cwd": versionDir });
        ChildProcess.execSync("npm install mc-build@" + name, { "cwd": versionDir });
      }
      ;
      let path = Path2.join([versionDir, "node_modules", ".bin"]);
      let env2 = { ...process.env, PATH: path, MCBVENVVERSION: name };
      let winScriptPath = Path2.join([Path2.directory(__filename), ".venv", "scripts", "windows.ps1"]);
      let _g = new StringMap();
      _g.inst.set("MCBPATH", path);
      _g.inst.set("MCBVERSION", name);
      let mcbVenvScript = Ps1Builder.build("mcb-venv", winScriptPath, _g);
      FileSystem.createDirectory(Path2.join([Path2.addTrailingSlash(process.cwd()), "venv"]));
      Fs2.writeFileSync(Path2.join([Path2.addTrailingSlash(process.cwd()), "venv", "mcb-venv.ps1"]), mcbVenvScript);
    } else {
      console.log("src/mcb/venv/Venv.hx:48:", "Version not found.");
      console.log("src/mcb/venv/Venv.hx:49:", "Available versions: " + versions.join(", "));
    }
    ;
  }
  static activate() {
  }
  static get __name__() {
    return "mcb.venv.Venv";
  }
  static get __super__() {
    return CommandLine;
  }
  get __class__() {
    return Venv2;
  }
};

// bin/mcl/error/McbError.js
var $global23 = Register.$global;
var McbError = Register.global("$hxClasses")["mcl.error.McbError"] = class McbError2 extends Register.inherits(Exception) {
  new(msg, stack) {
    super.new(msg);
    this.mcbstack = stack;
  }
  __init__() {
  }
  static isMclError(e) {
    return e instanceof McbError2;
  }
  static get __name__() {
    return "mcl.error.McbError";
  }
  static get __super__() {
    return Exception;
  }
  get __class__() {
    return McbError2;
  }
};

// bin/mcl/Tokenizer.js
var $global24 = Register.$global;
var Token = Register.global("$hxEnums")["mcl.Token"] = {
  __ename__: "mcl.Token",
  Literal: Object.assign((v, pos) => ({ _hx_index: 0, __enum__: "mcl.Token", "v": v, "pos": pos }), { _hx_name: "Literal", __params__: ["v", "pos"] }),
  BracketOpen: Object.assign((pos, data) => ({ _hx_index: 1, __enum__: "mcl.Token", "pos": pos, "data": data }), { _hx_name: "BracketOpen", __params__: ["pos", "data"] }),
  BracketClose: Object.assign((pos) => ({ _hx_index: 2, __enum__: "mcl.Token", "pos": pos }), { _hx_name: "BracketClose", __params__: ["pos"] })
};
Token.__constructs__ = [Token.Literal, Token.BracketOpen, Token.BracketClose];
Token.__empty_constructs__ = [];
var Brackets = Register.global("$hxEnums")["mcl.Brackets"] = {
  __ename__: "mcl.Brackets",
  Curly: { _hx_name: "Curly", _hx_index: 0, __enum__: "mcl.Brackets" },
  Square: { _hx_name: "Square", _hx_index: 1, __enum__: "mcl.Brackets" },
  Round: { _hx_name: "Round", _hx_index: 2, __enum__: "mcl.Brackets" }
};
Brackets.__constructs__ = [Brackets.Curly, Brackets.Square, Brackets.Round];
Brackets.__empty_constructs__ = [Brackets.Curly, Brackets.Square, Brackets.Round];
var Tokenizer = Register.global("$hxClasses")["mcl.Tokenizer"] = class Tokenizer2 {
  static tokenize(code, file) {
    let isInMultilineComment = false;
    let indents = [];
    let _g = [];
    let _g1 = 0;
    let _g2 = code.split("\n");
    while (_g1 < _g2.length) {
      let line = _g2[_g1];
      ++_g1;
      let indent = 0;
      while (true) {
        let tmp;
        switch (line.charAt(0)) {
          case "	":
          case " ":
            line = line.substring(1);
            ++indent;
            tmp = true;
            break;
          default:
            tmp = false;
        }
        ;
        if (!tmp) {
          break;
        }
        ;
      }
      ;
      indents.push(indent);
      _g.push(line);
    }
    ;
    let lines = _g;
    let result = [];
    let lineNum = 0;
    let colNum = 0;
    let lineIdx = 0;
    while (lineIdx < lines.length) {
      let line = lines[lineIdx];
      let indent = indents[lineNum];
      while (true) {
        while (line.charAt(line.length - 1) == "\n" || line.charAt(line.length - 1) == "\r")
          line = line.substring(0, line.length - 1);
        if (line.endsWith(" \\")) {
          line = StringTools.rtrim(line.substring(0, line.length - 2));
          line += " " + StringTools.trim(lines[++lineIdx]);
          ++lineNum;
        } else {
          break;
        }
        ;
      }
      ;
      ++lineIdx;
      ++lineNum;
      if (line == "###") {
        isInMultilineComment = !isInMultilineComment;
        continue;
      }
      ;
      if (isInMultilineComment) {
        result.push(Token.Literal("### " + line, { "line": lineNum, "col": colNum + indent, "file": file }));
        continue;
      }
      ;
      if (line.charAt(0) == "#") {
        result.push(Token.Literal(line, { "line": lineNum, "col": colNum + indent, "file": file }));
        continue;
      }
      ;
      if (line.charAt(0) == "}") {
        result.push(Token.BracketClose({ "line": lineNum, "col": colNum + indent, "file": file }));
        line = line.substring(1);
      }
      ;
      let i = 0;
      let braces = [];
      let done = false;
      while (i < line.length) {
        let idx = line.length - i - 1;
        let c = line.charAt(idx);
        if (c == "}") {
          braces.push(Brackets.Curly);
        } else if (c == "{") {
          if (braces.length == 0) {
            let content = StringTools.trim(line.substring(0, idx));
            if (content.length > 0) {
              result.push(Token.Literal(content, { "line": lineNum, "col": colNum + indent, "file": file }));
            }
            ;
            let tmp = StringTools.trim(line.substring(idx + 1));
            result.push(Token.BracketOpen({ "line": lineNum, "col": colNum + indent + idx, "file": file }, tmp));
            done = true;
            break;
          }
          ;
          braces.pop();
        }
        ;
        ++i;
      }
      ;
      let trimmed = StringTools.trim(line);
      if (done || trimmed.length == 0) {
        continue;
      }
      ;
      result.push(Token.Literal(StringTools.trim(trimmed), { "line": lineNum, "col": colNum + indent, "file": file }));
    }
    ;
    return result;
  }
  static get __name__() {
    return "mcl.Tokenizer";
  }
  get __class__() {
    return Tokenizer2;
  }
};

// bin/mcl/Compiler.js
var Module = __toESM(require("module"));

// bin/mcl/error/CompilerError.js
var $global25 = Register.$global;
var CompilerError = Register.global("$hxClasses")["mcl.error.CompilerError"] = class CompilerError2 extends Register.inherits(McbError) {
  new(message, internal, mcbstack) {
    super.new((internal ? "Internal " : "") + "Compiler Error:\n	" + message, mcbstack);
    this.internal = internal;
  }
  static get __name__() {
    return "mcl.error.CompilerError";
  }
  static get __super__() {
    return McbError;
  }
  get __class__() {
    return CompilerError2;
  }
};

// bin/mcl/TagManager.js
var $global26 = Register.$global;
var TagManager = Register.global("$hxClasses")["mcl.TagManager"] = class TagManager2 extends Register.inherits() {
  new() {
    this.tagEntries = new StringMap();
  }
  ensureTag(tag, context) {
    let colonIndex = tag.indexOf(":");
    if (colonIndex == -1) {
      tag = context.namespace + ":" + context.path.concat([tag]).join("/");
    } else if (colonIndex != tag.lastIndexOf(":")) {
      let pos = null;
      throw new CompilerError(ErrorUtil.formatContext("Invalid tag name: " + tag, pos, context), false, [pos].concat(context.stack));
    }
    ;
    if (!this.tagEntries.inst.has(tag)) {
      this.tagEntries.inst.set(tag, { "entries": /* @__PURE__ */ new Set(), "replace": false });
    }
    ;
    return tag;
  }
  addTagEntry(tag, entry, context, replace) {
    if (replace == null) {
      replace = false;
    }
    ;
    tag = this.ensureTag(tag, context);
    this.tagEntries.inst.get(tag).entries.add({ "value": entry, "replace": replace });
  }
  setTagReplace(tag, context, replace) {
    tag = this.ensureTag(tag, context);
    this.tagEntries.inst.get(tag).replace = replace;
  }
  writeTagFiles(compiler) {
    let map = this.tagEntries;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      let segments = k.split(":");
      let tmp = segments.length != 2;
      let namespace = segments[0];
      let tag = segments[1];
      let tagPath = Path2.join(["data", namespace, "tags", compiler.config.features.useFolderRenames48 ? "function" : "functions", tag + ".json"]);
      let compiler1 = compiler.io;
      let _g = [];
      let jsIterator = v.entries.values();
      let _g_jsIterator = jsIterator;
      let _g_lastStep = jsIterator.next();
      while (!_g_lastStep.done) {
        let v2 = _g_lastStep.value;
        _g_lastStep = _g_jsIterator.next();
        let entry = v2;
        let entry1 = entry.replace;
        _g.push(entry.value);
      }
      ;
      compiler1.write(tagPath, JSON.stringify({ "values": _g, "replace": v.replace ? true : void 0 }));
    }
    ;
  }
  static get __name__() {
    return "mcl.TagManager";
  }
  get __class__() {
    return TagManager2;
  }
};

// bin/mcl/error/ParserError.js
var $global27 = Register.$global;
var ParserError = Register.global("$hxClasses")["mcl.error.ParserError"] = class ParserError2 extends Register.inherits(McbError) {
  new(message) {
    super.new("Parser Error:\n	" + message, []);
  }
  static get __name__() {
    return "mcl.error.ParserError";
  }
  static get __super__() {
    return McbError;
  }
  get __class__() {
    return ParserError2;
  }
};

// bin/mcl/AstNode.js
var $global28 = Register.$global;
var JsonTagType = Register.global("$hxEnums")["mcl.JsonTagType"] = {
  __ename__: "mcl.JsonTagType",
  Tag: Object.assign((subType, replace, entries) => ({ _hx_index: 0, __enum__: "mcl.JsonTagType", "subType": subType, "replace": replace, "entries": entries }), { _hx_name: "Tag", __params__: ["subType", "replace", "entries"] }),
  Advancement: Object.assign((entries) => ({ _hx_index: 1, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "Advancement", __params__: ["entries"] }),
  ItemModifier: Object.assign((entries) => ({ _hx_index: 2, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "ItemModifier", __params__: ["entries"] }),
  LootTable: Object.assign((entries) => ({ _hx_index: 3, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "LootTable", __params__: ["entries"] }),
  Predicate: Object.assign((entries) => ({ _hx_index: 4, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "Predicate", __params__: ["entries"] }),
  Recipe: Object.assign((entries) => ({ _hx_index: 5, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "Recipe", __params__: ["entries"] }),
  ChatType: Object.assign((entries) => ({ _hx_index: 6, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "ChatType", __params__: ["entries"] }),
  DamageType: Object.assign((entries) => ({ _hx_index: 7, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "DamageType", __params__: ["entries"] }),
  Dimension: Object.assign((entries) => ({ _hx_index: 8, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "Dimension", __params__: ["entries"] }),
  DimensionType: Object.assign((entries) => ({ _hx_index: 9, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "DimensionType", __params__: ["entries"] }),
  Enchantment: Object.assign((entries) => ({ _hx_index: 10, __enum__: "mcl.JsonTagType", "entries": entries }), { _hx_name: "Enchantment", __params__: ["entries"] }),
  WorldGen: Object.assign((subType, name, entries) => ({ _hx_index: 11, __enum__: "mcl.JsonTagType", "subType": subType, "name": name, "entries": entries }), { _hx_name: "WorldGen", __params__: ["subType", "name", "entries"] })
};
JsonTagType.__constructs__ = [JsonTagType.Tag, JsonTagType.Advancement, JsonTagType.ItemModifier, JsonTagType.LootTable, JsonTagType.Predicate, JsonTagType.Recipe, JsonTagType.ChatType, JsonTagType.DamageType, JsonTagType.Dimension, JsonTagType.DimensionType, JsonTagType.Enchantment, JsonTagType.WorldGen];
JsonTagType.__empty_constructs__ = [];
var AstNode = Register.global("$hxEnums")["mcl.AstNode"] = {
  __ename__: "mcl.AstNode",
  Raw: Object.assign((pos, value, continuations, isMacro) => ({ _hx_index: 0, __enum__: "mcl.AstNode", "pos": pos, "value": value, "continuations": continuations, "isMacro": isMacro }), { _hx_name: "Raw", __params__: ["pos", "value", "continuations", "isMacro"] }),
  FunctionDef: Object.assign((pos, name, body, appendTo) => ({ _hx_index: 1, __enum__: "mcl.AstNode", "pos": pos, "name": name, "body": body, "appendTo": appendTo }), { _hx_name: "FunctionDef", __params__: ["pos", "name", "body", "appendTo"] }),
  TemplateDef: Object.assign((pos, name, body) => ({ _hx_index: 2, __enum__: "mcl.AstNode", "pos": pos, "name": name, "body": body }), { _hx_name: "TemplateDef", __params__: ["pos", "name", "body"] }),
  Directory: Object.assign((pos, name, body) => ({ _hx_index: 3, __enum__: "mcl.AstNode", "pos": pos, "name": name, "body": body }), { _hx_name: "Directory", __params__: ["pos", "name", "body"] }),
  Import: Object.assign((pos, name) => ({ _hx_index: 4, __enum__: "mcl.AstNode", "pos": pos, "name": name }), { _hx_name: "Import", __params__: ["pos", "name"] }),
  CompileTimeLoop: Object.assign((pos, expression, as, body) => ({ _hx_index: 5, __enum__: "mcl.AstNode", "pos": pos, "expression": expression, "as": as, "body": body }), { _hx_name: "CompileTimeLoop", __params__: ["pos", "expression", "as", "body"] }),
  CompileTimeIf: Object.assign((pos, expression, body, elseExpressions) => ({ _hx_index: 6, __enum__: "mcl.AstNode", "pos": pos, "expression": expression, "body": body, "elseExpressions": elseExpressions }), { _hx_name: "CompileTimeIf", __params__: ["pos", "expression", "body", "elseExpressions"] }),
  MultiLineScript: Object.assign((pos, value) => ({ _hx_index: 7, __enum__: "mcl.AstNode", "pos": pos, "value": value }), { _hx_name: "MultiLineScript", __params__: ["pos", "value"] }),
  Block: Object.assign((pos, name, body, data, isMacro, isInline) => ({ _hx_index: 8, __enum__: "mcl.AstNode", "pos": pos, "name": name, "body": body, "data": data, "isMacro": isMacro, "isInline": isInline }), { _hx_name: "Block", __params__: ["pos", "name", "body", "data", "isMacro", "isInline"] }),
  TickBlock: Object.assign((pos, body) => ({ _hx_index: 9, __enum__: "mcl.AstNode", "pos": pos, "body": body }), { _hx_name: "TickBlock", __params__: ["pos", "body"] }),
  LoadBlock: Object.assign((pos, body) => ({ _hx_index: 10, __enum__: "mcl.AstNode", "pos": pos, "body": body }), { _hx_name: "LoadBlock", __params__: ["pos", "body"] }),
  ExecuteBlock: Object.assign((pos, execute, data, body, continuations, isMacro) => ({ _hx_index: 11, __enum__: "mcl.AstNode", "pos": pos, "execute": execute, "data": data, "body": body, "continuations": continuations, "isMacro": isMacro }), { _hx_name: "ExecuteBlock", __params__: ["pos", "execute", "data", "body", "continuations", "isMacro"] }),
  ScheduleBlock: Object.assign((pos, delay, type, body, isMacro) => ({ _hx_index: 12, __enum__: "mcl.AstNode", "pos": pos, "delay": delay, "type": type, "body": body, "isMacro": isMacro }), { _hx_name: "ScheduleBlock", __params__: ["pos", "delay", "type", "body", "isMacro"] }),
  SequenceBlock: Object.assign((pos, body) => ({ _hx_index: 13, __enum__: "mcl.AstNode", "pos": pos, "body": body }), { _hx_name: "SequenceBlock", __params__: ["pos", "body"] }),
  RuntimeLoop: Object.assign((pos, expression, body) => ({ _hx_index: 14, __enum__: "mcl.AstNode", "pos": pos, "expression": expression, "body": body }), { _hx_name: "RuntimeLoop", __params__: ["pos", "expression", "body"] }),
  Comment: Object.assign((pos, value) => ({ _hx_index: 15, __enum__: "mcl.AstNode", "pos": pos, "value": value }), { _hx_name: "Comment", __params__: ["pos", "value"] }),
  JsonFile: Object.assign((pos, name, info) => ({ _hx_index: 16, __enum__: "mcl.AstNode", "pos": pos, "name": name, "info": info }), { _hx_name: "JsonFile", __params__: ["pos", "name", "info"] }),
  TemplateOverload: Object.assign((pos, args, body) => ({ _hx_index: 17, __enum__: "mcl.AstNode", "pos": pos, "args": args, "body": body }), { _hx_name: "TemplateOverload", __params__: ["pos", "args", "body"] }),
  ClockExpr: Object.assign((pos, name, time, body) => ({ _hx_index: 18, __enum__: "mcl.AstNode", "pos": pos, "name": name, "time": time, "body": body }), { _hx_name: "ClockExpr", __params__: ["pos", "name", "time", "body"] }),
  Execute: Object.assign((pos, command, value, isMacro) => ({ _hx_index: 19, __enum__: "mcl.AstNode", "pos": pos, "command": command, "value": value, "isMacro": isMacro }), { _hx_name: "Execute", __params__: ["pos", "command", "value", "isMacro"] }),
  FunctionCall: Object.assign((pos, name, data, isMacro) => ({ _hx_index: 20, __enum__: "mcl.AstNode", "pos": pos, "name": name, "data": data, "isMacro": isMacro }), { _hx_name: "FunctionCall", __params__: ["pos", "name", "data", "isMacro"] }),
  EqCommand: Object.assign((pos, command) => ({ _hx_index: 21, __enum__: "mcl.AstNode", "pos": pos, "command": command }), { _hx_name: "EqCommand", __params__: ["pos", "command"] }),
  ScheduleCall: Object.assign((pos, delay, target, mode, isMacro) => ({ _hx_index: 22, __enum__: "mcl.AstNode", "pos": pos, "delay": delay, "target": target, "mode": mode, "isMacro": isMacro }), { _hx_name: "ScheduleCall", __params__: ["pos", "delay", "target", "mode", "isMacro"] }),
  ReturnRun: Object.assign((pos, value, isMacro) => ({ _hx_index: 23, __enum__: "mcl.AstNode", "pos": pos, "value": value, "isMacro": isMacro }), { _hx_name: "ReturnRun", __params__: ["pos", "value", "isMacro"] }),
  ScheduleClear: Object.assign((pos, target, isMacro) => ({ _hx_index: 24, __enum__: "mcl.AstNode", "pos": pos, "target": target, "isMacro": isMacro }), { _hx_name: "ScheduleClear", __params__: ["pos", "target", "isMacro"] }),
  Void: { _hx_name: "Void", _hx_index: 25, __enum__: "mcl.AstNode" },
  Group: Object.assign((body) => ({ _hx_index: 26, __enum__: "mcl.AstNode", "body": body }), { _hx_name: "Group", __params__: ["body"] })
};
AstNode.__constructs__ = [AstNode.Raw, AstNode.FunctionDef, AstNode.TemplateDef, AstNode.Directory, AstNode.Import, AstNode.CompileTimeLoop, AstNode.CompileTimeIf, AstNode.MultiLineScript, AstNode.Block, AstNode.TickBlock, AstNode.LoadBlock, AstNode.ExecuteBlock, AstNode.ScheduleBlock, AstNode.SequenceBlock, AstNode.RuntimeLoop, AstNode.Comment, AstNode.JsonFile, AstNode.TemplateOverload, AstNode.ClockExpr, AstNode.Execute, AstNode.FunctionCall, AstNode.EqCommand, AstNode.ScheduleCall, AstNode.ReturnRun, AstNode.ScheduleClear, AstNode.Void, AstNode.Group];
AstNode.__empty_constructs__ = [AstNode.Void];

// bin/EReg.js
var $global29 = Register.$global;
var EReg = Register.global("$hxClasses")["EReg"] = class EReg2 extends Register.inherits() {
  new(r, opt) {
    this.r = new RegExp(r, opt.split("u").join(""));
  }
  /**
  Tells if `this` regular expression matches String `s`.
  
  This method modifies the internal state.
  
  If `s` is `null`, the result is unspecified.
  */
  match(s) {
    if (this.r.global) {
      this.r.lastIndex = 0;
    }
    ;
    this.r.m = this.r.exec(s);
    this.r.s = s;
    return this.r.m != null;
  }
  /**
  Returns the matched sub-group `n` of `this` EReg.
  
  This method should only be called after `this.match` or
  `this.matchSub`, and then operates on the String of that operation.
  
  The index `n` corresponds to the n-th set of parentheses in the pattern
  of `this` EReg. If no such sub-group exists, the result is unspecified.
  
  If `n` equals 0, the whole matched substring is returned.
  */
  matched(n) {
    if (this.r.m != null && n >= 0 && n < this.r.m.length) {
      return this.r.m[n];
    } else {
      throw Exception.thrown("EReg::matched");
    }
    ;
  }
  /**
  Returns the part to the right of the last matched substring.
  
  If the most recent call to `this.match` or `this.matchSub` did not
  match anything, the result is unspecified.
  
  If the global g modifier was in place for the matching, only the
  substring to the right of the leftmost match is returned.
  
  The result does not include the matched part.
  */
  matchedRight() {
    if (this.r.m == null) {
      throw Exception.thrown("No string matched");
    }
    ;
    let sz = this.r.m.index + this.r.m[0].length;
    return HxOverrides.substr(this.r.s, sz, this.r.s.length - sz);
  }
  /**
  Returns the position and length of the last matched substring, within
  the String which was last used as argument to `this.match` or
  `this.matchSub`.
  
  If the most recent call to `this.match` or `this.matchSub` did not
  match anything, the result is unspecified.
  
  If the global g modifier was in place for the matching, the position and
  length of the leftmost substring is returned.
  */
  matchedPos() {
    if (this.r.m == null) {
      throw Exception.thrown("No string matched");
    }
    ;
    return { "pos": this.r.m.index, "len": this.r.m[0].length };
  }
  static get __name__() {
    return "EReg";
  }
  get __class__() {
    return EReg2;
  }
};

// bin/mcl/Parser.js
var $global30 = Register.$global;
var ArrayInput = Register.global("$hxClasses")["mcl.ArrayInput"] = class ArrayInput2 extends Register.inherits() {
  new(array) {
    this.array = array;
    this.set_index(0);
  }
  get index() {
    return this.get_index();
  }
  set index(v) {
    this.set_index(v);
  }
  get_index() {
    return this._index;
  }
  set_index(i) {
    return this._index = i;
  }
  next() {
    if (this._index >= this.array.length) {
      throw new ParserError("Tried to read past the end of the token list");
    }
    ;
    let tmp = this.array;
    let lhs = this.get_index();
    this.set_index(lhs + 1);
    return tmp[lhs];
  }
  skip() {
    this.set_index(this.get_index() + 1);
  }
  peek() {
    return this.array[this.get_index()];
  }
  hasNext() {
    return this.get_index() < this.array.length;
  }
  insert(token) {
    let _this = this.array;
    let pos = this.get_index();
    _this.splice(pos, 0, token);
  }
  back() {
    this.set_index(this.get_index() - 1);
  }
  update(token) {
    this.array[this.get_index()] = token;
  }
  static get __name__() {
    return "mcl.ArrayInput";
  }
  get __class__() {
    return ArrayInput2;
  }
};
var Parser = Register.global("$hxClasses")["mcl.Parser"] = class Parser2 {
  static format(template, ...data) {
    let regex_r = new RegExp("\\{\\}", "".split("u").join(""));
    let _g = 0;
    let _g1 = data.slice();
    while (_g < _g1.length) {
      let field = _g1[_g];
      ++_g;
      template = template.replace(regex_r, Std.string(field));
    }
    ;
    return template;
  }
  static toss(token, error) {
    switch (token._hx_index) {
      case 0:
        let v = token.v;
        let pos = token.pos;
        throw new ParserError(Parser2.format(error, v, pos.file, pos.line, pos.col));
        break;
      case 1:
        let pos1 = token.pos;
        let data = token.data;
        throw new ParserError(Parser2.format(error, data, pos1.file, pos1.line, pos1.col));
        break;
      case 2:
        let pos2 = token.pos;
        throw new ParserError(Parser2.format(error, pos2.file, pos2.line, pos2.col));
        break;
    }
    ;
  }
  static unreachable(token) {
    let tmp;
    switch (token._hx_index) {
      case 0:
        let v = token.v;
        let p = token.pos;
        tmp = Parser2.format("Unexpected token '{}' at {}:{}:{}", v, p.file, p.line, p.col);
        break;
      case 1:
        let p1 = token.pos;
        let d = token.data;
        tmp = Parser2.format("Unexpected '{' with data '{}' at {}:{}:{}", d, p1.file, p1.line, p1.col);
        break;
      case 2:
        let p2 = token.pos;
        tmp = Parser2.format("Unexpected '}' at {}:{}:{}", p2.file, p2.line, p2.col);
        break;
    }
    ;
    return new ParserError(tmp);
  }
  static expect(reader, match) {
    let token = reader.next();
    if (!match(token)) {
      throw Parser2.unreachable(token);
    }
    ;
  }
  static expectThenData(reader, allowData) {
    if (allowData == null) {
      allowData = true;
    }
    ;
    let token = reader.peek();
    Parser2.expect(reader, function(token2) {
      return token2._hx_index == 1;
    });
    if (token._hx_index == 1) {
      let _g = token.pos;
      let data = token.data;
      if (!allowData && data.length > 0) {
        throw Parser2.unreachable(token);
      }
      ;
      return data;
    } else {
      return null;
    }
    ;
  }
  static block(reader, sub, allowData, onLastToken) {
    if (allowData == null) {
      allowData = true;
    }
    ;
    let data = Parser2.expectThenData(reader, allowData);
    while (true) {
      if (!reader.hasNext()) {
        throw new ParserError("Unexpected end of file!");
      }
      ;
      let token = reader.peek();
      if (token._hx_index == 2) {
        let _g = token.pos;
        if (onLastToken != null) {
          onLastToken(token);
        }
        ;
        break;
      } else {
        sub();
      }
      ;
    }
    ;
    Parser2.expect(reader, function(token) {
      return token._hx_index == 2;
    });
    if (data == "") {
      return null;
    } else {
      return data;
    }
    ;
  }
  static readFunction(name, reader, pos) {
    let commands = [];
    let appendTo = null;
    let segments = name.split(" ");
    if (segments.length == 2) {
      name = segments[0];
      appendTo = segments[1];
    } else if (segments.length == 1) {
      name = segments[0];
    }
    ;
    Parser2.block(reader, function() {
      commands.push(Parser2.innerParse(reader));
    }, false);
    return AstNode.FunctionDef(pos, name, commands, appendTo);
  }
  static innerParseTemplate(reader) {
    let _g = reader.peek();
    if (_g._hx_index == 0) {
      let _g1 = _g.v;
      let _g2 = _g.pos;
      switch (_g1) {
        case "load":
          let pos = _g2;
          reader.skip();
          let content = [];
          Parser2.block(reader, function() {
            content.push(Parser2.innerParse(reader));
          }, false);
          return AstNode.LoadBlock(pos, content);
          break;
        case "tick":
          let pos1 = _g2;
          reader.skip();
          let content1 = [];
          Parser2.block(reader, function() {
            content1.push(Parser2.innerParse(reader));
          }, false);
          return AstNode.TickBlock(pos1, content1);
          break;
        default:
          let v = _g1;
          let pos2 = _g2;
          if (v == "with" || v.startsWith("with ")) {
            reader.skip();
            let args = StringTools.trim(v.substring("with ".length));
            let content2 = [];
            Parser2.block(reader, function() {
              content2.push(Parser2.innerParse(reader));
            }, false);
            return AstNode.TemplateOverload(pos2, args, content2);
          } else {
            throw Parser2.unreachable(reader.next());
          }
          ;
      }
      ;
    } else {
      throw Parser2.unreachable(reader.next());
    }
    ;
  }
  static readTemplate(name, reader, pos) {
    let entries = [];
    Parser2.block(reader, function() {
      entries.push(Parser2.innerParseTemplate(reader));
    }, false);
    return AstNode.TemplateDef(pos, name, entries);
  }
  static pos(token) {
    switch (token._hx_index) {
      case 0:
        let _g = token.v;
        let pos = token.pos;
        return pos;
        break;
      case 1:
        let _g1 = token.data;
        let pos1 = token.pos;
        return pos1;
        break;
      case 2:
        let pos2 = token.pos;
        return pos2;
        break;
    }
    ;
  }
  static json(reader) {
    let pos = Parser2.pos(reader.peek());
    let depth = 0;
    let result = "";
    do {
      if (!reader.hasNext()) {
        throw new ParserError("Unexpected end of file!");
      }
      ;
      let token = reader.next();
      switch (token._hx_index) {
        case 0:
          let _g = token.pos;
          let v = token.v;
          result += v;
          break;
        case 1:
          let _g1 = token.pos;
          let data = token.data;
          result += "{";
          result += data;
          ++depth;
          break;
        case 2:
          let _g2 = token.pos;
          --depth;
          result += "}";
          break;
      }
      ;
    } while (depth > 0);
    return AstNode.Raw(pos, result, [], false);
  }
  static parseMcbFile(tokens) {
    let reader = new ArrayInput(tokens);
    let nodes = [];
    while (reader.hasNext())
      nodes.push(Parser2.parseTLD(reader));
    return nodes;
  }
  static parseMcbtFile(tokens) {
    let reader = new ArrayInput(tokens);
    let nodes = [];
    while (reader.hasNext()) {
      let token = reader.next();
      let tmp;
      if (token._hx_index == 0) {
        let v = token.v;
        let pos = token.pos;
        if (v.startsWith("template ")) {
          let name = StringTools.trim(v.substring("template ".length));
          tmp = Parser2.readTemplate(name, reader, pos);
        } else if (v.startsWith("#")) {
          tmp = AstNode.Comment(pos, v);
        } else if (v.startsWith("import ")) {
          tmp = AstNode.Import(pos, v.substring("import ".length));
        } else {
          throw Parser2.unreachable(token);
        }
        ;
      } else {
        throw Parser2.unreachable(token);
      }
      ;
      nodes.push(tmp);
    }
    ;
    return nodes;
  }
  static parserCompilerLoop(v, pos, reader, handler) {
    let content = [];
    Parser2.block(reader, function() {
      content.push(handler());
    });
    if (Parser2.loopRegExp.match(v)) {
      let loop = Parser2.loopRegExp.matched(1);
      let as = Parser2.loopRegExp.matched(2);
      let tmp;
      if (as.length == 0) {
        tmp = null;
      } else {
        let _g = [];
        let _g1 = 0;
        let _g2 = as.split(",");
        while (_g1 < _g2.length) {
          let e = _g2[_g1];
          ++_g1;
          _g.push(StringTools.trim(e));
        }
        ;
        tmp = _g;
      }
      ;
      return AstNode.CompileTimeLoop(pos, loop, tmp, content);
    }
    ;
    return AstNode.CompileTimeLoop(pos, v, null, content);
  }
  static parseTLD(reader) {
    let _g = reader.next();
    if (_g._hx_index == 0) {
      let v = _g.v;
      let pos = _g.pos;
      if (v.startsWith("function ")) {
        let name = StringTools.trim(v.substring("function ".length));
        return Parser2.readFunction(name, reader, pos);
      } else if (v.startsWith("clock ")) {
        let time = StringTools.trim(v.substring("clock ".length));
        if (time.indexOf(" ") == -1) {
          throw new ParserError(Parser2.format('"Expected a name and a time for the clock command" at {}:{}:{}', pos.file, pos.line, pos.col));
        }
        ;
        let name = StringTools.trim(time.substring(0, time.indexOf(" ") + 1));
        time = StringTools.trim(time.substring(time.indexOf(" ")));
        let content = [];
        Parser2.block(reader, function() {
          content.push(Parser2.innerParse(reader));
        });
        return AstNode.ClockExpr(pos, name, time, content);
      } else if (v.startsWith("import ")) {
        return AstNode.Import(pos, v.substring("import ".length));
      } else if (v.startsWith("dir ") && reader.peek()._hx_index == 1) {
        let content = [];
        let data = Parser2.block(reader, function() {
          content.push(Parser2.parseTLD(reader));
        }, false);
        if (data != null) {
          throw Parser2.unreachable(Token.Literal(v, pos));
        }
        ;
        return AstNode.Directory(pos, v.substring("dir ".length), content);
      } else if (v.startsWith("<%%")) {
        let content = [];
        while (true) {
          if (!reader.hasNext()) {
            throw new ParserError("Unexpected end of file!");
          }
          ;
          let _g2 = reader.peek();
          if (_g2._hx_index == 0) {
            let _g1 = _g2.pos;
            if (_g2.v == "%%>") {
              reader.skip();
              break;
            }
            ;
          }
          ;
          content.push(reader.next());
        }
        ;
        return AstNode.MultiLineScript(pos, content);
      } else if (v.startsWith("#")) {
        return AstNode.Comment(pos, v);
      } else if (v.startsWith("REPEAT")) {
        return Parser2.parserCompilerLoop(v, pos, reader, function() {
          return Parser2.parseTLD(reader);
        });
      } else if (v.startsWith("IF")) {
        return Parser2.parseCompileTimeIf(v, pos, reader, function() {
          return Parser2.parseTLD(reader);
        });
      } else if (v.startsWith("tag ")) {
        let sections = StringTools.trim(v.substring("tag ".length)).split(" ");
        let type = sections.shift();
        let name = sections.shift();
        let replace = sections.shift() == "replace";
        let content = [];
        Parser2.block(reader, function() {
          content.push(Parser2.innerParse(reader));
        });
        return AstNode.JsonFile(pos, name, JsonTagType.Tag(type, replace, content));
      } else if (v.startsWith("advancement ") || v.startsWith("enchantment ") || v.startsWith("item_modifier ") || v.startsWith("loot_table ") || v.startsWith("predicate ") || v.startsWith("recipe ") || v.startsWith("chat_type ") || v.startsWith("damage_type ") || v.startsWith("dimension ") || v.startsWith("dimension_type ")) {
        return Parser2.readPlainJsonFile(v, pos, reader);
      } else if (v.startsWith("worldgen ")) {
        let name = StringTools.trim(v.substring("worldgen ".length));
        let subtype = name.substring(0, name.indexOf(" "));
        name = name.substring(name.indexOf(" ") + 1);
        let content = [];
        Parser2.block(reader, function() {
          content.push(Parser2.innerParse(reader));
        });
        return AstNode.JsonFile(pos, name, JsonTagType.WorldGen(subtype, name, content));
      } else {
        throw Parser2.unreachable(Token.Literal(v, pos));
      }
      ;
    } else {
      let node = _g;
      throw Parser2.unreachable(node);
    }
    ;
  }
  static readPlainJsonFile(v, pos, reader) {
    let _g = [];
    let _g1 = 0;
    let _g2 = v.split(" ");
    while (_g1 < _g2.length) {
      let v2 = _g2[_g1];
      ++_g1;
      if (v2 != "") {
        _g.push(v2);
      }
      ;
    }
    ;
    let bits = _g;
    let type = bits.shift();
    let name = bits.shift();
    let content = [];
    Parser2.block(reader, function() {
      content.push(Parser2.json(reader));
    });
    let tmp;
    if (type == null) {
      throw Parser2.unreachable(Token.Literal(v, pos));
    } else {
      switch (type) {
        case "advancement":
          tmp = JsonTagType.Advancement(content);
          break;
        case "chat_type":
          tmp = JsonTagType.ChatType(content);
          break;
        case "damage_type":
          tmp = JsonTagType.DamageType(content);
          break;
        case "dimension":
          tmp = JsonTagType.Dimension(content);
          break;
        case "dimension_type":
          tmp = JsonTagType.DimensionType(content);
          break;
        case "enchantment":
          tmp = JsonTagType.Enchantment(content);
          break;
        case "item_modifier":
          tmp = JsonTagType.ItemModifier(content);
          break;
        case "loot_table":
          tmp = JsonTagType.LootTable(content);
          break;
        case "predicate":
          tmp = JsonTagType.Predicate(content);
          break;
        case "recipe":
          tmp = JsonTagType.Recipe(content);
          break;
        default:
          throw Parser2.unreachable(Token.Literal(v, pos));
      }
      ;
    }
    ;
    return AstNode.JsonFile(pos, name, tmp);
  }
  static innerParse(reader) {
    let token = reader.peek();
    switch (token._hx_index) {
      case 0:
        let v = token.v;
        let pos = token.pos;
        reader.next();
        let isMacroArg = v.charAt(0) == "$";
        if (isMacroArg) {
          v = v.substring(1);
        }
        ;
        if (v == "<%%") {
          let content2 = [];
          while (true) {
            if (!reader.hasNext()) {
              throw new ParserError("Unexpected end of file!");
            }
            ;
            let _g2 = reader.peek();
            if (_g2._hx_index == 0) {
              let _g1 = _g2.pos;
              if (_g2.v == "%%>") {
                reader.skip();
                break;
              }
              ;
            }
            ;
            content2.push(reader.next());
          }
          ;
          return AstNode.MultiLineScript(pos, content2);
        } else if (v.startsWith("IF")) {
          return Parser2.parseCompileTimeIf(v, pos, reader, function() {
            return Parser2.innerParse(reader);
          });
        } else if (v.startsWith("function ")) {
          let target = v.substring("function ".length);
          let end = target.indexOf(" ");
          let name = target.substring(0, end == -1 ? target.length : end);
          let data2 = target.substring(name.length + 1);
          return AstNode.FunctionCall(pos, name, data2, isMacroArg);
        } else if (v.startsWith("schedule ")) {
          let name = StringTools.trim(v.substring("schedule ".length));
          if (name.startsWith("function ")) {
            let target = name.substring("function ".length);
            let end = target.indexOf(" ");
            let funcName = target.substring(0, end == -1 ? target.length : end);
            let delay2 = end == -1 ? null : target.substring(funcName.length + 1);
            let mode2 = "replace";
            if (delay2.endsWith(" append")) {
              mode2 = "append";
              delay2 = delay2.substring(0, delay2.length - " append".length);
            }
            ;
            if (delay2.endsWith(" replace")) {
              mode2 = "replace";
              delay2 = delay2.substring(0, delay2.length - " replace".length);
            }
            ;
            if (delay2 == null) {
              throw new ParserError(Parser2.format('"Expected delay after function name in schedule command" at {}:{}:{}', pos.file, pos.line, pos.col));
            }
            ;
            return AstNode.ScheduleCall(pos, delay2, funcName, mode2, isMacroArg);
          }
          ;
          if (name.startsWith("clear ")) {
            return AstNode.ScheduleClear(pos, name.substring("clear ".length), isMacroArg);
          }
          ;
          let delayIdx = name.indexOf(" ");
          let delay = delayIdx == -1 ? name : name.substring(0, delayIdx);
          let mode = "append";
          if (name.endsWith(" append")) {
            mode = "append";
            name = name.substring(0, name.length - " append".length);
          }
          ;
          if (name.endsWith(" replace")) {
            mode = "replace";
            name = name.substring(0, name.length - " replace".length);
          }
          ;
          let content2 = [];
          if (reader.peek()._hx_index != 1) {
            throw new ParserError("Expected { after delay in schedule block command");
          }
          ;
          Parser2.block(reader, function() {
            content2.push(Parser2.innerParse(reader));
          });
          return AstNode.ScheduleBlock(pos, delay, mode, content2, isMacroArg);
        } else if (v.startsWith("execute") && (v.charAt("execute".length) == " " || v.charAt("execute".length) == "<")) {
          if (reader.hasNext() && reader.peek()._hx_index == 1) {
            let content2 = [];
            if (!v.endsWith("run") && Parser2.executeRegExp.match(v)) {
              let p = Parser2.executeRegExp.matchedPos();
              let subPos = { "file": pos.file, "line": pos.line, "col": pos.col + p.pos + p.len };
              let continuationToken = Token.Literal(StringTools.ltrim(v.substring(p.pos + p.len)), subPos);
              reader.insert(continuationToken);
              return AstNode.Execute(pos, StringTools.rtrim(v.substring(0, p.pos + 3)), Parser2.innerParse(reader), isMacroArg);
            }
            ;
            let data2 = Parser2.block(reader, function() {
              content2.push(Parser2.innerParse(reader));
            });
            let extraBlocks = [];
            _hx_loop2:
              while (reader.hasNext()) {
                let _g2 = reader.peek();
                if (_g2._hx_index == 0) {
                  let _g1 = _g2.v;
                  let _g22 = _g2.pos;
                  switch (_g1) {
                    case "else $run":
                      let pos2 = _g22;
                      reader.skip();
                      let elseContent = [];
                      let elseData = Parser2.block(reader, function() {
                        elseContent.push(Parser2.innerParse(reader));
                      });
                      extraBlocks.push(AstNode.Block(pos2, null, elseContent, elseData, true, false));
                      break;
                    case "else run":
                      let pos12 = _g22;
                      reader.skip();
                      let elseContent1 = [];
                      let elseData1 = Parser2.block(reader, function() {
                        elseContent1.push(Parser2.innerParse(reader));
                      });
                      extraBlocks.push(AstNode.Block(pos12, null, elseContent1, elseData1, false, false));
                      break;
                    default:
                      let v2 = _g1;
                      let pos22 = _g22;
                      if (v2.startsWith("else $") && v2.endsWith("run")) {
                        reader.skip();
                        let executeCommand = StringTools.trim(v2.substring("else $".length));
                        let elseContent2 = [];
                        let elseData2 = Parser2.block(reader, function() {
                          elseContent2.push(Parser2.innerParse(reader));
                        });
                        pos22.col += 5;
                        extraBlocks.push(AstNode.ExecuteBlock(pos22, executeCommand, elseData2, elseContent2, null, true));
                      } else {
                        let v3 = _g1;
                        let pos3 = _g22;
                        if (v3.startsWith("else ") && v3.endsWith("run")) {
                          reader.skip();
                          let executeCommand = StringTools.trim(v3.substring("else ".length));
                          let elseContent2 = [];
                          let elseData2 = Parser2.block(reader, function() {
                            elseContent2.push(Parser2.innerParse(reader));
                          });
                          pos3.col += 5;
                          extraBlocks.push(AstNode.ExecuteBlock(pos3, executeCommand, elseData2, elseContent2, null, false));
                        } else {
                          break _hx_loop2;
                        }
                        ;
                      }
                      ;
                  }
                  ;
                } else {
                  break;
                }
                ;
              }
            ;
            return AstNode.ExecuteBlock(pos, v, data2, content2, extraBlocks.length > 0 ? extraBlocks : null, isMacroArg);
          } else {
            if (!Parser2.executeRegExp.match(v)) {
              return Parser2.readRaw(pos, v, reader, isMacroArg);
            }
            ;
            let p = Parser2.executeRegExp.matchedPos();
            let subPos = { "file": pos.file, "line": pos.line, "col": pos.col + p.pos + p.len };
            let continuationToken = Token.Literal(StringTools.ltrim(v.substring(p.pos + p.len)), subPos);
            reader.insert(continuationToken);
            return AstNode.Execute(pos, StringTools.rtrim(v.substring(0, p.pos + 3)), Parser2.innerParse(reader), isMacroArg);
          }
          ;
        } else if (v.startsWith("REPEAT")) {
          return Parser2.parserCompilerLoop(v, pos, reader, function() {
            return Parser2.innerParse(reader);
          });
        } else if (v.startsWith("#")) {
          return AstNode.Comment(pos, v);
        } else if (v == "block" || v.startsWith("block ")) {
          let name = StringTools.trim(v.substring("block ".length));
          let content2 = [];
          let data2 = Parser2.block(reader, function() {
            content2.push(Parser2.innerParse(reader));
          });
          return AstNode.Block(pos, name, content2, data2, isMacroArg, false);
        } else if (v.startsWith("return run")) {
          let subCommand = StringTools.trim(v.substring("return run ".length));
          let pos12 = { "file": pos.file, "line": pos.line, "col": pos.col + "return run ".length };
          let _g2 = reader.peek();
          if (_g2._hx_index == 1) {
            let pos2 = _g2.pos;
            let data2 = _g2.data;
            let content2 = [];
            let data1 = Parser2.block(reader, function() {
              content2.push(Parser2.innerParse(reader));
            });
            return AstNode.ReturnRun(pos2, AstNode.Block(pos2, null, content2, data1, false, false), isMacroArg);
          } else {
            reader.back();
            reader.update(Token.Literal(subCommand, pos12));
            return AstNode.ReturnRun(pos12, Parser2.innerParse(reader), isMacroArg);
          }
          ;
        } else if (v == "tick") {
          let content2 = [];
          Parser2.block(reader, function() {
            content2.push(Parser2.innerParse(reader));
          }, false);
          return AstNode.TickBlock(pos, content2);
        } else if (v == "load") {
          let content2 = [];
          Parser2.block(reader, function() {
            content2.push(Parser2.innerParse(reader));
          }, false);
          return AstNode.LoadBlock(pos, content2);
        } else if (v.startsWith("eq ")) {
          return AstNode.EqCommand(pos, v.substring("eq ".length));
        } else {
          return Parser2.readRaw(pos, v, reader, isMacroArg);
        }
        ;
        break;
      case 1:
        let _g = token.data;
        let pos1 = token.pos;
        let content = [];
        let data = Parser2.block(reader, function() {
          content.push(Parser2.innerParse(reader));
        });
        return AstNode.Block(pos1, null, content, data, false, false);
        break;
      default:
        throw Parser2.unreachable(token);
    }
    ;
  }
  static readRaw(pos, v, reader, isMacro) {
    if (!reader.hasNext()) {
      return AstNode.Raw(pos, v, [], isMacro);
    }
    ;
    let content = [];
    let line = pos.line;
    _hx_loop1:
      while (true) {
        if (!reader.hasNext()) {
          throw new ParserError("Unexpected end of file!");
        }
        ;
        let _g = reader.peek();
        switch (_g._hx_index) {
          case 0:
            let v1 = _g.v;
            let pos2 = _g.pos;
            if (pos2.line == line) {
              reader.skip();
              content.push(AstNode.Raw(pos2, v1, [], false));
            } else {
              break _hx_loop1;
            }
            ;
            break;
          case 1:
            let pos1 = _g.pos;
            let data = _g.data;
            if (pos1.line == line) {
              let blockContent = [];
              let blockData = Parser2.block(reader, function() {
                blockContent.push(Parser2.innerParse(reader));
              });
              content.push(AstNode.Block(pos1, null, blockContent, blockData, false, false));
            } else {
              break _hx_loop1;
            }
            ;
            break;
          case 2:
            let pos22 = _g.pos;
            if (pos22.line == line) {
              throw Parser2.unreachable(Token.Literal(v, pos22));
            } else {
              break _hx_loop1;
            }
            ;
            break;
          default:
            break _hx_loop1;
        }
        ;
      }
    ;
    return AstNode.Raw(pos, v, content, isMacro);
  }
  static parseCompileTimeIf(v, pos, reader, arg) {
    let exp = StringTools.trim(v.substring("IF".length));
    let content = [];
    Parser2.block(reader, function() {
      content.push(arg());
    }, false);
    let elseDatas = [];
    while (true) {
      if (!reader.hasNext()) {
        throw new ParserError("Unexpected end of file!");
      }
      ;
      let _g = reader.peek();
      if (_g._hx_index == 0) {
        let v2 = _g.v;
        let pos2 = _g.pos;
        if (v2 == "ELSE" || v2.startsWith("ELSE ")) {
          reader.skip();
          let condition = v2 == "ELSE" ? null : StringTools.trim(v2.substring("ELSE ".length));
          if (condition != null) {
            if (condition.startsWith("IF")) {
              condition = StringTools.trim(condition.substring("IF".length));
            }
            ;
          } else {
            condition = null;
          }
          ;
          let elseContent = [];
          Parser2.block(reader, function() {
            elseContent.push(arg());
          }, false);
          elseDatas.push({ "condition": condition, "node": elseContent });
        } else {
          break;
        }
        ;
      } else {
        break;
      }
      ;
    }
    ;
    return AstNode.CompileTimeIf(pos, exp, content, elseDatas);
  }
  static get __name__() {
    return "mcl.Parser";
  }
  get __class__() {
    return Parser2;
  }
};
Parser.loopRegExp = new EReg("(REPEAT\\s*\\(.+?\\))\\s\\s*as\\s\\s*([a-zA-Z,\\s]+)", "");
Parser.executeRegExp = new EReg("\\b(run\\s+?)\\b", "");

// bin/haxpression/ValueType.js
var $global31 = Register.$global;
var ValueType = Register.global("$hxEnums")["haxpression.ValueType"] = {
  __ename__: "haxpression.ValueType",
  VFloat: Object.assign((v) => ({ _hx_index: 0, __enum__: "haxpression.ValueType", "v": v }), { _hx_name: "VFloat", __params__: ["v"] }),
  VInt: Object.assign((v) => ({ _hx_index: 1, __enum__: "haxpression.ValueType", "v": v }), { _hx_name: "VInt", __params__: ["v"] }),
  VBool: Object.assign((v) => ({ _hx_index: 2, __enum__: "haxpression.ValueType", "v": v }), { _hx_name: "VBool", __params__: ["v"] }),
  VString: Object.assign((v) => ({ _hx_index: 3, __enum__: "haxpression.ValueType", "v": v }), { _hx_name: "VString", __params__: ["v"] }),
  VNA: { _hx_name: "VNA", _hx_index: 4, __enum__: "haxpression.ValueType" },
  VNM: { _hx_name: "VNM", _hx_index: 5, __enum__: "haxpression.ValueType" }
};
ValueType.__constructs__ = [ValueType.VFloat, ValueType.VInt, ValueType.VBool, ValueType.VString, ValueType.VNA, ValueType.VNM];
ValueType.__empty_constructs__ = [ValueType.VNA, ValueType.VNM];

// bin/haxpression/utils/Chars.js
var $global32 = Register.$global;
var Chars = Register.global("$hxClasses")["haxpression.utils.Chars"] = class Chars2 {
  static isDecimalDigit(charCode) {
    if (charCode >= 48) {
      return charCode <= 57;
    } else {
      return false;
    }
    ;
  }
  static isUpperCaseLetter(charCode) {
    if (charCode >= 65) {
      return charCode <= 90;
    } else {
      return false;
    }
    ;
  }
  static isLowerCaseLetter(charCode) {
    if (charCode >= 97) {
      return charCode <= 122;
    } else {
      return false;
    }
    ;
  }
  static isIdentifierStart(charCode) {
    if (!(charCode == Chars2.DOLLAR_CODE || charCode == Chars2.UNDERSCORE_CODE || Chars2.isUpperCaseLetter(charCode) || Chars2.isLowerCaseLetter(charCode))) {
      return Chars2.OTHER_IDENTIFIER_START_CODES.includes(charCode);
    } else {
      return true;
    }
    ;
  }
  static isIdentifierPart(charCode) {
    if (!(Chars2.isIdentifierStart(charCode) || Chars2.isDecimalDigit(charCode))) {
      return Chars2.OTHER_IDENTIFIER_PART_CODES.includes(charCode);
    } else {
      return true;
    }
    ;
  }
  static isWhiteSpace(charCode) {
    if (!(charCode == Chars2.TAB_CODE || charCode == Chars2.LF_CODE || charCode == Chars2.CR_CODE)) {
      return charCode == Chars2.SPACE_CODE;
    } else {
      return true;
    }
    ;
  }
  static get __name__() {
    return "haxpression.utils.Chars";
  }
  get __class__() {
    return Chars2;
  }
};
Chars.TAB_CODE = 9;
Chars.LF_CODE = 10;
Chars.CR_CODE = 13;
Chars.SPACE_CODE = 32;
Chars.EXCLAMATION_POINT_CODE = 33;
Chars.DOUBLE_QUOTE_CODE = 34;
Chars.DOLLAR_CODE = 36;
Chars.SINGLE_QUOTE_CODE = 39;
Chars.OPEN_PAREN_CODE = 40;
Chars.CLOSE_PAREN_CODE = 41;
Chars.COMMA_CODE = 44;
Chars.PERIOD_CODE = 46;
Chars.COLON_CODE = 58;
Chars.SEMICOLON_CODE = 59;
Chars.QUESTION_MARK_CODE = 63;
Chars.OPEN_BRACKET_CODE = 91;
Chars.CLOSE_BRACKET_CODE = 93;
Chars.UNDERSCORE_CODE = 95;
Chars.OTHER_IDENTIFIER_START_CODES = [];
Chars.OTHER_IDENTIFIER_PART_CODES = [Chars.EXCLAMATION_POINT_CODE, Chars.DOLLAR_CODE, Chars.COLON_CODE];

// bin/haxpression/utils/Iterators.js
var $global33 = Register.$global;
var Iterators = Register.global("$hxClasses")["haxpression.utils.Iterators"] = class Iterators2 {
  static toArray(iterator) {
    let result = [];
    let value = iterator;
    while (value.hasNext()) {
      let value1 = value.next();
      result.push(value1);
    }
    ;
    return result;
  }
  static get __name__() {
    return "haxpression.utils.Iterators";
  }
  get __class__() {
    return Iterators2;
  }
};

// bin/haxpression/utils/Arrays.js
var $global34 = Register.$global;
var Arrays = Register.global("$hxClasses")["haxpression.utils.Arrays"] = class Arrays2 {
  static all(items, check) {
    let _g = [];
    let _g1 = 0;
    let _g2 = items;
    while (_g1 < _g2.length) {
      let v = _g2[_g1];
      ++_g1;
      if (check(v)) {
        _g.push(v);
      }
      ;
    }
    ;
    return _g.length == items.length;
  }
  static reduce(items, callback, acc) {
    let _g = 0;
    while (_g < items.length) {
      let item = items[_g];
      ++_g;
      acc = callback(acc, item);
    }
    ;
    return acc;
  }
  static get __name__() {
    return "haxpression.utils.Arrays";
  }
  get __class__() {
    return Arrays2;
  }
};

// bin/haxpression/Error.js
var $global35 = Register.$global;
var Error2 = Register.global("$hxClasses")["haxpression.Error"] = class Error3 extends Register.inherits() {
  new(message, expression, position) {
    this.message = message;
    this.expression = expression;
    this.position = position;
  }
  toString() {
    let expressionInfo = this.expression != null ? ' in expression: "' + this.expression + '"' : "";
    let positionInfo = this.position != null ? " at position: " + this.position : "";
    return "" + this.message + expressionInfo + positionInfo;
  }
  static get __name__() {
    return "haxpression.Error";
  }
  get __class__() {
    return Error3;
  }
};

// bin/haxpression/Value.js
var $global36 = Register.$global;
var Value = Register.global("$hxClasses")["haxpression._Value.Value"] = class Value2 {
  static fromValueType(valueType) {
    return valueType;
  }
  static toValueType(this1) {
    return this1;
  }
  static fromFloat(v) {
    return Value2.fromValueType(ValueType.VFloat(v));
  }
  static fromInt(v) {
    return Value2.fromValueType(ValueType.VInt(v));
  }
  static fromBool(v) {
    return Value2.fromValueType(ValueType.VBool(v));
  }
  static toFloat(this1) {
    switch (this1._hx_index) {
      case 0:
        let v = this1.v;
        return v;
        break;
      case 1:
        let v1 = this1.v;
        return v1;
        break;
      case 2:
        let v2 = this1.v;
        throw Exception.thrown(new Error2("cannot convert Bool to Float"));
        break;
      case 3:
        let v3 = this1.v;
        throw Exception.thrown(new Error2("cannot convert String to Float"));
        break;
      case 4:
        throw Exception.thrown(new Error2("cannot convert NA to Float"));
        break;
      case 5:
        throw Exception.thrown(new Error2("cannot convert NM to Float"));
        break;
    }
    ;
  }
  static toInt(this1) {
    switch (this1._hx_index) {
      case 0:
        let v = this1.v;
        return v | 0;
        break;
      case 1:
        let v1 = this1.v;
        return v1;
        break;
      case 2:
        let v2 = this1.v;
        throw Exception.thrown(new Error2("cannot convert Bool to Int"));
        break;
      case 3:
        let v3 = this1.v;
        throw Exception.thrown(new Error2("cannot convert String to Int"));
        break;
      case 4:
        throw Exception.thrown(new Error2("cannot convert NA to Int"));
        break;
      case 5:
        throw Exception.thrown(new Error2("cannot convert NM to Int"));
        break;
    }
    ;
  }
  static toBool(this1) {
    switch (this1._hx_index) {
      case 0:
        let v = this1.v;
        return v != 0;
        break;
      case 1:
        let v1 = this1.v;
        return v1 != 0;
        break;
      case 2:
        let v2 = this1.v;
        return v2;
        break;
      case 3:
        let v3 = this1.v;
        return v3.toLowerCase() == Value2.TRUE_STRING;
        break;
      case 4:
        throw Exception.thrown(new Error2("cannot convert NA to Bool"));
        break;
      case 5:
        throw Exception.thrown(new Error2("cannot convert NM to Bool"));
        break;
    }
    ;
  }
  static isNA(this1) {
    if (this1._hx_index == 4) {
      return true;
    } else {
      return false;
    }
    ;
  }
  static isNM(this1) {
    if (this1._hx_index == 5) {
      return true;
    } else {
      return false;
    }
    ;
  }
  static get __name__() {
    return "haxpression._Value.Value_Impl_";
  }
  get __class__() {
    return Value2;
  }
};
Value.TRUE_STRING = "true";

// bin/haxpression/UnaryOperations.js
var $global37 = Register.$global;
var UnaryOperations = Register.global("$hxClasses")["haxpression.UnaryOperations"] = class UnaryOperations2 {
  static evaluate(_operator, value) {
    return UnaryOperations2.map.inst.get(_operator).operation(value);
  }
  static addOperator(_operator, operation) {
    let this1 = UnaryOperations2.map;
    let value = { "operation": UnaryOperations2.wrapOperation(operation) };
    this1.inst.set(_operator, value);
  }
  static hasOperator(_operator) {
    return UnaryOperations2.map.inst.has(_operator);
  }
  static getMaxOperatorLength() {
    return Arrays.reduce(Iterators.toArray(EsMap.adaptIterator(UnaryOperations2.map.inst.keys())), function(maxLength, key) {
      if (key.length > maxLength) {
        return key.length;
      } else {
        return maxLength;
      }
      ;
    }, 0);
  }
  static wrapOperation(operation) {
    return function(value) {
      if (Value.isNA(value)) {
        return Value.fromValueType(ValueType.VNA);
      } else if (Value.isNM(value)) {
        return Value.fromValueType(ValueType.VNM);
      } else {
        return operation(value);
      }
      ;
    };
  }
  static get __name__() {
    return "haxpression.UnaryOperations";
  }
  get __class__() {
    return UnaryOperations2;
  }
};
{
  UnaryOperations.map = new StringMap();
  UnaryOperations.addOperator("-", function(value) {
    return Value.fromFloat(Value.toFloat(value) * -1);
  });
  UnaryOperations.addOperator("+", function(value) {
    return Value.fromFloat(Value.toFloat(value));
  });
  UnaryOperations.addOperator("!", function(value) {
    return Value.fromBool(!Value.toBool(value));
  });
  UnaryOperations.addOperator("~", function(value) {
    return Value.fromInt(~Value.toInt(value));
  });
}

// bin/haxpression/ExpressionType.js
var $global38 = Register.$global;
var ExpressionType = Register.global("$hxEnums")["haxpression.ExpressionType"] = {
  __ename__: "haxpression.ExpressionType",
  ELiteral: Object.assign((value) => ({ _hx_index: 0, __enum__: "haxpression.ExpressionType", "value": value }), { _hx_name: "ELiteral", __params__: ["value"] }),
  EIdentifier: Object.assign((name) => ({ _hx_index: 1, __enum__: "haxpression.ExpressionType", "name": name }), { _hx_name: "EIdentifier", __params__: ["name"] }),
  EUnary: Object.assign((_operator, operand) => ({ _hx_index: 2, __enum__: "haxpression.ExpressionType", "_operator": _operator, "operand": operand }), { _hx_name: "EUnary", __params__: ["_operator", "operand"] }),
  EBinary: Object.assign((_operator, left, right) => ({ _hx_index: 3, __enum__: "haxpression.ExpressionType", "_operator": _operator, "left": left, "right": right }), { _hx_name: "EBinary", __params__: ["_operator", "left", "right"] }),
  ECall: Object.assign((callee, $arguments) => ({ _hx_index: 4, __enum__: "haxpression.ExpressionType", "callee": callee, "arguments": $arguments }), { _hx_name: "ECall", __params__: ["callee", "arguments"] }),
  EConditional: Object.assign((test, consequent, alternate) => ({ _hx_index: 5, __enum__: "haxpression.ExpressionType", "test": test, "consequent": consequent, "alternate": alternate }), { _hx_name: "EConditional", __params__: ["test", "consequent", "alternate"] }),
  EArray: Object.assign((items) => ({ _hx_index: 6, __enum__: "haxpression.ExpressionType", "items": items }), { _hx_name: "EArray", __params__: ["items"] }),
  ECompound: Object.assign((items) => ({ _hx_index: 7, __enum__: "haxpression.ExpressionType", "items": items }), { _hx_name: "ECompound", __params__: ["items"] })
};
ExpressionType.__constructs__ = [ExpressionType.ELiteral, ExpressionType.EIdentifier, ExpressionType.EUnary, ExpressionType.EBinary, ExpressionType.ECall, ExpressionType.EConditional, ExpressionType.EArray, ExpressionType.ECompound];
ExpressionType.__empty_constructs__ = [];

// bin/haxpression/ExpressionTypes.js
var $global39 = Register.$global;
var ExpressionTypes = Register.global("$hxClasses")["haxpression.ExpressionTypes"] = class ExpressionTypes2 {
  static canEvaluateAll(expressionTypes) {
    return Arrays.all(expressionTypes, function(expressionType) {
      return Expression.canEvaluate(Expression.fromExpressionType(expressionType));
    });
  }
  static simplify(expressionTypes) {
    let result = new Array(expressionTypes.length);
    let _g = 0;
    let _g1 = expressionTypes.length;
    while (_g < _g1) {
      let i = _g++;
      result[i] = Expression.toExpressionType(Expression.simplify(Expression.fromExpressionType(expressionTypes[i])));
    }
    ;
    return result;
  }
  static evaluate(expressionTypes, variables) {
    let result = new Array(expressionTypes.length);
    let _g = 0;
    let _g1 = expressionTypes.length;
    while (_g < _g1) {
      let i = _g++;
      result[i] = Expression.evaluate(Expression.fromExpressionType(expressionTypes[i]), variables);
    }
    ;
    return result;
  }
  static get __name__() {
    return "haxpression.ExpressionTypes";
  }
  get __class__() {
    return ExpressionTypes2;
  }
};

// bin/haxpression/CallOperations.js
var $global40 = Register.$global;
var CallOperations = Register.global("$hxClasses")["haxpression.CallOperations"] = class CallOperations2 {
  static addFunction(callee, arity, operation) {
    let this1 = CallOperations2.map;
    let value = { "arity": arity, "operation": CallOperations2.wrapOperation(callee, arity, operation) };
    this1.inst.set(callee, value);
  }
  static hasFunction(callee) {
    return CallOperations2.map.inst.has(callee);
  }
  static getFunction(callee) {
    if (!CallOperations2.hasFunction(callee)) {
      throw Exception.thrown(new Error2("no function implementation found for name: " + callee));
    }
    ;
    return CallOperations2.map.inst.get(callee).operation;
  }
  static getArity(callee) {
    if (!CallOperations2.hasFunction(callee)) {
      throw Exception.thrown(new Error2("no function implementation found for name: " + callee));
    }
    ;
    return CallOperations2.map.inst.get(callee).arity;
  }
  static canEvaluate(callee, $arguments) {
    if (!CallOperations2.hasFunction(callee)) {
      return false;
    }
    ;
    let arity = CallOperations2.getArity(callee);
    if (arity >= 0 && arity != $arguments.length) {
      return false;
    }
    ;
    return ExpressionTypes.canEvaluateAll($arguments);
  }
  static evaluate(callee, $arguments) {
    let operation = CallOperations2.getFunction(callee);
    return operation($arguments);
  }
  static wrapOperation(callee, arity, operation) {
    return function($arguments) {
      if (arity >= 0 && $arguments.length != arity) {
        throw Exception.thrown(new Error2("function " + callee + " expects exactly " + arity + " argument(s)"));
      }
      ;
      return operation($arguments);
    };
  }
  static get __name__() {
    return "haxpression.CallOperations";
  }
  get __class__() {
    return CallOperations2;
  }
};
{
  CallOperations.map = new StringMap();
  CallOperations.addFunction("abs", 1, function($arguments) {
    return Value.fromFloat(Math.abs(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("acos", 1, function($arguments) {
    return Value.fromFloat(Math.acos(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("asin", 1, function($arguments) {
    return Value.fromFloat(Math.asin(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("atan", 1, function($arguments) {
    return Value.fromFloat(Math.atan(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("atan2", 2, function($arguments) {
    return Value.fromFloat(Math.atan2(Value.toFloat($arguments[0]), Value.toFloat($arguments[1])));
  });
  CallOperations.addFunction("ceil", 1, function($arguments) {
    return Value.fromInt(Math.ceil(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("cos", 1, function($arguments) {
    return Value.fromFloat(Math.cos(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("exp", 1, function($arguments) {
    return Value.fromFloat(Math.exp(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("fceil", 1, function($arguments) {
    return Value.fromFloat(Math.ceil(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("ffloor", 1, function($arguments) {
    return Value.fromFloat(Math.floor(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("floor", 1, function($arguments) {
    return Value.fromInt(Math.floor(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("fround", 1, function($arguments) {
    return Value.fromFloat(Math.round(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("log", 1, function($arguments) {
    return Value.fromFloat(Math.log(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("max", 2, function($arguments) {
    return Value.fromFloat(Math.max(Value.toFloat($arguments[0]), Value.toFloat($arguments[1])));
  });
  CallOperations.addFunction("min", 2, function($arguments) {
    return Value.fromFloat(Math.min(Value.toFloat($arguments[0]), Value.toFloat($arguments[1])));
  });
  CallOperations.addFunction("pow", 2, function($arguments) {
    return Value.fromFloat(Math.pow(Value.toFloat($arguments[0]), Value.toFloat($arguments[1])));
  });
  CallOperations.addFunction("random", 0, function($arguments) {
    return Value.fromFloat(Math.random());
  });
  CallOperations.addFunction("rand", 0, function($arguments) {
    return Value.fromFloat(Math.random());
  });
  CallOperations.addFunction("round", 1, function($arguments) {
    return Value.fromInt(Math.round(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("sin", 1, function($arguments) {
    return Value.fromFloat(Math.sin(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("sqrt", 1, function($arguments) {
    return Value.fromFloat(Math.sqrt(Value.toFloat($arguments[0])));
  });
  CallOperations.addFunction("tan", 1, function($arguments) {
    return Value.fromFloat(Math.tan(Value.toFloat($arguments[0])));
  });
}

// bin/haxpression/BinaryOperations.js
var $global41 = Register.$global;
var BinaryOperations = Register.global("$hxClasses")["haxpression.BinaryOperations"] = class BinaryOperations2 {
  static evaluate(_operator, left, right) {
    return BinaryOperations2.map.inst.get(_operator).operation(left, right);
  }
  static addOperator(_operator, precedence, operation) {
    let this1 = BinaryOperations2.map;
    let value = { "precedence": precedence, "operation": BinaryOperations2.wrapOperation(operation) };
    this1.inst.set(_operator, value);
  }
  static hasOperator(_operator) {
    return BinaryOperations2.map.inst.has(_operator);
  }
  static getOperatorPrecedence(_operator) {
    return BinaryOperations2.map.inst.get(_operator).precedence;
  }
  static getMaxOperatorLength() {
    return Arrays.reduce(Iterators.toArray(EsMap.adaptIterator(BinaryOperations2.map.inst.keys())), function(maxLength, key) {
      if (key.length > maxLength) {
        return key.length;
      } else {
        return maxLength;
      }
      ;
    }, 0);
  }
  static wrapOperation(operation) {
    return function(left, right) {
      if (Value.isNA(left) || Value.isNA(right)) {
        return Value.fromValueType(ValueType.VNA);
      } else if (Value.isNM(left) || Value.isNM(right)) {
        return Value.fromValueType(ValueType.VNM);
      } else {
        return operation(left, right);
      }
      ;
    };
  }
  static get __name__() {
    return "haxpression.BinaryOperations";
  }
  get __class__() {
    return BinaryOperations2;
  }
};
{
  BinaryOperations.map = new StringMap();
  BinaryOperations.addOperator("||", 1, function(left, right) {
    return Value.fromBool(Value.toBool(left) || Value.toBool(right));
  });
  BinaryOperations.addOperator("&&", 2, function(left, right) {
    return Value.fromBool(Value.toBool(left) && Value.toBool(right));
  });
  BinaryOperations.addOperator("|", 3, function(left, right) {
    return Value.fromInt(Value.toInt(left) | Value.toInt(right));
  });
  BinaryOperations.addOperator("^", 4, function(left, right) {
    return Value.fromInt(Value.toInt(left) ^ Value.toInt(right));
  });
  BinaryOperations.addOperator("&", 5, function(left, right) {
    return Value.fromInt(Value.toInt(left) & Value.toInt(right));
  });
  BinaryOperations.addOperator("==", 6, function(left, right) {
    return Value.fromBool(Value.toFloat(left) == Value.toFloat(right));
  });
  BinaryOperations.addOperator("!=", 6, function(left, right) {
    return Value.fromBool(Value.toFloat(left) != Value.toFloat(right));
  });
  BinaryOperations.addOperator("<", 7, function(left, right) {
    return Value.fromBool(Value.toFloat(left) < Value.toFloat(right));
  });
  BinaryOperations.addOperator(">", 7, function(left, right) {
    return Value.fromBool(Value.toFloat(left) > Value.toFloat(right));
  });
  BinaryOperations.addOperator("<=", 7, function(left, right) {
    return Value.fromBool(Value.toFloat(left) <= Value.toFloat(right));
  });
  BinaryOperations.addOperator(">=", 7, function(left, right) {
    return Value.fromBool(Value.toFloat(left) >= Value.toFloat(right));
  });
  BinaryOperations.addOperator("<<", 8, function(left, right) {
    return Value.fromInt(Value.toInt(left) << Value.toInt(right));
  });
  BinaryOperations.addOperator(">>", 8, function(left, right) {
    return Value.fromInt(Value.toInt(left) >> Value.toInt(right));
  });
  BinaryOperations.addOperator(">>>", 8, function(left, right) {
    return Value.fromInt(Value.toInt(left) >>> Value.toInt(right));
  });
  BinaryOperations.addOperator("+", 9, function(left, right) {
    return Value.fromFloat(Value.toFloat(left) + Value.toFloat(right));
  });
  BinaryOperations.addOperator("-", 9, function(left, right) {
    return Value.fromFloat(Value.toFloat(left) - Value.toFloat(right));
  });
  BinaryOperations.addOperator("*", 10, function(left, right) {
    return Value.fromFloat(Value.toFloat(left) * Value.toFloat(right));
  });
  BinaryOperations.addOperator("/", 10, function(left, right) {
    return Value.fromFloat(Value.toFloat(left) / Value.toFloat(right));
  });
  BinaryOperations.addOperator("%", 10, function(left, right) {
    return Value.fromFloat(Value.toFloat(left) % Value.toFloat(right));
  });
  BinaryOperations.addOperator("**", 11, function(left, right) {
    return Value.fromFloat(Math.pow(Value.toFloat(left), Value.toFloat(right)));
  });
}

// bin/haxpression/Expression.js
var $global42 = Register.$global;
var Expression = Register.global("$hxClasses")["haxpression._Expression.Expression"] = class Expression2 {
  static fromExpressionType(expressionType) {
    return expressionType;
  }
  static toExpressionType(this1) {
    return this1;
  }
  static simplify(this1) {
    switch (this1._hx_index) {
      case 0:
        let value = this1.value;
        return Expression2.fromExpressionType(ExpressionType.ELiteral(value));
        break;
      case 1:
        let name = this1.name;
        return Expression2.fromExpressionType(ExpressionType.EIdentifier(name));
        break;
      case 2:
        let _operator = this1._operator;
        let operand = this1.operand;
        if (Expression2.canEvaluate(Expression2.fromExpressionType(operand))) {
          return Expression2.fromExpressionType(ExpressionType.ELiteral(Value.toValueType(UnaryOperations.evaluate(_operator, Expression2.evaluate(Expression2.fromExpressionType(operand))))));
        } else {
          return Expression2.fromExpressionType(ExpressionType.EUnary(_operator, Expression2.toExpressionType(Expression2.simplify(Expression2.fromExpressionType(operand)))));
        }
        ;
        break;
      case 3:
        let _operator1 = this1._operator;
        let left = this1.left;
        let right = this1.right;
        if (Expression2.canEvaluate(Expression2.fromExpressionType(left)) && Expression2.canEvaluate(Expression2.fromExpressionType(right))) {
          return Expression2.fromExpressionType(ExpressionType.ELiteral(Value.toValueType(BinaryOperations.evaluate(_operator1, Expression2.evaluate(Expression2.fromExpressionType(left)), Expression2.evaluate(Expression2.fromExpressionType(right))))));
        } else {
          return Expression2.fromExpressionType(ExpressionType.EBinary(_operator1, Expression2.toExpressionType(Expression2.simplify(Expression2.fromExpressionType(left))), Expression2.toExpressionType(Expression2.simplify(Expression2.fromExpressionType(right)))));
        }
        ;
        break;
      case 4:
        let callee = this1.callee;
        let $arguments = this1["arguments"];
        if (ExpressionTypes.canEvaluateAll($arguments)) {
          return Expression2.fromExpressionType(ExpressionType.ELiteral(Value.toValueType(CallOperations.evaluate(callee, ExpressionTypes.evaluate($arguments)))));
        } else {
          return Expression2.fromExpressionType(ExpressionType.ECall(callee, ExpressionTypes.simplify($arguments)));
        }
        ;
        break;
      case 5:
        let test = this1.test;
        let consequent = this1.consequent;
        let alternate = this1.alternate;
        if (Expression2.canEvaluate(Expression2.fromExpressionType(test))) {
          if (Value.toBool(Expression2.evaluate(Expression2.fromExpressionType(test)))) {
            return Expression2.simplify(Expression2.fromExpressionType(consequent));
          } else {
            return Expression2.simplify(Expression2.fromExpressionType(alternate));
          }
          ;
        } else {
          return Expression2.fromExpressionType(ExpressionType.EConditional(Expression2.toExpressionType(Expression2.simplify(Expression2.fromExpressionType(test))), Expression2.toExpressionType(Expression2.simplify(Expression2.fromExpressionType(consequent))), Expression2.toExpressionType(Expression2.simplify(Expression2.fromExpressionType(alternate)))));
        }
        ;
        break;
      case 6:
        let items = this1.items;
        return Expression2.fromExpressionType(ExpressionType.EArray(ExpressionTypes.simplify(items)));
        break;
      case 7:
        let items1 = this1.items;
        return Expression2.fromExpressionType(ExpressionType.ECompound(ExpressionTypes.simplify(items1)));
        break;
    }
    ;
  }
  static canEvaluate(this1) {
    switch (this1._hx_index) {
      case 0:
        let value = this1.value;
        return true;
        break;
      case 1:
        let name = this1.name;
        return false;
        break;
      case 2:
        let _operator = this1._operator;
        let operand = this1.operand;
        return Expression2.canEvaluate(Expression2.fromExpressionType(operand));
        break;
      case 3:
        let _operator1 = this1._operator;
        let left = this1.left;
        let right = this1.right;
        if (Expression2.canEvaluate(Expression2.fromExpressionType(left))) {
          return Expression2.canEvaluate(Expression2.fromExpressionType(right));
        } else {
          return false;
        }
        ;
        break;
      case 4:
        let callee = this1.callee;
        let $arguments = this1["arguments"];
        return CallOperations.canEvaluate(callee, $arguments);
        break;
      case 5:
        let test = this1.test;
        let consequent = this1.consequent;
        let alternate = this1.alternate;
        if (!Expression2.canEvaluate(Expression2.fromExpressionType(test))) {
          return false;
        } else if (Value.toBool(Expression2.evaluate(Expression2.fromExpressionType(test)))) {
          return Expression2.canEvaluate(Expression2.fromExpressionType(consequent));
        } else {
          return Expression2.canEvaluate(Expression2.fromExpressionType(alternate));
        }
        ;
        break;
      case 6:
        let items = this1.items;
        return ExpressionTypes.canEvaluateAll(items);
        break;
      case 7:
        let items1 = this1.items;
        return ExpressionTypes.canEvaluateAll(items1);
        break;
    }
    ;
  }
  static evaluate(this1, variables) {
    if (variables == null) {
      variables = new StringMap();
    }
    ;
    switch (this1._hx_index) {
      case 0:
        let value = this1.value;
        return Value.fromValueType(value);
        break;
      case 1:
        let name = this1.name;
        if (!variables.inst.has(name)) {
          throw Exception.thrown(new Error2("cannot evaluate expression with unset variable: " + name));
        }
        ;
        return variables.inst.get(name);
        break;
      case 2:
        let _operator = this1._operator;
        let operand = this1.operand;
        let operandValue = Expression2.evaluate(Expression2.fromExpressionType(operand), variables);
        return UnaryOperations.evaluate(_operator, operandValue);
        break;
      case 3:
        let _operator1 = this1._operator;
        let left = this1.left;
        let right = this1.right;
        let leftValue = Expression2.evaluate(Expression2.fromExpressionType(left), variables);
        let rightValue = Expression2.evaluate(Expression2.fromExpressionType(right), variables);
        return BinaryOperations.evaluate(_operator1, leftValue, rightValue);
        break;
      case 4:
        let callee = this1.callee;
        let $arguments = this1["arguments"];
        return CallOperations.evaluate(callee, ExpressionTypes.evaluate($arguments, variables));
        break;
      case 5:
        let test = this1.test;
        let consequent = this1.consequent;
        let alternate = this1.alternate;
        if (Value.toBool(Expression2.evaluate(Expression2.fromExpressionType(test), variables))) {
          return Expression2.evaluate(Expression2.fromExpressionType(consequent), variables);
        } else {
          return Expression2.evaluate(Expression2.fromExpressionType(alternate), variables);
        }
        ;
        break;
      case 6:
        let items = this1.items;
        if (items.length == 0) {
          return Value.fromValueType(ValueType.VNA);
        } else {
          let values = ExpressionTypes.evaluate(items, variables);
          return values[values.length - 1];
        }
        ;
        break;
      case 7:
        let items1 = this1.items;
        if (items1.length == 0) {
          return Value.fromValueType(ValueType.VNA);
        } else {
          let values = ExpressionTypes.evaluate(items1, variables);
          return values[values.length - 1];
        }
        ;
        break;
    }
    ;
  }
  static isCompound(this1) {
    let _g = Expression2.toExpressionType(this1);
    if (_g._hx_index == 7) {
      let _g1 = _g.items;
      return true;
    } else {
      return false;
    }
    ;
  }
  static get __name__() {
    return "haxpression._Expression.Expression_Impl_";
  }
  get __class__() {
    return Expression2;
  }
};

// bin/haxpression/Parser.js
var $global43 = Register.$global;
var Parser3 = Register.global("$hxClasses")["haxpression.Parser"] = class Parser4 extends Register.inherits() {
  new(inputString) {
    this.inputString = inputString;
    this.index = 0;
    this.length = inputString.length;
    this.expressions = [];
  }
  internalParse() {
    while (this.index < this.length) {
      let charCode = this.charCodeAt(this.index);
      if (charCode == Chars.SEMICOLON_CODE || charCode == Chars.COMMA_CODE) {
        this.index++;
      } else {
        let expression = this.gobbleExpression();
        if (expression != null) {
          this.expressions.push(expression);
        } else if (this.index < this.length) {
          throw Exception.thrown(new Error2('unexpected internal parse "' + this.charAt(this.index) + '"', this.inputString, this.index));
        }
        ;
      }
      ;
    }
    ;
    if (this.expressions.length == 1) {
      return this.expressions[0];
    } else {
      let _this = this.expressions;
      let result = new Array(_this.length);
      let _g = 0;
      let _g1 = _this.length;
      while (_g < _g1) {
        let i = _g++;
        result[i] = Expression.toExpressionType(_this[i]);
      }
      ;
      return Expression.fromExpressionType(ExpressionType.ECompound(result));
    }
    ;
  }
  charAt(index) {
    return this.inputString.charAt(index);
  }
  charCodeAt(index) {
    return HxOverrides.cca(this.inputString, index);
  }
  gobbleSpaces() {
    let charCode = this.charCodeAt(this.index);
    while (this.index < this.length && Chars.isWhiteSpace(charCode))
      charCode = this.charCodeAt(++this.index);
  }
  gobbleExpression() {
    let expression = this.gobbleBinaryExpression();
    this.gobbleSpaces();
    if (this.charCodeAt(this.index) == Chars.QUESTION_MARK_CODE) {
      this.index++;
      let consequent = this.gobbleExpression();
      if (consequent == null) {
        throw Exception.thrown(new Error2('expected a "consequent" expression for ternary conditional expression', this.inputString, this.index));
      }
      ;
      this.gobbleSpaces();
      if (this.charCodeAt(this.index) == Chars.COLON_CODE) {
        this.index++;
        let alternate = this.gobbleExpression();
        if (alternate == null) {
          throw Exception.thrown(new Error2('expected an "alternate" expression for ternary conditional expression', this.inputString, this.index));
        }
        ;
        return Expression.fromExpressionType(ExpressionType.EConditional(Expression.toExpressionType(expression), Expression.toExpressionType(consequent), Expression.toExpressionType(alternate)));
      }
      ;
    }
    ;
    return expression;
  }
  gobbleBinaryOperator() {
    this.gobbleSpaces();
    let toCheck = HxOverrides.substr(this.inputString, this.index, BinaryOperations.getMaxOperatorLength());
    let toCheckLength = toCheck.length;
    while (toCheckLength > 0) {
      if (BinaryOperations.hasOperator(toCheck)) {
        this.index += toCheckLength;
        return toCheck;
      }
      ;
      --toCheckLength;
      toCheck = HxOverrides.substr(toCheck, 0, toCheckLength);
    }
    ;
    return null;
  }
  gobbleBinaryExpression() {
    let $char;
    let expression;
    let binaryOperator;
    let precedence;
    let stack;
    let left;
    let right;
    let left1 = this.gobbleToken();
    let binaryOperator1 = this.gobbleBinaryOperator();
    if (binaryOperator1 == null) {
      return left1;
    }
    ;
    let binaryOperatorInfo = { "_operator": binaryOperator1, "precedence": BinaryOperations.getOperatorPrecedence(binaryOperator1) };
    let right1 = this.gobbleToken();
    if (right1 == null) {
      throw Exception.thrown(new Error2('expected expression after binary _operator: "' + binaryOperator1 + '"', this.inputString, this.index));
    }
    ;
    let stack1 = [left1, binaryOperatorInfo, right1];
    while (true) {
      binaryOperator1 = this.gobbleBinaryOperator();
      if (!(binaryOperator1 != null)) {
        break;
      }
      ;
      precedence = BinaryOperations.getOperatorPrecedence(binaryOperator1);
      if (precedence == 0) {
        break;
      }
      ;
      binaryOperatorInfo = { "_operator": binaryOperator1, "precedence": precedence };
      while (stack1.length > 2 && precedence <= stack1[stack1.length - 2].precedence) {
        right1 = stack1.pop();
        binaryOperator1 = stack1.pop()._operator;
        left1 = stack1.pop();
        let expression2 = ExpressionType.EBinary(binaryOperator1, Expression.toExpressionType(left1), Expression.toExpressionType(right1));
        stack1.push(expression2);
      }
      ;
      expression = this.gobbleToken();
      if (expression == null) {
        throw Exception.thrown(new Error2('expected expression after binary _operator: "' + binaryOperator1 + '"', this.inputString, this.index));
      }
      ;
      stack1.push(binaryOperatorInfo);
      stack1.push(expression);
    }
    ;
    let i = stack1.length - 1;
    expression = stack1[i];
    while (i > 1) {
      expression = Expression.fromExpressionType(ExpressionType.EBinary(stack1[i - 1]._operator, stack1[i - 2], Expression.toExpressionType(expression)));
      i -= 2;
    }
    ;
    return expression;
  }
  gobbleToken() {
    this.gobbleSpaces();
    let charCode = this.charCodeAt(this.index);
    if (Chars.isDecimalDigit(charCode) || charCode == Chars.PERIOD_CODE) {
      return this.gobbleNumericLiteral();
    } else if (charCode == Chars.SINGLE_QUOTE_CODE || charCode == Chars.DOUBLE_QUOTE_CODE) {
      return this.gobbleStringLiteral();
    } else if (Chars.isIdentifierStart(charCode) || charCode == Chars.OPEN_PAREN_CODE) {
      return this.gobbleVariable();
    } else if (charCode == Chars.OPEN_BRACKET_CODE) {
      return this.gobbleArray();
    } else {
      let toCheck = HxOverrides.substr(this.inputString, this.index, UnaryOperations.getMaxOperatorLength());
      let toCheckLength = toCheck.length;
      while (toCheckLength > 0) {
        if (UnaryOperations.hasOperator(toCheck)) {
          this.index += toCheckLength;
          return Expression.fromExpressionType(ExpressionType.EUnary(toCheck, Expression.toExpressionType(this.gobbleToken())));
        }
        ;
        --toCheckLength;
        toCheck = HxOverrides.substr(toCheck, 0, toCheckLength);
      }
      ;
      return null;
    }
    ;
  }
  gobbleNumericLiteral() {
    let numberString = "";
    while (this.index < this.length && Chars.isDecimalDigit(this.charCodeAt(this.index)))
      numberString += this.charAt(this.index++);
    if (this.charCodeAt(this.index) == Chars.PERIOD_CODE) {
      numberString += this.charAt(this.index++);
      while (this.index < this.length && Chars.isDecimalDigit(this.charCodeAt(this.index)))
        numberString += this.charAt(this.index++);
    }
    ;
    let $char = this.charAt(this.index);
    if ($char == "e" || $char == "E") {
      numberString += this.charAt(this.index++);
      $char = this.charAt(this.index);
      if ($char == "+" || $char == "-") {
        numberString += this.charAt(this.index++);
      }
      ;
      while (this.index < this.length && Chars.isDecimalDigit(this.charCodeAt(this.index)))
        numberString += this.charAt(this.index++);
      if (!Chars.isDecimalDigit(this.charCodeAt(this.index - 1))) {
        throw Exception.thrown(new Error2('expected exponent in numeric literal: "' + numberString + this.charAt(this.index) + '"', this.inputString, this.index));
      }
      ;
    }
    ;
    if (this.index >= this.length) {
      return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VFloat(parseFloat(numberString))));
    }
    ;
    let charCode = this.charCodeAt(this.index);
    if (Chars.isIdentifierStart(charCode)) {
      throw Exception.thrown(new Error2('variable names cannot start with a number: "' + numberString + this.charAt(this.index) + '"', this.inputString, this.index));
    } else if (charCode == Chars.PERIOD_CODE) {
      throw Exception.thrown(new Error2('unexpected period in numeric literal: "' + numberString + this.charAt(this.index) + '"', this.inputString, this.index));
    }
    ;
    return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VFloat(parseFloat(numberString))));
  }
  gobbleStringLiteral() {
    let str = "";
    let quote = this.charAt(this.index++);
    let closed = false;
    while (this.index < this.length) {
      let $char = this.charAt(this.index++);
      if ($char == quote) {
        closed = true;
        break;
      } else if ($char == "\\") {
        $char = this.charAt(this.index++);
        switch ($char) {
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "v":
            str += "\v";
            break;
        }
        ;
      } else {
        str += $char;
      }
      ;
    }
    ;
    if (!closed) {
      throw Exception.thrown(new Error2('unclosed quote after: "' + str + '"', this.inputString, this.index));
    }
    ;
    return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VString(str)));
  }
  gobbleIdentifier() {
    let charCode = this.charCodeAt(this.index);
    let start = this.index;
    if (Chars.isIdentifierStart(charCode)) {
      this.index++;
    } else {
      throw Exception.thrown(new Error2("unexpected " + this.charAt(this.index), this.inputString, this.index));
    }
    ;
    while (this.index < this.length) {
      charCode = this.charCodeAt(this.index);
      if (Chars.isIdentifierPart(charCode)) {
        this.index++;
      } else {
        break;
      }
      ;
    }
    ;
    let identifier = this.inputString.substring(start, this.index);
    switch (identifier.toLowerCase()) {
      case "false":
        return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VBool(false)));
        break;
      case "na":
        return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNA));
        break;
      case "nm":
        return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNM));
        break;
      case "null":
        return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNA));
        break;
      case "true":
        return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VBool(true)));
        break;
      case "undefined":
        return Expression.fromExpressionType(ExpressionType.ELiteral(ValueType.VNA));
        break;
      default:
        return Expression.fromExpressionType(ExpressionType.EIdentifier(identifier));
    }
    ;
  }
  gobbleArguments(terminationCharCode) {
    let expressions = [];
    let sawTermination = false;
    while (this.index < this.length) {
      this.gobbleSpaces();
      let charCode = this.charCodeAt(this.index);
      if (charCode == terminationCharCode) {
        sawTermination = true;
        this.index++;
        break;
      } else if (charCode == Chars.COMMA_CODE) {
        this.index++;
      } else {
        let expression = this.gobbleExpression();
        if (expression == null || Expression.isCompound(expression)) {
          throw Exception.thrown(new Error2("expected comma between arguments", this.inputString, this.index));
        }
        ;
        expressions.push(expression);
      }
      ;
    }
    ;
    if (!sawTermination) {
      let $char = String.fromCodePoint(terminationCharCode);
      throw Exception.thrown(new Error2('expected termination character: "' + $char + '"', this.inputString, this.index));
    }
    ;
    return expressions;
  }
  gobbleVariable() {
    let charCode = this.charCodeAt(this.index);
    let expression;
    if (charCode == Chars.OPEN_PAREN_CODE) {
      expression = this.gobbleGroup();
    } else {
      expression = this.gobbleIdentifier();
    }
    ;
    this.gobbleSpaces();
    if (this.index < this.length) {
      charCode = this.charCodeAt(this.index);
      while (this.index < this.length && (charCode == Chars.PERIOD_CODE || charCode == Chars.OPEN_BRACKET_CODE || charCode == Chars.OPEN_PAREN_CODE)) {
        this.index++;
        if (charCode == Chars.PERIOD_CODE) {
          throw Exception.thrown(new Error2('member access expressions like "a.b" are not supported', this.inputString, this.index));
        } else if (charCode == Chars.OPEN_BRACKET_CODE) {
          throw Exception.thrown(new Error2('member access expressions like "a["b"]" are not supported', this.inputString, this.index));
        } else if (charCode == Chars.OPEN_PAREN_CODE) {
          let callee;
          let _g = Expression.toExpressionType(expression);
          if (_g._hx_index == 1) {
            let name = _g.name;
            callee = name;
          } else {
            throw Exception.thrown(new Error2("expected function name identifier for function call expression", this.inputString, this.index));
          }
          ;
          let _this = this.gobbleArguments(Chars.CLOSE_PAREN_CODE);
          let result = new Array(_this.length);
          let _g1 = 0;
          let _g2 = _this.length;
          while (_g1 < _g2) {
            let i = _g1++;
            result[i] = Expression.toExpressionType(_this[i]);
          }
          ;
          let $arguments = result;
          expression = Expression.fromExpressionType(ExpressionType.ECall(callee, $arguments));
        }
        ;
        this.gobbleSpaces();
        charCode = this.charCodeAt(this.index);
      }
      ;
    }
    ;
    return expression;
  }
  gobbleGroup() {
    this.index++;
    let expression = this.gobbleExpression();
    if (this.charCodeAt(this.index) == Chars.CLOSE_PAREN_CODE) {
      this.index++;
      return expression;
    } else {
      throw Exception.thrown(new Error2("unclosed (", this.inputString, this.index));
    }
    ;
  }
  gobbleArray() {
    this.index++;
    let _this = this.gobbleArguments(Chars.CLOSE_BRACKET_CODE);
    let result = new Array(_this.length);
    let _g = 0;
    let _g1 = _this.length;
    while (_g < _g1) {
      let i = _g++;
      result[i] = Expression.toExpressionType(_this[i]);
    }
    ;
    let items = result;
    return Expression.fromExpressionType(ExpressionType.EArray(items));
  }
  static parse(input) {
    let parser = new Parser4(input);
    return parser.internalParse();
  }
  static get __name__() {
    return "haxpression.Parser";
  }
  get __class__() {
    return Parser4;
  }
};

// bin/mcl/McMath.js
var $global44 = Register.$global;
var FlattenedType = Register.global("$hxEnums")["mcl.FlattenedType"] = {
  __ename__: "mcl.FlattenedType",
  FLiteral: Object.assign((value) => ({ _hx_index: 0, __enum__: "mcl.FlattenedType", "value": value }), { _hx_name: "FLiteral", __params__: ["value"] }),
  FIdentifier: Object.assign((name) => ({ _hx_index: 1, __enum__: "mcl.FlattenedType", "name": name }), { _hx_name: "FIdentifier", __params__: ["name"] }),
  FUnary: Object.assign((operant, operand) => ({ _hx_index: 2, __enum__: "mcl.FlattenedType", "operant": operant, "operand": operand }), { _hx_name: "FUnary", __params__: ["operant", "operand"] }),
  FBinary: Object.assign((operant, left, right) => ({ _hx_index: 3, __enum__: "mcl.FlattenedType", "operant": operant, "left": left, "right": right }), { _hx_name: "FBinary", __params__: ["operant", "left", "right"] }),
  FAdd: Object.assign((item) => ({ _hx_index: 4, __enum__: "mcl.FlattenedType", "item": item }), { _hx_name: "FAdd", __params__: ["item"] }),
  FMul: Object.assign((item) => ({ _hx_index: 5, __enum__: "mcl.FlattenedType", "item": item }), { _hx_name: "FMul", __params__: ["item"] }),
  FCall: Object.assign((callee, args) => ({ _hx_index: 6, __enum__: "mcl.FlattenedType", "callee": callee, "args": args }), { _hx_name: "FCall", __params__: ["callee", "args"] }),
  FConditional: Object.assign((test, consequent, alternate) => ({ _hx_index: 7, __enum__: "mcl.FlattenedType", "test": test, "consequent": consequent, "alternate": alternate }), { _hx_name: "FConditional", __params__: ["test", "consequent", "alternate"] }),
  FArray: Object.assign((items) => ({ _hx_index: 8, __enum__: "mcl.FlattenedType", "items": items }), { _hx_name: "FArray", __params__: ["items"] }),
  FCompound: Object.assign((items) => ({ _hx_index: 9, __enum__: "mcl.FlattenedType", "items": items }), { _hx_name: "FCompound", __params__: ["items"] })
};
FlattenedType.__constructs__ = [FlattenedType.FLiteral, FlattenedType.FIdentifier, FlattenedType.FUnary, FlattenedType.FBinary, FlattenedType.FAdd, FlattenedType.FMul, FlattenedType.FCall, FlattenedType.FConditional, FlattenedType.FArray, FlattenedType.FCompound];
FlattenedType.__empty_constructs__ = [];
var McMath = Register.global("$hxClasses")["mcl.McMath"] = class McMath2 {
  static flatten(exp) {
    switch (exp._hx_index) {
      case 0:
        let value = exp.value;
        return FlattenedType.FLiteral(value);
        break;
      case 1:
        let name = exp.name;
        return FlattenedType.FIdentifier(name);
        break;
      case 2:
        let operant = exp._operator;
        let operand = exp.operand;
        return FlattenedType.FUnary(operant, McMath2.flatten(operand));
        break;
      case 3:
        let operant1 = exp._operator;
        let left = exp.left;
        let right = exp.right;
        if (operant1 == "+") {
          let entries = new Array();
          let literals = 0;
          let flattenAdd = null;
          flattenAdd = function(exp2) {
            switch (exp2._hx_index) {
              case 0:
                let value2 = exp2.value;
                switch (value2._hx_index) {
                  case 0:
                    let v = value2.v;
                    if (v == Math.floor(v)) {
                      literals += Math.floor(v);
                    } else {
                      entries.push(McMath2.flatten(exp2));
                    }
                    ;
                    break;
                  case 1:
                    let v1 = value2.v;
                    literals += v1;
                    break;
                  default:
                    entries.push(McMath2.flatten(exp2));
                }
                ;
                break;
              case 3:
                if (exp2._operator == "+") {
                  let left2 = exp2.left;
                  let right2 = exp2.right;
                  flattenAdd(left2);
                  flattenAdd(right2);
                } else {
                  entries.push(McMath2.flatten(exp2));
                }
                ;
                break;
              default:
                entries.push(McMath2.flatten(exp2));
            }
            ;
          };
          flattenAdd(exp);
          if (literals != 0) {
            entries.push(FlattenedType.FLiteral(ValueType.VInt(literals)));
          }
          ;
          return FlattenedType.FAdd(entries);
        }
        ;
        if (operant1 == "*") {
          let entries = new Array();
          let literals = 1;
          let flattenMul = null;
          flattenMul = function(exp2) {
            switch (exp2._hx_index) {
              case 0:
                let value2 = exp2.value;
                switch (value2._hx_index) {
                  case 0:
                    let v = value2.v;
                    if (v == Math.floor(v)) {
                      literals *= Math.floor(v);
                    } else {
                      entries.push(McMath2.flatten(exp2));
                    }
                    ;
                    break;
                  case 1:
                    let v1 = value2.v;
                    literals *= v1;
                    break;
                  default:
                    entries.push(McMath2.flatten(exp2));
                }
                ;
                break;
              case 3:
                if (exp2._operator == "*") {
                  let left2 = exp2.left;
                  let right2 = exp2.right;
                  flattenMul(left2);
                  flattenMul(right2);
                } else {
                  entries.push(McMath2.flatten(exp2));
                }
                ;
                break;
              default:
                entries.push(McMath2.flatten(exp2));
            }
            ;
          };
          flattenMul(exp);
          if (literals != 1) {
            entries.push(FlattenedType.FLiteral(ValueType.VInt(literals)));
          }
          ;
          return FlattenedType.FMul(entries);
        }
        ;
        return FlattenedType.FBinary(operant1, McMath2.flatten(left), McMath2.flatten(right));
        break;
      case 4:
        let callee = exp.callee;
        let args = exp["arguments"];
        let f = McMath2.flatten;
        let result = new Array(args.length);
        let _g = 0;
        let _g1 = args.length;
        while (_g < _g1) {
          let i = _g++;
          result[i] = f(args[i]);
        }
        ;
        return FlattenedType.FCall(callee, result);
        break;
      case 5:
        let test = exp.test;
        let consequent = exp.consequent;
        let alternate = exp.alternate;
        return FlattenedType.FConditional(McMath2.flatten(test), McMath2.flatten(consequent), McMath2.flatten(alternate));
        break;
      case 6:
        let items = exp.items;
        let f1 = McMath2.flatten;
        let result1 = new Array(items.length);
        let _g2 = 0;
        let _g3 = items.length;
        while (_g2 < _g3) {
          let i = _g2++;
          result1[i] = f1(items[i]);
        }
        ;
        return FlattenedType.FArray(result1);
        break;
      case 7:
        let items1 = exp.items;
        let f2 = McMath2.flatten;
        let result2 = new Array(items1.length);
        let _g4 = 0;
        let _g5 = items1.length;
        while (_g4 < _g5) {
          let i = _g4++;
          result2[i] = f2(items1[i]);
        }
        ;
        return FlattenedType.FCompound(result2);
        break;
    }
    ;
  }
  static organize(exp) {
    switch (exp._hx_index) {
      case 0:
        let value = exp.value;
        switch (value._hx_index) {
          case 0:
            let v = value.v;
            return ExpressionType.ELiteral(ValueType.VFloat(v));
            break;
          case 1:
            let v1 = value.v;
            return ExpressionType.ELiteral(ValueType.VInt(v1));
            break;
          case 2:
            let v2 = value.v;
            return ExpressionType.ELiteral(ValueType.VBool(v2));
            break;
          case 3:
            let v3 = value.v;
            return ExpressionType.ELiteral(ValueType.VString(v3));
            break;
          default:
            throw Exception.thrown("unsupported literal");
        }
        ;
        break;
      case 1:
        let name = exp.name;
        return ExpressionType.EIdentifier(name);
        break;
      case 2:
        let operant = exp._operator;
        let operand = exp.operand;
        return ExpressionType.EUnary(operant, McMath2.organize(operand));
        break;
      case 3:
        let _g = exp._operator;
        let _g1 = exp.left;
        let _g2 = exp.right;
        if (_g1._hx_index == 0) {
          let a = _g1.value;
          let operant2 = _g;
          let right = _g2;
          let v;
          switch (a._hx_index) {
            case 0:
              let v1 = a.v;
              if (v1 == Math.floor(v1)) {
                v = Math.floor(v1);
              } else {
                return ExpressionType.EBinary(operant2, ExpressionType.ELiteral(a), McMath2.organize(right));
              }
              ;
              break;
            case 1:
              let v2 = a.v;
              v = v2;
              break;
            default:
              return ExpressionType.EBinary(operant2, ExpressionType.ELiteral(a), McMath2.organize(right));
          }
          ;
          if (operant2 == "+") {
            return ExpressionType.EBinary(operant2, McMath2.organize(right), ExpressionType.ELiteral(ValueType.VInt(v)));
          }
          ;
          if (operant2 == "-") {
            return ExpressionType.EBinary("+", McMath2.organize(right), ExpressionType.ELiteral(ValueType.VInt(-v)));
          }
          ;
          if (operant2 == "*") {
            return ExpressionType.EBinary(operant2, McMath2.organize(right), ExpressionType.ELiteral(ValueType.VInt(v)));
          }
          ;
          return ExpressionType.EBinary(operant2, ExpressionType.ELiteral(a), McMath2.organize(right));
        } else if (_g == "-") {
          if (_g2._hx_index == 0) {
            let left = _g1;
            let value2 = _g2.value;
            let v;
            switch (value2._hx_index) {
              case 0:
                let v1 = value2.v;
                if (v1 == Math.floor(v1)) {
                  v = Math.floor(v1);
                } else {
                  return ExpressionType.EBinary("-", McMath2.organize(left), ExpressionType.ELiteral(value2));
                }
                ;
                break;
              case 1:
                let v2 = value2.v;
                v = v2;
                break;
              default:
                return ExpressionType.EBinary("-", McMath2.organize(left), ExpressionType.ELiteral(value2));
            }
            ;
            return ExpressionType.EBinary("+", McMath2.organize(left), ExpressionType.ELiteral(ValueType.VInt(-v)));
          } else {
            let left = _g1;
            let operant2 = _g;
            let right = _g2;
            return ExpressionType.EBinary(operant2, McMath2.organize(left), McMath2.organize(right));
          }
          ;
        } else {
          let left = _g1;
          let operant2 = _g;
          let right = _g2;
          return ExpressionType.EBinary(operant2, McMath2.organize(left), McMath2.organize(right));
        }
        ;
        break;
      case 4:
        let name1 = exp.callee;
        let args = exp["arguments"];
        let f = McMath2.organize;
        let result = new Array(args.length);
        let _g3 = 0;
        let _g4 = args.length;
        while (_g3 < _g4) {
          let i = _g3++;
          result[i] = f(args[i]);
        }
        ;
        return ExpressionType.ECall(name1, result);
        break;
      case 5:
        let test = exp.test;
        let consequent = exp.consequent;
        let alternate = exp.alternate;
        return ExpressionType.EConditional(McMath2.organize(test), McMath2.organize(consequent), McMath2.organize(alternate));
        break;
      case 6:
        let items = exp.items;
        let f1 = McMath2.organize;
        let result1 = new Array(items.length);
        let _g5 = 0;
        let _g6 = items.length;
        while (_g5 < _g6) {
          let i = _g5++;
          result1[i] = f1(items[i]);
        }
        ;
        return ExpressionType.EArray(result1);
        break;
      case 7:
        let items1 = exp.items;
        let f2 = McMath2.organize;
        let result2 = new Array(items1.length);
        let _g7 = 0;
        let _g8 = items1.length;
        while (_g7 < _g8) {
          let i = _g7++;
          result2[i] = f2(items1[i]);
        }
        ;
        return ExpressionType.ECompound(result2);
        break;
    }
    ;
  }
  static compile(eq, context) {
    let _g = 0;
    let _g1 = eq.length;
    while (_g < _g1) {
      let i = _g++;
      if (eq.charAt(i) == "@" && eq.charAt(i + 1) != "s" && eq.charAt(i + 2) != "[") {
        throw Exception.thrown("only unrestricted @s selectors are allowed in equations to avoid unexpected behavior.");
      }
      ;
    }
    ;
    let skip = function() {
      let idx2 = 0;
      while (eq.charAt(idx2) == " " && idx2 < eq.length)
        ++idx2;
      eq = eq.substring(idx2);
    };
    let collect = function() {
      let value = "";
      let idx2 = 0;
      while (eq.charAt(idx2) != " " && idx2 < eq.length) {
        value += eq.charAt(idx2);
        ++idx2;
      }
      ;
      eq = eq.substring(idx2);
      return value;
    };
    let lhs = collect();
    skip();
    lhs += " " + collect();
    skip();
    let sep = collect();
    skip();
    let rhs = eq;
    let variables = new StringMap();
    let idx = 0;
    let isAlphaNumeric = function(c) {
      let code = c.charCodeAt(0);
      if (!(code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code == 46 || code == 95 || code == 36 || code == 35)) {
        return code == 64;
      } else {
        return true;
      }
      ;
    };
    let varnameIdx = 0;
    let getNextVarName = function() {
      varnameIdx += 1;
      return "var" + varnameIdx;
    };
    let newEquation = "";
    while (idx < rhs.length) {
      let c = rhs.charAt(idx);
      let code = HxOverrides.cca(c, 0);
      if (code == 64 || code >= 97 && code <= 122 || code >= 65 && code <= 90) {
        let name = "";
        while (idx < rhs.length && isAlphaNumeric(rhs.charAt(idx))) {
          name += rhs.charAt(idx);
          ++idx;
        }
        ;
        ++idx;
        name += " ";
        while (idx < rhs.length && isAlphaNumeric(rhs.charAt(idx))) {
          name += rhs.charAt(idx);
          ++idx;
        }
        ;
        if (!variables.inst.has(name)) {
          let value = getNextVarName();
          variables.inst.set(name, value);
        }
        ;
        newEquation += variables.inst.get(name);
      } else {
        newEquation += c;
        ++idx;
      }
      ;
    }
    ;
    let x = McMath2.flatten(McMath2.organize(Expression.toExpressionType(Expression.simplify(Parser3.parse(newEquation)))));
    let _g2 = new StringMap();
    let map = variables;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      _g2.inst.set(v, k);
    }
    ;
    return McMath2.render(x, lhs, _g2, sep, context);
  }
  static render(x, result, variables, finalOp, context) {
    let commands = [];
    let idx = 0;
    let unsafeToModify_inst = /* @__PURE__ */ new Map();
    let $const = context.compiler.config.eqConstScoreboardName;
    let temp = context.compiler.config.eqVarScoreboardName;
    let constantValues_inst = /* @__PURE__ */ new Map();
    let c = function(v, remove) {
      if (remove == null) {
        remove = false;
      }
      ;
      if (remove) {
        let count = constantValues_inst.get(v);
        --count;
        if (count <= 0) {
          constantValues_inst["delete"](v);
        } else {
          constantValues_inst.set(v, count);
        }
        ;
      } else {
        let count = constantValues_inst.get(v);
        if (count == null) {
          count = 1;
        } else {
          ++count;
        }
        ;
        constantValues_inst.set(v, count);
      }
      ;
    };
    let map = variables;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k2 = _g_key;
      let v = _g_value;
      unsafeToModify_inst.set(v, true);
    }
    ;
    let isSafeToModify = function(s) {
      if (unsafeToModify_inst.has(s)) {
        return false;
      }
      ;
      if (s.endsWith(" " + $const)) {
        return false;
      }
      ;
      return true;
    };
    let mkTemp = function(from, alt) {
      if (alt != null && isSafeToModify(alt)) {
        commands.push("scoreboard players operation " + alt + " = " + from);
        return alt;
      }
      ;
      idx += 1;
      let id = "tmp" + (idx - 1) + " " + temp;
      if (from.endsWith(" " + $const)) {
        c(Std.parseInt(from.substring(0, from.length - 6)), true);
        commands.push("scoreboard players set " + id + " " + from.substring(0, from.length - 6));
      } else {
        commands.push("scoreboard players operation " + id + " = " + from);
      }
      ;
      return id;
    };
    let makeSafe = function(v, alt) {
      if (isSafeToModify(v)) {
        return v;
      }
      ;
      return mkTemp(v, alt);
    };
    let isConstant = function(v) {
      if (v._hx_index == 0) {
        let _g2 = v.value;
        return true;
      } else {
        return false;
      }
      ;
    };
    let isVariable = function(v) {
      if (v._hx_index == 1) {
        let _g2 = v.name;
        return true;
      } else {
        return false;
      }
      ;
    };
    let getVariable = function(v) {
      if (v._hx_index == 1) {
        let name = v.name;
        return variables.inst.get(name);
      } else {
        throw Exception.thrown("not a variable");
      }
      ;
    };
    let getValue = function(v) {
      if (v._hx_index == 0) {
        let value = v.value;
        switch (value._hx_index) {
          case 0:
            let v1 = value.v;
            return v1;
            break;
          case 1:
            let v2 = value.v;
            return v2;
            break;
          default:
            throw Exception.thrown("unsupported literal");
        }
        ;
      }
      ;
      throw Exception.thrown("not a constant");
    };
    let getConstant = function(v) {
      let val = Math.floor(getValue(v));
      c(val);
      return "" + val + " " + $const;
    };
    let renderNode = null;
    renderNode = function(node, output) {
      switch (node._hx_index) {
        case 0:
          let id = node.value;
          switch (id._hx_index) {
            case 0:
              let v = id.v;
              c(Math.floor(v));
              return "" + Math.floor(v) + " " + $const;
              break;
            case 1:
              let v1 = id.v;
              c(v1);
              return "" + v1 + " " + $const;
              break;
            default:
              throw Exception.thrown("unsupported literal");
          }
          ;
          break;
        case 1:
          let id1 = node.name;
          throw Exception.thrown("NO NO NO NO NO2");
          break;
        case 2:
          let operant = node.operant;
          let operand = node.operand;
          let l = isVariable(operand) ? makeSafe(getVariable(operand), output) : isConstant(operand) ? makeSafe(getConstant(operand), output) : renderNode(operand, output);
          if (operant == "-") {
            let r2 = makeSafe(l);
            c(-1);
            commands.push("scoreboard players operation " + r2 + " *= -1 " + $const);
            return r2;
          }
          ;
          return l;
          break;
        case 3:
          let operant1 = node.operant;
          let left = node.left;
          let right = node.right;
          let l1 = isVariable(left) ? makeSafe(getVariable(left), output) : isConstant(left) ? makeSafe(getConstant(left), output) : renderNode(left, output);
          let r = isVariable(right) ? getVariable(right) : isConstant(right) ? getConstant(right) : renderNode(right, null);
          commands.push("scoreboard players operation " + l1 + " " + operant1 + "= " + r);
          return l1;
          break;
        case 4:
          let items = node.item;
          let l2 = isVariable(items[0]) ? makeSafe(getVariable(items[0]), output) : isConstant(items[0]) ? makeSafe(getConstant(items[0]), output) : renderNode(items[0], output);
          let _g2 = 1;
          let _g1 = items.length;
          while (_g2 < _g1) {
            let i = _g2++;
            if (isVariable(items[i])) {
              commands.push("scoreboard players operation " + l2 + " += " + getVariable(items[i]));
            } else if (isConstant(items[i])) {
              let v = getValue(items[i]);
              if (v > 0) {
                commands.push("scoreboard players add " + l2 + " " + v);
              } else if (v < 0) {
                commands.push("scoreboard players remove " + l2 + " " + -v);
              }
              ;
            } else {
              let r2 = renderNode(items[i], null);
              commands.push("scoreboard players operation " + l2 + " += " + r2);
            }
            ;
          }
          ;
          return l2;
          break;
        case 5:
          let items1 = node.item;
          let l3 = isVariable(items1[0]) ? makeSafe(getVariable(items1[0]), output) : isConstant(items1[0]) ? makeSafe(getConstant(items1[0]), output) : renderNode(items1[0], output);
          let _g22 = 1;
          let _g3 = items1.length;
          while (_g22 < _g3) {
            let i = _g22++;
            let r2 = isVariable(items1[i]) ? getVariable(items1[i]) : isConstant(items1[i]) ? getConstant(items1[i]) : renderNode(items1[i], null);
            commands.push("scoreboard players operation " + l3 + " *= " + r2);
          }
          ;
          return l3;
          break;
        case 6:
          let callee = node.callee;
          let args = node.args;
          throw Exception.thrown("unsupported call");
          break;
        case 7:
          let test = node.test;
          let consequent = node.consequent;
          let alternate = node.alternate;
          throw Exception.thrown("unsupported conditional");
          break;
        case 8:
          let items2 = node.items;
          throw Exception.thrown("unsupported array");
          break;
        case 9:
          let items3 = node.items;
          throw Exception.thrown("unsupported compound");
          break;
      }
      ;
    };
    if (isConstant(x) && finalOp == "=") {
      commands.push("scoreboard players set " + result + " " + getValue(x));
    } else if (isVariable(x)) {
      commands.push("scoreboard players operation " + result + " " + finalOp + " " + getVariable(x));
    } else {
      let stored = renderNode(x, result);
      if (result != stored) {
        commands.push("scoreboard players operation " + result + " " + finalOp + " " + stored);
      }
      ;
    }
    ;
    let tmp = commands.join("\n");
    let _g = [];
    let k = EsMap.adaptIterator(constantValues_inst.keys());
    while (k.hasNext()) {
      let k1 = k.next();
      _g.push(k1);
    }
    ;
    return { "commands": tmp, "constants": _g };
  }
  static get __name__() {
    return "mcl.McMath";
  }
  get __class__() {
    return McMath2;
  }
};

// bin/haxe/iterators/ArrayIterator.js
var $global45 = Register.$global;
var ArrayIterator3 = Register.global("$hxClasses")["haxe.iterators.ArrayIterator"] = class ArrayIterator4 extends Register.inherits() {
  new(array) {
    this.current = 0;
    this.array = array;
  }
  /**
  See `Iterator.hasNext`
  */
  hasNext() {
    return this.current < this.array.length;
  }
  /**
  See `Iterator.next`
  */
  next() {
    return this.array[this.current++];
  }
  static get __name__() {
    return "haxe.iterators.ArrayIterator";
  }
  get __class__() {
    return ArrayIterator4;
  }
};

// bin/haxe/ds/ObjectMap.js
var $global46 = Register.$global;
var ObjectMap = Register.global("$hxClasses")["haxe.ds.ObjectMap"] = class ObjectMap2 extends Register.inherits(EsMap) {
  new() {
    super.new();
  }
  static get __name__() {
    return "haxe.ds.ObjectMap";
  }
  static get __interfaces__() {
    return [IMap];
  }
  static get __super__() {
    return EsMap;
  }
  get __class__() {
    return ObjectMap2;
  }
};

// bin/Type.js
var $global47 = Register.$global;
var ValueType2 = Register.global("$hxEnums")["ValueType"] = {
  __ename__: "ValueType",
  TNull: { _hx_name: "TNull", _hx_index: 0, __enum__: "ValueType" },
  TInt: { _hx_name: "TInt", _hx_index: 1, __enum__: "ValueType" },
  TFloat: { _hx_name: "TFloat", _hx_index: 2, __enum__: "ValueType" },
  TBool: { _hx_name: "TBool", _hx_index: 3, __enum__: "ValueType" },
  TObject: { _hx_name: "TObject", _hx_index: 4, __enum__: "ValueType" },
  TFunction: { _hx_name: "TFunction", _hx_index: 5, __enum__: "ValueType" },
  TClass: Object.assign((c) => ({ _hx_index: 6, __enum__: "ValueType", "c": c }), { _hx_name: "TClass", __params__: ["c"] }),
  TEnum: Object.assign((e) => ({ _hx_index: 7, __enum__: "ValueType", "e": e }), { _hx_name: "TEnum", __params__: ["e"] }),
  TUnknown: { _hx_name: "TUnknown", _hx_index: 8, __enum__: "ValueType" }
};
ValueType2.__constructs__ = [ValueType2.TNull, ValueType2.TInt, ValueType2.TFloat, ValueType2.TBool, ValueType2.TObject, ValueType2.TFunction, ValueType2.TClass, ValueType2.TEnum, ValueType2.TUnknown];
ValueType2.__empty_constructs__ = [ValueType2.TNull, ValueType2.TInt, ValueType2.TFloat, ValueType2.TBool, ValueType2.TObject, ValueType2.TFunction, ValueType2.TUnknown];
var Type = Register.global("$hxClasses")["Type"] = class Type2 {
  /**
  Creates an instance of class `cl`, using `args` as arguments to the
  class constructor.
  
  This function guarantees that the class constructor is called.
  
  Default values of constructors arguments are not guaranteed to be
  taken into account.
  
  If `cl` or `args` are null, or if the number of elements in `args` does
  not match the expected number of constructor arguments, or if any
  argument has an invalid type,  or if `cl` has no own constructor, the
  result is unspecified.
  
  In particular, default values of constructor arguments are not
  guaranteed to be taken into account.
  */
  static createInstance(cl, args) {
    let ctor = Function.prototype.bind.apply(cl, [null].concat(args));
    return new ctor();
  }
  /**
  Creates an instance of enum `e` by calling its constructor `constr` with
  arguments `params`.
  
  If `e` or `constr` is null, or if enum `e` has no constructor named
  `constr`, or if the number of elements in `params` does not match the
  expected number of constructor arguments, or if any argument has an
  invalid type, the result is unspecified.
  */
  static createEnum(e, constr, params) {
    let f = Reflect2.field(e, constr);
    if (f == null) {
      throw Exception.thrown("No such constructor " + constr);
    }
    ;
    if (Reflect2.isFunction(f)) {
      if (params == null) {
        throw Exception.thrown("Constructor " + constr + " need parameters");
      }
      ;
      return f.apply(e, params);
    }
    ;
    if (params != null && params.length != 0) {
      throw Exception.thrown("Constructor " + constr + " does not need parameters");
    }
    ;
    return f;
  }
  /**
  Returns the runtime type of value `v`.
  
  The result corresponds to the type `v` has at runtime, which may vary
  per platform. Assumptions regarding this should be minimized to avoid
  surprises.
  */
  static typeof(v) {
    switch (typeof v) {
      case "boolean":
        return ValueType2.TBool;
        break;
      case "function":
        if (v.__name__ || v.__ename__) {
          return ValueType2.TObject;
        }
        ;
        return ValueType2.TFunction;
        break;
      case "number":
        if (Math.ceil(v) == v % 2147483648) {
          return ValueType2.TInt;
        }
        ;
        return ValueType2.TFloat;
        break;
      case "object":
        if (v == null) {
          return ValueType2.TNull;
        }
        ;
        let e = v.__enum__;
        if (e != null) {
          return ValueType2.TEnum(Register.global("$hxEnums")[e]);
        }
        ;
        let c = Boot.getClass(v);
        if (c != null) {
          return ValueType2.TClass(c);
        }
        ;
        return ValueType2.TObject;
        break;
      case "string":
        return ValueType2.TClass(String);
        break;
      case "undefined":
        return ValueType2.TNull;
        break;
      default:
        return ValueType2.TUnknown;
    }
    ;
  }
  /**
  Recursively compares two enum instances `a` and `b` by value.
  
  Unlike `a == b`, this function performs a deep equality check on the
  arguments of the constructors, if exists.
  
  If `a` or `b` are null, the result is unspecified.
  */
  static enumEq(a, b) {
    if (a == b) {
      return true;
    }
    ;
    try {
      let e = a.__enum__;
      if (e == null || e != b.__enum__) {
        return false;
      }
      ;
      if (a._hx_index != b._hx_index) {
        return false;
      }
      ;
      let enm = Register.global("$hxEnums")[e];
      let params = enm.__constructs__[a._hx_index].__params__;
      let _g = 0;
      while (_g < params.length) {
        let f = params[_g];
        ++_g;
        if (!Type2.enumEq(a[f], b[f])) {
          return false;
        }
        ;
      }
      ;
    } catch (_g) {
      return false;
    }
    ;
    return true;
  }
  static get __name__() {
    return "Type";
  }
  get __class__() {
    return Type2;
  }
};

// bin/mcl/Globals.js
var $global48 = Register.$global;
var McIntIterator = Register.global("$hxClasses")["mcl.McIntIterator"] = class McIntIterator2 extends Register.inherits() {
  new(min, max) {
    this.min = min;
    this.max = max;
    this.current = min;
    this.offset = min < max ? 1 : -1;
  }
  hasNext() {
    if (this.offset == 1) {
      return this.current <= this.max;
    } else {
      return this.current >= this.max;
    }
    ;
  }
  next() {
    let result = this.current;
    if (!this.hasNext()) {
      throw Exception.thrown("No such element");
    }
    ;
    this.current += this.offset;
    return result;
  }
  static get __name__() {
    return "mcl.McIntIterator";
  }
  get __class__() {
    return McIntIterator2;
  }
};
var McFloatIterator = Register.global("$hxClasses")["mcl.McFloatIterator"] = class McFloatIterator2 extends Register.inherits() {
  new(min, max, step) {
    this.min = min;
    this.max = max;
    this.current = min;
    this.offset = step;
    if (step < 0 && min < max) {
      throw Exception.thrown("Invalid step for range");
    }
    ;
    if (step > 0 && min > max) {
      throw Exception.thrown("Invalid step for range");
    }
    ;
  }
  hasNext() {
    if (this.offset > 0) {
      return this.current <= this.max;
    } else {
      return this.current >= this.max;
    }
    ;
  }
  next() {
    let result = this.current;
    if (!this.hasNext()) {
      throw Exception.thrown("No such element");
    }
    ;
    this.current += this.offset;
    return result;
  }
  static get __name__() {
    return "mcl.McFloatIterator";
  }
  get __class__() {
    return McFloatIterator2;
  }
};
var Globals = Register.global("$hxClasses")["mcl.Globals"] = class Globals2 {
  static set(name, value) {
    Globals2.map.inst.set(name, value);
  }
  static get(name) {
    return Globals2.map.inst.get(name);
  }
  static has(name) {
    return Globals2.map.inst.has(name);
  }
  static delete(name) {
    return Globals2.map.inst["delete"](name);
  }
  static get __name__() {
    return "mcl.Globals";
  }
  get __class__() {
    return Globals2;
  }
};
Globals.loopVariants = function($this) {
  var $r0;
  let _g = new ObjectMap();
  _g.inst.set([ValueType2.TInt, ValueType2.TInt], function(args) {
    let min = args[0];
    let max = args[1];
    return new McIntIterator(min, max);
  });
  _g.inst.set([ValueType2.TFloat, ValueType2.TFloat, ValueType2.TFloat], function(args) {
    let min = args[0];
    let max = args[1];
    let step = args[2];
    return new McFloatIterator(min, max, step);
  });
  _g.inst.set([ValueType2.TClass(Array)], function(args) {
    return new ArrayIterator3(args[0]);
  });
  _g.inst.set([ValueType2.TObject], function(args) {
    let iterator = new ArrayIterator3(Object.entries(args[0]));
    return iterator;
  });
  _g.inst.set([ValueType2.TFunction], function(args) {
    let iterator = args[0];
    return new ArrayIterator3(Array.from(iterator()));
  });
  $r0 = _g;
  return $r0;
}(void 0);
Globals.map = function($this) {
  var $r0;
  let _g = new StringMap();
  _g.inst.set("REPEAT", function(...args) {
    let argCount = args.length;
    let map = Globals.loopVariants;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let overlod = _g_key;
      let handler = _g_value;
      if (overlod.length == argCount) {
        let failure = false;
        let _g3 = 0;
        let _g12 = argCount;
        while (_g3 < _g12) {
          let i = _g3++;
          let t = Type["typeof"](args[i]);
          if (!(Type.enumEq(overlod[i], t) || overlod[i] == ValueType2.TFloat && t == ValueType2.TInt)) {
            failure = true;
            break;
          }
          ;
        }
        ;
        if (!failure) {
          return handler(args.slice());
        }
        ;
      }
      ;
    }
    ;
    let _this = args.slice();
    let result = new Array(_this.length);
    let _g2 = 0;
    let _g1 = _this.length;
    while (_g2 < _g1) {
      let i = _g2++;
      result[i] = Std.string(Type["typeof"](_this[i]));
    }
    ;
    throw Exception.thrown("Invalid arguments for REPEAT (" + result.join(", ") + ")");
  });
  $r0 = _g;
  return $r0;
}(void 0);

// bin/haxe/ds/IntMap.js
var $global49 = Register.$global;
var IntMap = Register.global("$hxClasses")["haxe.ds.IntMap"] = class IntMap2 extends Register.inherits(EsMap) {
  new() {
    super.new();
  }
  static get __name__() {
    return "haxe.ds.IntMap";
  }
  static get __interfaces__() {
    return [IMap];
  }
  static get __super__() {
    return EsMap;
  }
  get __class__() {
    return IntMap2;
  }
};

// bin/mcl/FeatureFlags.js
var $global50 = Register.$global;
var FeatureFlags = Register.global("$hxClasses")["mcl.FeatureFlags"] = class FeatureFlags2 extends Register.inherits() {
  new() {
    this.useFolderRenames48 = false;
  }
  apply(version, overrides) {
    let _g = [];
    let map = FeatureFlags2.flags;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let _ = _g_value;
      _g.push(k);
    }
    ;
    let ids = _g;
    ids.sort(function(a, b) {
      return a - b;
    });
    let _g1 = 0;
    while (_g1 < ids.length) {
      let id = ids[_g1];
      ++_g1;
      if (version < id) {
        return;
      }
      ;
      let flag = FeatureFlags2.flags.inst.get(id);
      if (flag.useFolderRenames48 != null) {
        this.useFolderRenames48 = flag.useFolderRenames48;
      }
      ;
    }
    ;
    if (overrides != null) {
      if (overrides.useFolderRenames48 != null) {
        this.useFolderRenames48 = overrides.useFolderRenames48;
      }
      ;
    }
    ;
    Object.freeze(this);
  }
  static get __name__() {
    return "mcl.FeatureFlags";
  }
  get __class__() {
    return FeatureFlags2;
  }
};
FeatureFlags.flags = function($this) {
  var $r0;
  let _g = new IntMap();
  _g.inst.set(48, { "useFolderRenames48": true });
  _g.inst.set(0, { "useFolderRenames43": false, "useFolderRenames48": false });
  $r0 = _g;
  return $r0;
}(void 0);

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require("node:process"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_node_tty = __toESM(require("node:tty"), 1);
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process.default;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_node_process.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// bin/mcb/Logger.js
var $global51 = Register.$global;
var Logger = Register.global("$hxClasses")["mcb.Logger"] = class Logger2 {
  static log(msg) {
    if (Logger2.enabled) {
      let v = Logger2.prefix + Logger2.chalk.white(msg);
      process.stdout.write(Std.string(v));
      process.stdout.write("\n");
    }
    ;
  }
  static error(msg) {
    if (Logger2.enabled) {
      let v = Logger2.prefix + Logger2.chalk.redBright(msg);
      process.stdout.write(Std.string(v));
      process.stdout.write("\n");
    }
    ;
  }
  static warn(msg) {
    if (Logger2.enabled) {
      let v = Logger2.prefix + Logger2.chalk.yellow(msg);
      process.stdout.write(Std.string(v));
      process.stdout.write("\n");
    }
    ;
  }
  static get __name__() {
    return "mcb.Logger";
  }
  get __class__() {
    return Logger2;
  }
};
Logger.enabled = true;
Logger.chalk = source_default;
Logger.prefix = Logger.chalk.gray("[") + Logger.chalk.green("MCB") + Logger.chalk.gray("] ");

// bin/mcl/Config.js
var Fs4 = __toESM(require("fs"));

// bin/haxe/io/Error.js
var $global52 = Register.$global;
var Error4 = Register.global("$hxEnums")["haxe.io.Error"] = {
  __ename__: "haxe.io.Error",
  /**
  The IO is set into nonblocking mode and some data cannot be read or written
  */
  Blocked: { _hx_name: "Blocked", _hx_index: 0, __enum__: "haxe.io.Error" },
  /**
  An integer value is outside its allowed range
  */
  Overflow: { _hx_name: "Overflow", _hx_index: 1, __enum__: "haxe.io.Error" },
  /**
  An operation on Bytes is outside of its valid range
  */
  OutsideBounds: { _hx_name: "OutsideBounds", _hx_index: 2, __enum__: "haxe.io.Error" },
  /**
  Other errors
  */
  Custom: Object.assign((e) => ({ _hx_index: 3, __enum__: "haxe.io.Error", "e": e }), { _hx_name: "Custom", __params__: ["e"] })
};
Error4.__constructs__ = [Error4.Blocked, Error4.Overflow, Error4.OutsideBounds, Error4.Custom];
Error4.__empty_constructs__ = [Error4.Blocked, Error4.Overflow, Error4.OutsideBounds];

// bin/haxe/io/Encoding.js
var $global53 = Register.$global;
var Encoding = Register.global("$hxEnums")["haxe.io.Encoding"] = {
  __ename__: "haxe.io.Encoding",
  UTF8: { _hx_name: "UTF8", _hx_index: 0, __enum__: "haxe.io.Encoding" },
  /**
  Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific
  */
  RawNative: { _hx_name: "RawNative", _hx_index: 1, __enum__: "haxe.io.Encoding" }
};
Encoding.__constructs__ = [Encoding.UTF8, Encoding.RawNative];
Encoding.__empty_constructs__ = [Encoding.UTF8, Encoding.RawNative];

// bin/haxe/io/Bytes.js
var $global54 = Register.$global;
var Bytes = Register.global("$hxClasses")["haxe.io.Bytes"] = class Bytes2 extends Register.inherits() {
  new(data) {
    this.length = data.byteLength;
    this.b = new Uint8Array(data);
    this.b.bufferValue = data;
    data.hxBytes = this;
    data.bytes = this.b;
  }
  /**
  Returns the `len`-bytes long string stored at the given position `pos`,
  interpreted with the given `encoding` (UTF-8 by default).
  */
  getString(pos, len, encoding) {
    if (pos < 0 || len < 0 || pos + len > this.length) {
      throw Exception.thrown(Error4.OutsideBounds);
    }
    ;
    if (encoding == null) {
      encoding = Encoding.UTF8;
    }
    ;
    let s = "";
    let b = this.b;
    let i = pos;
    let max = pos + len;
    switch (encoding._hx_index) {
      case 0:
        let debug = pos > 0;
        while (i < max) {
          let c = b[i++];
          if (c < 128) {
            if (c == 0) {
              break;
            }
            ;
            s += String.fromCodePoint(c);
          } else if (c < 224) {
            let code = (c & 63) << 6 | b[i++] & 127;
            s += String.fromCodePoint(code);
          } else if (c < 240) {
            let c2 = b[i++];
            let code = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
            s += String.fromCodePoint(code);
          } else {
            let c2 = b[i++];
            let c3 = b[i++];
            let u = (c & 15) << 18 | (c2 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
            s += String.fromCodePoint(u);
          }
          ;
        }
        ;
        break;
      case 1:
        while (i < max) {
          let c = b[i++] | b[i++] << 8;
          s += String.fromCodePoint(c);
        }
        ;
        break;
    }
    ;
    return s;
  }
  /**
  Returns a `String` representation of the bytes interpreted as UTF-8.
  */
  toString() {
    return this.getString(0, this.length);
  }
  /**
  Returns the `Bytes` representation of the given `String`, using the
  specified encoding (UTF-8 by default).
  */
  static ofString(s, encoding) {
    if (encoding == Encoding.RawNative) {
      let buf = new Uint8Array(s.length << 1);
      let _g = 0;
      let _g1 = s.length;
      while (_g < _g1) {
        let i2 = _g++;
        let c = s.charCodeAt(i2);
        buf[i2 << 1] = c & 255;
        buf[i2 << 1 | 1] = c >> 8;
      }
      ;
      return new Bytes2(buf.buffer);
    }
    ;
    let a = new Array();
    let i = 0;
    while (i < s.length) {
      let c = s.charCodeAt(i++);
      if (55296 <= c && c <= 56319) {
        c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
      }
      ;
      if (c <= 127) {
        a.push(c);
      } else if (c <= 2047) {
        a.push(192 | c >> 6);
        a.push(128 | c & 63);
      } else if (c <= 65535) {
        a.push(224 | c >> 12);
        a.push(128 | c >> 6 & 63);
        a.push(128 | c & 63);
      } else {
        a.push(240 | c >> 18);
        a.push(128 | c >> 12 & 63);
        a.push(128 | c >> 6 & 63);
        a.push(128 | c & 63);
      }
      ;
    }
    ;
    return new Bytes2(new Uint8Array(a).buffer);
  }
  /**
  Returns the `Bytes` representation of the given `BytesData`.
  */
  static ofData(b) {
    let hb = b.hxBytes;
    if (hb != null) {
      return hb;
    }
    ;
    return new Bytes2(b);
  }
  static get __name__() {
    return "haxe.io.Bytes";
  }
  get __class__() {
    return Bytes2;
  }
};

// bin/js/node/buffer/Buffer.js
var $global55 = Register.$global;
var Helper = Register.global("$hxClasses")["js.node.buffer._Buffer.Helper"] = class Helper2 {
  static bytesOfBuffer(b) {
    let o = Object.create(Bytes.prototype);
    o.length = b.byteLength;
    o.b = b;
    b.bufferValue = b;
    b.hxBytes = o;
    b.bytes = b;
    return o;
  }
  static get __name__() {
    return "js.node.buffer._Buffer.Helper";
  }
  get __class__() {
    return Helper2;
  }
};

// bin/haxe/crypto/Sha1.js
var $global56 = Register.$global;
var Sha1 = Register.global("$hxClasses")["haxe.crypto.Sha1"] = class Sha12 extends Register.inherits() {
  new() {
  }
  doEncode(x) {
    let w = new Array();
    let a = 1732584193;
    let b = -271733879;
    let c = -1732584194;
    let d = 271733878;
    let e = -1009589776;
    let i = 0;
    while (i < x.length) {
      let olda = a;
      let oldb = b;
      let oldc = c;
      let oldd = d;
      let olde = e;
      let j = 0;
      while (j < 80) {
        if (j < 16) {
          w[j] = x[i + j];
        } else {
          let num = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
          w[j] = num << 1 | num >>> 31;
        }
        ;
        let t = (a << 5 | a >>> 27) + this.ft(j, b, c, d) + e + w[j] + this.kt(j);
        e = d;
        d = c;
        c = b << 30 | b >>> 2;
        b = a;
        a = t;
        ++j;
      }
      ;
      a += olda;
      b += oldb;
      c += oldc;
      d += oldd;
      e += olde;
      i += 16;
    }
    ;
    return [a, b, c, d, e];
  }
  /**
  Perform the appropriate triplet combination function for the current iteration
  */
  ft(t, b, c, d) {
    if (t < 20) {
      return b & c | ~b & d;
    }
    ;
    if (t < 40) {
      return b ^ c ^ d;
    }
    ;
    if (t < 60) {
      return b & c | b & d | c & d;
    }
    ;
    return b ^ c ^ d;
  }
  /**
  Determine the appropriate additive constant for the current iteration
  */
  kt(t) {
    if (t < 20) {
      return 1518500249;
    }
    ;
    if (t < 40) {
      return 1859775393;
    }
    ;
    if (t < 60) {
      return -1894007588;
    }
    ;
    return -899497514;
  }
  hex(a) {
    let str = "";
    let _g = 0;
    while (_g < a.length) {
      let num = a[_g];
      ++_g;
      str += StringTools.hex(num, 8);
    }
    ;
    return str.toLowerCase();
  }
  static encode(s) {
    let sh = new Sha12();
    let h = sh.doEncode(Sha12.str2blks(s));
    return sh.hex(h);
  }
  /**
  Convert a string to a sequence of 16-word blocks, stored as an array.
  Append padding bits and the length, as described in the SHA1 standard.
  */
  static str2blks(s) {
    let s1 = Bytes.ofString(s);
    let nblk = (s1.length + 8 >> 6) + 1;
    let blks = new Array();
    let _g = 0;
    let _g1 = nblk * 16;
    while (_g < _g1) {
      let i2 = _g++;
      blks[i2] = 0;
    }
    ;
    let _g2 = 0;
    let _g3 = s1.length;
    while (_g2 < _g3) {
      let i2 = _g2++;
      let p2 = i2 >> 2;
      blks[p2] |= s1.b[i2] << 24 - ((i2 & 3) << 3);
    }
    ;
    let i = s1.length;
    let p = i >> 2;
    blks[p] |= 128 << 24 - ((i & 3) << 3);
    blks[nblk * 16 - 1] = s1.length * 8;
    return blks;
  }
  static get __name__() {
    return "haxe.crypto.Sha1";
  }
  get __class__() {
    return Sha12;
  }
};

// bin/haxe/crypto/BaseCode.js
var $global57 = Register.$global;
var BaseCode = Register.global("$hxClasses")["haxe.crypto.BaseCode"] = class BaseCode2 extends Register.inherits() {
  new(base) {
    let len = base.length;
    let nbits = 1;
    while (len > 1 << nbits)
      ++nbits;
    if (nbits > 8 || len != 1 << nbits) {
      throw Exception.thrown("BaseCode : base length must be a power of two.");
    }
    ;
    this.base = base;
    this.nbits = nbits;
  }
  initTable() {
    let tbl = new Array();
    let _g = 0;
    while (_g < 256) {
      let i = _g++;
      tbl[i] = -1;
    }
    ;
    let _g1 = 0;
    let _g2 = this.base.length;
    while (_g1 < _g2) {
      let i = _g1++;
      tbl[this.base.b[i]] = i;
    }
    ;
    this.tbl = tbl;
  }
  decodeBytes(b) {
    let nbits = this.nbits;
    let base = this.base;
    if (this.tbl == null) {
      this.initTable();
    }
    ;
    let tbl = this.tbl;
    let size = b.length * nbits >> 3;
    let out = new Bytes(new ArrayBuffer(size));
    let buf = 0;
    let curbits = 0;
    let pin = 0;
    let pout = 0;
    while (pout < size) {
      while (curbits < 8) {
        curbits += nbits;
        buf <<= nbits;
        let i = tbl[b.b[pin++]];
        if (i == -1) {
          throw Exception.thrown("BaseCode : invalid encoded char");
        }
        ;
        buf |= i;
      }
      ;
      curbits -= 8;
      out.b[pout++] = buf >> curbits & 255;
    }
    ;
    return out;
  }
  static get __name__() {
    return "haxe.crypto.BaseCode";
  }
  get __class__() {
    return BaseCode2;
  }
};

// bin/haxe/crypto/Base64.js
var $global58 = Register.$global;
var Base64 = Register.global("$hxClasses")["haxe.crypto.Base64"] = class Base642 {
  static decode(str, complement) {
    if (complement == null) {
      complement = true;
    }
    ;
    if (complement) {
      while (HxOverrides.cca(str, str.length - 1) == 61)
        str = HxOverrides.substr(str, 0, -1);
    }
    ;
    return new BaseCode(Base642.BYTES).decodeBytes(Bytes.ofString(str));
  }
  static get __name__() {
    return "haxe.crypto.Base64";
  }
  get __class__() {
    return Base642;
  }
};
Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Base64.BYTES = Bytes.ofString(Base64.CHARS);

// bin/haxe/Resource.js
var $global59 = Register.$global;
var Resource = Register.global("$hxClasses")["haxe.Resource"] = class Resource2 {
  /**
  Retrieves the resource identified by `name` as a `String`.
  
  If `name` does not match any resource name, `null` is returned.
  */
  static getString(name) {
    let _g = 0;
    let _g1 = Resource2.content;
    while (_g < _g1.length) {
      let x = _g1[_g];
      ++_g;
      if (x.name == name) {
        if (x.str != null) {
          return x.str;
        }
        ;
        let b = Base64.decode(x.data);
        return b.toString();
      }
      ;
    }
    ;
    return null;
  }
  static get __name__() {
    return "haxe.Resource";
  }
  get __class__() {
    return Resource2;
  }
};
Resource.content = [{ name: "io-worker", data: "dmFyIGk9cmVxdWlyZSgid29ya2VyX3RocmVhZHMiKSx0PXJlcXVpcmUoImZzIiksYT1yZXF1aXJlKCJwYXRoIiksbj1uZXcgTWFwO2Z1bmN0aW9uIHAocyxvKXtsZXQgcj0oMCxhLnBhcnNlKShzKS5kaXI7bi5oYXMocil8fCgoMCx0Lm1rZGlyU3luYykocix7cmVjdXJzaXZlOiEwfSksbi5zZXQociwhMCkpLCgwLHQud3JpdGVGaWxlU3luYykocyxvKX1pLnBhcmVudFBvcnQub24oIm1lc3NhZ2UiLGZ1bmN0aW9uKG8pe3RyeXtvLm1hcCgoe3A6ZSxjOnJ9KT0+cChlLHIpKSxpLnBhcmVudFBvcnQucG9zdE1lc3NhZ2UoMSl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKX19KTsK" }];

// bin/Io.js
var Fs3 = __toESM(require("fs"));
var import_buffer = require("buffer");
var $global60 = Register.$global;
var Io = function() {
};
Io.__isInterface__ = true;
var RevertTracker = Register.global("$hxClasses")["RevertTracker"] = class RevertTracker2 extends Register.inherits() {
  new() {
    this.filesTracked = new StringMap();
  }
  track(path) {
    if (FileSystem.exists(path)) {
      let this1 = this.filesTracked;
      let value = Helper.bytesOfBuffer(Fs3.readFileSync(path));
      this1.inst.set(path, value);
    } else {
      this.filesTracked.inst.set(path, null);
    }
    ;
  }
  revert() {
    let map = this.filesTracked;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      if (v == null) {
        Fs3.unlinkSync(k);
      } else {
        FileSystem.createDirectory(Path2.directory(k));
        let data = v.b;
        Fs3.writeFileSync(k, import_buffer.Buffer.from(data.buffer, data.byteOffset, v.length));
      }
      ;
    }
    ;
    this.filesTracked = new StringMap();
  }
  static get __name__() {
    return "RevertTracker";
  }
  get __class__() {
    return RevertTracker2;
  }
};
var SyncIo = Register.global("$hxClasses")["SyncIo"] = class SyncIo2 extends Register.inherits() {
  new() {
    this.existingDirectories = new StringMap();
    this.revertMap = new RevertTracker();
    this.fileData = new StringMap();
  }
  reportFilesRemoved(oldFiles) {
    let _g = [];
    let file = EsMap.adaptIterator(oldFiles.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (!this.fileData.inst.has(file1)) {
        _g.push(file1);
      }
      ;
    }
    ;
    return _g;
  }
  reportFilesAdded(oldFiles) {
    let _g = [];
    let file = EsMap.adaptIterator(this.fileData.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (!oldFiles.inst.has(file1)) {
        _g.push(file1);
      }
      ;
    }
    ;
    return _g;
  }
  reportFilesChanged(oldFiles) {
    let _g = [];
    let file = EsMap.adaptIterator(this.fileData.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (oldFiles.inst.has(file1) && oldFiles.inst.get(file1) != this.fileData.inst.get(file1)) {
        _g.push(file1);
      }
      ;
    }
    ;
    return _g;
  }
  reportFileMetadata() {
    return this.fileData;
  }
  write(path, content) {
    let this1 = this.fileData;
    let value = Sha1.encode(content);
    this1.inst.set(path, value);
    this.revertMap.track(path);
    let dir = Path2.directory(path);
    if (!this.existingDirectories.inst.has(dir)) {
      FileSystem.createDirectory(dir);
      this.existingDirectories.inst.set(dir, true);
    }
    ;
    Fs3.writeFileSync(path, content);
  }
  cleanup() {
  }
  finished() {
    return true;
  }
  static get __name__() {
    return "SyncIo";
  }
  static get __interfaces__() {
    return [Io];
  }
  get __class__() {
    return SyncIo2;
  }
};
var ThreadedIo = Register.global("$hxClasses")["ThreadedIo"] = class ThreadedIo2 extends Register.inherits() {
  new() {
    this.terminated = false;
    this.pending = false;
    this.done = false;
    this.fileData = new StringMap();
    this.queue = [];
    this.enableLog = false;
    this.proc || (this.proc = require("node:worker_threads"));
    ;
    this.thread = new this.proc.Worker(Resource.getString("io-worker"), { name: "IoWorker", eval: true, workerData: { enableLog: false } });
    ;
    let _gthis = this;
    this.thread.on("error", function(error) {
      _gthis.log("Worker error: " + error);
      _gthis.terminated = true;
      throw Exception.thrown(error);
    });
    this.thread.on("exit", function(code) {
      _gthis.log("Worker stopped with exit code " + code);
      return _gthis.terminated = true;
    });
    this.thread.on("message", function() {
      _gthis.flush();
    });
  }
  reportFilesRemoved(oldFiles) {
    let _g = [];
    let file = EsMap.adaptIterator(oldFiles.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (!this.fileData.inst.has(file1)) {
        _g.push(file1);
      }
      ;
    }
    ;
    return _g;
  }
  reportFilesAdded(oldFiles) {
    let _g = [];
    let file = EsMap.adaptIterator(this.fileData.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (!oldFiles.inst.has(file1)) {
        _g.push(file1);
      }
      ;
    }
    ;
    return _g;
  }
  reportFilesChanged(oldFiles) {
    let _g = [];
    let file = EsMap.adaptIterator(this.fileData.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (oldFiles.inst.has(file1) && oldFiles.inst.get(file1) != this.fileData.inst.get(file1)) {
        _g.push(file1);
      }
      ;
    }
    ;
    return _g;
  }
  reportFileMetadata() {
    return this.fileData;
  }
  log(msg) {
    if (this.enableLog) {
      console.log("src/Io.hx:153:", "[ThreadedIo | " + process.uptime() + "] " + msg);
    }
    ;
  }
  flush() {
    this.log("flush");
    if (this.queue.length == 0) {
      if (!this.done) {
        this.pending = false;
      } else {
        this.log("Terminating worker thread");
        this.thread.terminate();
      }
      ;
      return;
    }
    ;
    let packet = this.queue;
    this.queue = [];
    this.pending = true;
    this.log("Posting " + packet.length + " entries to worker thread");
    this.thread.postMessage(packet);
  }
  write(path, content) {
    let this1 = this.fileData;
    let value = Sha1.encode(content);
    this1.inst.set(path, value);
    this.log("write " + path);
    if (this.done) {
      throw Exception.thrown("Cannot write after cleanup()");
    }
    ;
    this.queue.push({ "p": path, "c": content });
    if (!this.pending) {
      this.flush();
    }
    ;
  }
  cleanup() {
    this.log("cleanup");
    this.done = true;
    if (!this.pending) {
      this.flush();
    }
    ;
  }
  finished() {
    return this.terminated;
  }
  static get __name__() {
    return "ThreadedIo";
  }
  static get __interfaces__() {
    return [Io];
  }
  get __class__() {
    return ThreadedIo2;
  }
};
var MultiThreadIo = Register.global("$hxClasses")["MultiThreadIo"] = class MultiThreadIo2 extends Register.inherits() {
  new(count) {
    this.fileData = new StringMap();
    this.idx = 0;
    this.threads = [];
    if ((count & count - 1) != 0) {
      throw Exception.thrown("Thread count must be a power of two");
    }
    ;
    this.mask = count - 1;
    let _g = 0;
    let _g1 = count;
    while (_g < _g1) {
      let i = _g++;
      this.threads.push(new ThreadedIo());
    }
    ;
  }
  reportFilesRemoved(oldFiles) {
    let result = [];
    let files = this.reportFileMetadata();
    let file = EsMap.adaptIterator(oldFiles.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (!files.inst.has(file1)) {
        result.push(file1);
      }
      ;
    }
    ;
    return result;
  }
  reportFilesAdded(oldFiles) {
    let files = this.reportFileMetadata();
    let result = [];
    let file = EsMap.adaptIterator(files.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (!oldFiles.inst.has(file1)) {
        result.push(file1);
      }
      ;
    }
    ;
    return result;
  }
  reportFilesChanged(oldFiles) {
    let data = this.reportFileMetadata();
    let result = [];
    let file = EsMap.adaptIterator(data.inst.keys());
    while (file.hasNext()) {
      let file1 = file.next();
      if (oldFiles.inst.has(file1) && oldFiles.inst.get(file1) != data.inst.get(file1)) {
        result.push(file1);
      }
      ;
    }
    ;
    return result;
  }
  reportFileMetadata() {
    let _g = 0;
    let _g1 = this.threads;
    while (_g < _g1.length) {
      let t = _g1[_g];
      ++_g;
      let file = EsMap.adaptIterator(t.reportFileMetadata().inst.keys());
      while (file.hasNext()) {
        let file1 = file.next();
        let this1 = this.fileData;
        let value = t.reportFileMetadata().inst.get(file1);
        this1.inst.set(file1, value);
      }
      ;
    }
    ;
    return this.fileData;
  }
  cleanup() {
    let _g = 0;
    let _g1 = this.threads;
    while (_g < _g1.length) {
      let t = _g1[_g];
      ++_g;
      t.cleanup();
    }
    ;
  }
  write(path, content) {
    this.threads[this.idx++ & this.mask].write(path, content);
  }
  finished() {
    let _g = 0;
    let _g1 = this.threads;
    while (_g < _g1.length) {
      let t = _g1[_g];
      ++_g;
      if (!t.finished()) {
        return false;
      }
      ;
    }
    ;
    return true;
  }
  static isPowerOfTwo(x) {
    return (x & x - 1) == 0;
  }
  static get __name__() {
    return "MultiThreadIo";
  }
  static get __interfaces__() {
    return [Io];
  }
  get __class__() {
    return MultiThreadIo2;
  }
};

// bin/mcl/Config.js
var $global61 = Register.$global;
var EventDispatcher = Register.global("$hxClasses")["mcl.EventDispatcher"] = class EventDispatcher2 extends Register.inherits() {
  new() {
    this._subscribers = new Array();
  }
  subscribe(callback) {
    this._subscribers.push(callback);
  }
  dispatch(event) {
    if (this._subscribers.length == 0) {
      return;
    }
    ;
    let _g = 0;
    let _g1 = this._subscribers;
    while (_g < _g1.length) {
      let subscriber = _g1[_g];
      ++_g;
      subscriber(event);
    }
    ;
  }
  static get __name__() {
    return "mcl.EventDispatcher";
  }
  get __class__() {
    return EventDispatcher2;
  }
};
var ConfigEvents = Register.global("$hxClasses")["mcl.ConfigEvents"] = class ConfigEvents2 extends Register.inherits() {
  new() {
    this.onPostBuild = new EventDispatcher();
    this.onPreBuild = new EventDispatcher();
  }
  static get __name__() {
    return "mcl.ConfigEvents";
  }
  get __class__() {
    return ConfigEvents2;
  }
};
var ConfigUtil = Register.global("$hxClasses")["mcl._Config.ConfigUtil"] = class ConfigUtil2 {
  static lock(obj) {
    Object.freeze(obj);
    let _g = 0;
    let _g1 = Reflect2.fields(obj);
    while (_g < _g1.length) {
      let field = _g1[_g];
      ++_g;
      let value = Reflect2.field(obj, field);
      if (value != null && typeof value == "object") {
        ConfigUtil2.lock(value);
      }
      ;
    }
    ;
    return obj;
  }
  static get __name__() {
    return "mcl._Config.ConfigUtil";
  }
  get __class__() {
    return ConfigUtil2;
  }
};
var Config = Register.global("$hxClasses")["mcl.Config"] = class Config2 extends Register.inherits() {
  new() {
    this.header = "# Generated with MC-Build\n";
    this.features = new FeatureFlags();
    this.formatVersion = 1;
    this.dontEmitComments = false;
    this.eqConstScoreboardName = "mcb.eq.const";
    this.eqVarScoreboardName = "mcb.eq.var";
    this.io = null;
    this.generatedDirName = "zzz";
    this.events = new ConfigEvents();
    this.libDir = Path2.join([__filename, "..", ".mcblib"]);
    this.internalScoreboardName = "mcb.internal";
  }
  static create(base) {
    ConfigUtil.lock(base);
    let c = new Config2();
    if (base.libDir != null) {
      c.libDir = base.libDir;
    }
    ;
    if (base.generatedDirName != null) {
      c.generatedDirName = base.generatedDirName;
    }
    ;
    if (base.internalScoreboardName != null) {
      c.internalScoreboardName = base.internalScoreboardName;
    }
    ;
    if (base.ioThreadCount != null) {
      let _g = base.ioThreadCount;
      if (base.ioThreadCount < 1) {
        throw Exception.thrown("io-thread-count must be greater than 0");
      } else if (_g == null) {
        c.io = new MultiThreadIo(base.ioThreadCount);
      } else {
        switch (_g) {
          case 1:
            c.io = new SyncIo();
            break;
          case 2:
            c.io = new ThreadedIo();
            break;
          default:
            c.io = new MultiThreadIo(base.ioThreadCount);
        }
        ;
      }
      ;
    }
    ;
    if (base.eqConstScoreboardName != null) {
      c.eqConstScoreboardName = base.eqConstScoreboardName;
    }
    ;
    if (base.eqVarScoreboardName != null) {
      c.eqVarScoreboardName = base.eqVarScoreboardName;
    }
    ;
    if (base.header != null) {
      c.header = base.header;
    }
    ;
    if (base.dontEmitComments != null) {
      c.dontEmitComments = base.dontEmitComments;
    }
    ;
    if (base.formatVersion != null) {
      c.formatVersion = base.formatVersion;
    } else {
      let content = Fs4.readFileSync(Path2.join([Path2.addTrailingSlash(process.cwd()), "pack.mcmeta"]), { "encoding": "utf8" });
      let json = JSON.parse(content);
      if (json != null && json.pack != null && json.pack.pack_format != null) {
        c.formatVersion = json.pack.pack_format;
      } else {
        Logger.error("Could not determine pack format version, please specify it in the config or pack.mcmeta file, if you have a pack.mcmeta file already this may be the result of a parsing error.");
        process.exit(21);
      }
      ;
    }
    ;
    c.features.apply(c.formatVersion, null);
    if (base.setup != null) {
      base.setup(c);
    }
    ;
    return c;
  }
  static mergeFeatureFlagsToConfig(c) {
  }
  static get __name__() {
    return "mcl.Config";
  }
  get __class__() {
    return Config2;
  }
};
var UserConfig = function() {
};
UserConfig.__isInterface__ = true;

// bin/mcl/Compiler.js
var $global62 = Register.$global;
var ErrorUtil = Register.global("$hxClasses")["mcl.ErrorUtil"] = class ErrorUtil2 {
  static format(message, pos) {
    return "" + pos.file + ":" + pos.line + ":" + (pos.col + 1) + ": " + message;
  }
  static formatWithStack(message, stack) {
    let res = message;
    let _g = 0;
    while (_g < stack.length) {
      let pos = stack[_g];
      ++_g;
      if (pos == null) {
        res += "\n	at <unknown>";
      } else {
        res += "\n	at " + pos.file + ":" + pos.line + ":" + (pos.col + 1);
      }
      ;
    }
    ;
    return res;
  }
  static formatContext(message, pos, context) {
    return ErrorUtil2.formatWithStack(message, context.stack.concat([pos]));
  }
  static get __name__() {
    return "mcl.ErrorUtil";
  }
  get __class__() {
    return ErrorUtil2;
  }
};
var UidTracker = Register.global("$hxClasses")["mcl._Compiler.UidTracker"] = class UidTracker2 extends Register.inherits() {
  new() {
    this.uid = 0;
  }
  get() {
    return this.uid++;
  }
  static get __name__() {
    return "mcl._Compiler.UidTracker";
  }
  get __class__() {
    return UidTracker2;
  }
};
var McTemplate = Register.global("$hxClasses")["mcl.McTemplate"] = class McTemplate2 extends Register.inherits() {
  new(name, body, file) {
    this.jsValueCache = new IntMap();
    this.hasBeenUsed = false;
    this.tickBlock = null;
    this.loadBlock = null;
    this.overloads = new ObjectMap();
    this.name = name;
    this.body = body;
    this.parse(body);
    this.file = file;
  }
  compileArgs(args, pos) {
    let $arguments = [];
    let sections = args.split(" ");
    let offset = 0;
    let _g = 0;
    while (_g < sections.length) {
      let section = sections[_g];
      ++_g;
      if (section == "") {
        ++offset;
        continue;
      }
      ;
      $arguments.push(TemplateArgument.parse(section, { "file": pos.file, "line": pos.line, "col": pos.col + offset }));
      offset += section.length;
    }
    ;
    return $arguments;
  }
  parse(nodes) {
    let _g = 0;
    while (_g < nodes.length) {
      let node = nodes[_g];
      ++_g;
      switch (node._hx_index) {
        case 9:
          let pos = node.pos;
          let body = node.body;
          if (this.tickBlock == null) {
            this.tickBlock = body;
          } else {
            throw new CompilerError(ErrorUtil.format("Templates can only have one top-level tick block", pos), false);
          }
          ;
          break;
        case 10:
          let pos1 = node.pos;
          let body1 = node.body;
          if (this.loadBlock == null) {
            this.loadBlock = body1;
          } else {
            throw new CompilerError(ErrorUtil.format("Templates can only have one top-level load block", pos1), false);
          }
          ;
          break;
        case 17:
          let pos2 = node.pos;
          let args = node.args;
          let body2 = node.body;
          let this1 = this.overloads;
          let key = this.compileArgs(args, pos2);
          this1.inst.set(key, body2);
          break;
        default:
          if (node._hx_index != 16) {
            throw new CompilerError(ErrorUtil.format("Unexpected node type: " + Std.string(node), Reflect2.field(node, "pos")), true);
          }
          ;
      }
      ;
    }
    ;
  }
  inject(context, into) {
    this.hasBeenUsed = true;
    let defs = [];
    if (this.loadBlock != null && this.loadBlock.length > 0) {
      let pos = this.loadBlock[0].pos;
      defs.push(AstNode.FunctionDef(pos, "load", this.loadBlock, "minecraft:load"));
    }
    ;
    if (this.tickBlock != null && this.tickBlock.length > 0) {
      let pos = this.tickBlock[0].pos;
      defs.push(AstNode.FunctionDef(pos, "tick", this.tickBlock, "minecraft:tick"));
    }
    ;
    if (defs.length > 0) {
      let pos = defs[0].pos;
      let info = context.compiler.getInitialPathInfo(this.file.name);
      let tmp = { "append": function(v) {
        throw new CompilerError(ErrorUtil.formatContext("tried to append to a Void context (template virtual context)", pos, context), false, [pos].concat(context.stack));
      }, "namespace": info.namespace, "path": info.path, "uidIndex": context.uidIndex, "variables": new VariableMap(context.globalVariables), "templates": this.file.templates, "stack": context.stack, "replacements": new VariableMap(null), "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
      let tmp1 = AstNode.Directory(pos, this.name, defs);
      into.embed(tmp, pos, new StringMap(), [tmp1], true);
    }
    ;
  }
  injectTransform(context, into) {
    this.hasBeenUsed = true;
    let defs = [];
    if (this.loadBlock != null && this.loadBlock.length > 0) {
      let pos = this.loadBlock[0].pos;
      defs.push(AstNode.FunctionDef(pos, "load", this.loadBlock, "minecraft:load"));
    }
    ;
    if (this.tickBlock != null && this.tickBlock.length > 0) {
      let pos = this.tickBlock[0].pos;
      defs.push(AstNode.FunctionDef(pos, "tick", this.tickBlock, "minecraft:tick"));
    }
    ;
    if (defs.length > 0) {
      let pos = defs[0].pos;
      let info = context.compiler.getInitialPathInfo(this.file.name);
      let tmp = { "append": function(v) {
        throw new CompilerError(ErrorUtil.formatContext("tried to append to a Void context (template virtual context)", pos, context), false, [pos].concat(context.stack));
      }, "namespace": info.namespace, "path": info.path, "uidIndex": context.uidIndex, "variables": new VariableMap(context.globalVariables), "templates": this.file.templates, "stack": context.stack, "replacements": new VariableMap(null), "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
      let tmp1 = AstNode.Directory(pos, this.name, defs);
      into.embedTransform(tmp, pos, new StringMap(), [tmp1], true);
    }
    ;
    return AstNode.Void;
  }
  process(file, context, pos, value, extras) {
    let argstring = StringTools.ltrim(value.substring(this.name.length));
    this.jsValueCache.clear();
    TemplateArgument.jsCache = this.jsValueCache;
    let map = this.overloads;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let types = _g_key;
      let overloadBody = _g_value;
      let args = new StringMap();
      let successCount = 0;
      let pidx = 0;
      let argList = [argstring].concat(extras == null ? [] : extras);
      let lastEntryWasBlock = false;
      let jsCacheIdx = 0;
      let _g = 0;
      while (_g < types.length) {
        let arg = types[_g];
        ++_g;
        while (pidx < argList.length && argList[pidx] == "")
          ++pidx;
        if (pidx >= argList.length) {
          break;
        }
        ;
        if (arg.expectBlock) {
          if (!Type.enumEq(Type["typeof"](argList[pidx]), ValueType2.TEnum(AstNode))) {
            break;
          }
          ;
          let x = arg.parseValueBlock(argList[pidx], pos, context);
          if (!x.success) {
            break;
          }
          ;
          lastEntryWasBlock = true;
          args.inst.set(arg.name, x.value);
          argList[pidx] = x.raw;
          ++successCount;
          ++pidx;
        } else {
          if (typeof argList[pidx] != "string") {
            break;
          }
          ;
          let s = argList[pidx];
          let jsBlockRaw = null;
          if (s.charAt(0) == "<" && s.charAt(1) == "%" && !arg.expectJsValue) {
            let end = s.indexOf("%>");
            if (end == -1) {
              throw new CompilerError(ErrorUtil.formatContext("Unexpected end of inline script block", pos, context), false, [pos].concat(context.stack));
            }
            ;
            let script = s.substring(2, end);
            jsBlockRaw = script;
            if (this.jsValueCache.inst.has(jsCacheIdx)) {
              let jsVal = this.jsValueCache.inst.get(jsCacheIdx);
              s = jsVal == null ? "null" : Std.string(jsVal);
            } else {
              let jsVal = McFile.invokeExpressionInline(script, context, pos);
              this.jsValueCache.inst.set(jsCacheIdx, jsVal);
              s = jsVal == null ? "null" : Std.string(jsVal);
            }
            ;
            ++jsCacheIdx;
          } else if (arg.expectJsValue) {
            TemplateArgument.jsCacheIdx = jsCacheIdx;
            ++jsCacheIdx;
          }
          ;
          let x = arg.parseValue(s, pos, context);
          if (!x.success) {
            break;
          }
          ;
          if (arg.name != null) {
            args.inst.set(arg.name, x.value);
          }
          ;
          if (jsBlockRaw != null) {
            argList[pidx] = StringTools.ltrim(Boot.__cast(argList[pidx], String).substring(jsBlockRaw.length + 4));
          } else {
            argList[pidx] = StringTools.ltrim(Boot.__cast(argList[pidx], String).substring(x.raw.length));
          }
          ;
          ++successCount;
          lastEntryWasBlock = false;
        }
        ;
      }
      ;
      while (pidx < argList.length && argList[pidx] == "")
        ++pidx;
      if (successCount != types.length || pidx != argList.length || argList[pidx - 1] != "" && !lastEntryWasBlock) {
        continue;
      }
      ;
      if (!this.hasBeenUsed) {
        this.inject(context, file);
      }
      ;
      let newContext = { "append": context.append, "namespace": context.namespace, "path": context.path, "uidIndex": context.uidIndex, "variables": context.variables, "templates": this.file.templates, "stack": context.stack, "replacements": context.replacements, "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
      file.embed(newContext, pos, args, overloadBody);
      return;
    }
    ;
    throw new CompilerError(ErrorUtil.formatContext("Failed to find matching template overload for: " + value, pos, context), false, [pos].concat(context.stack));
  }
  transform(file, context, pos, value, extras) {
    let argstring = StringTools.ltrim(value.substring(this.name.length));
    this.jsValueCache.clear();
    TemplateArgument.jsCache = this.jsValueCache;
    let map = this.overloads;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let types = _g_key;
      let overloadBody = _g_value;
      let args = new StringMap();
      let successCount = 0;
      let pidx = 0;
      let argList = [argstring].concat(extras == null ? [] : extras);
      let lastEntryWasBlock = false;
      let jsCacheIdx = 0;
      let _g = 0;
      while (_g < types.length) {
        let arg = types[_g];
        ++_g;
        while (pidx < argList.length && argList[pidx] == "")
          ++pidx;
        if (pidx >= argList.length) {
          break;
        }
        ;
        if (arg.expectBlock) {
          if (!Type.enumEq(Type["typeof"](argList[pidx]), ValueType2.TEnum(AstNode))) {
            break;
          }
          ;
          let x = arg.parseValueBlock(argList[pidx], pos, context);
          if (!x.success) {
            break;
          }
          ;
          lastEntryWasBlock = true;
          args.inst.set(arg.name, x.value);
          argList[pidx] = x.raw;
          ++successCount;
          ++pidx;
        } else {
          if (typeof argList[pidx] != "string") {
            break;
          }
          ;
          let s = argList[pidx];
          let jsBlockRaw = null;
          if (s.charAt(0) == "<" && s.charAt(1) == "%" && !arg.expectJsValue) {
            let end = s.indexOf("%>");
            if (end == -1) {
              throw new CompilerError(ErrorUtil.formatContext("Unexpected end of inline script block", pos, context), false, [pos].concat(context.stack));
            }
            ;
            let script = s.substring(2, end);
            jsBlockRaw = script;
            if (this.jsValueCache.inst.has(jsCacheIdx)) {
              let jsVal = this.jsValueCache.inst.get(jsCacheIdx);
              s = jsVal == null ? "null" : Std.string(jsVal);
            } else {
              let jsVal = McFile.invokeExpressionInline(script, context, pos);
              this.jsValueCache.inst.set(jsCacheIdx, jsVal);
              s = jsVal == null ? "null" : Std.string(jsVal);
            }
            ;
            ++jsCacheIdx;
          } else if (arg.expectJsValue) {
            TemplateArgument.jsCacheIdx = jsCacheIdx;
            ++jsCacheIdx;
          }
          ;
          let x = arg.parseValue(s, pos, context);
          if (!x.success) {
            break;
          }
          ;
          if (arg.name != null) {
            args.inst.set(arg.name, x.value);
          }
          ;
          if (jsBlockRaw != null) {
            argList[pidx] = StringTools.ltrim(Boot.__cast(argList[pidx], String).substring(jsBlockRaw.length + 4));
          } else {
            argList[pidx] = StringTools.ltrim(Boot.__cast(argList[pidx], String).substring(x.raw.length));
          }
          ;
          ++successCount;
          lastEntryWasBlock = false;
        }
        ;
      }
      ;
      while (pidx < argList.length && argList[pidx] == "")
        ++pidx;
      if (successCount != types.length || pidx != argList.length || argList[pidx - 1] != "" && !lastEntryWasBlock) {
        continue;
      }
      ;
      let nodes = [];
      if (!this.hasBeenUsed) {
        nodes.push(this.injectTransform(context, file));
      }
      ;
      let newContext = { "append": context.append, "namespace": context.namespace, "path": context.path, "uidIndex": context.uidIndex, "variables": context.variables, "templates": this.file.templates, "stack": context.stack, "replacements": context.replacements, "isTemplate": false, "requireTemplateKeyword": true, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
      nodes.push(file.embedTransform(newContext, pos, args, overloadBody, false));
      return AstNode.Group(nodes);
    }
    ;
    throw new CompilerError(ErrorUtil.formatContext("Failed to find matching template overload for: " + value, pos, context), false, [pos].concat(context.stack));
  }
  static get __name__() {
    return "mcl.McTemplate";
  }
  get __class__() {
    return McTemplate2;
  }
};
var VariableMap = Register.global("$hxClasses")["mcl.VariableMap"] = class VariableMap2 extends Register.inherits() {
  new(parent, variables) {
    this.parent = parent;
    this.variables = variables == null ? new StringMap() : variables;
  }
  get() {
    if (this._cache != null) {
      let _g = new StringMap();
      let map2 = this._cache;
      let _g_map2 = map2;
      let _g_keys2 = map2.keys();
      while (_g_keys2.hasNext()) {
        let key = _g_keys2.next();
        let _g_value = _g_map2.get(key);
        let _g_key = key;
        let k = _g_key;
        let v = _g_value;
        _g.inst.set(k, v);
      }
      ;
      return _g;
    }
    ;
    let res = this.parent == null ? new StringMap() : this.parent.get();
    let map = this.variables;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      res.inst.set(k, v);
    }
    ;
    this._cache = res;
    return res;
  }
  static fromObject(obj) {
    let res = new StringMap();
    let _g = 0;
    let _g1 = Reflect2.fields(obj);
    while (_g < _g1.length) {
      let k = _g1[_g];
      ++_g;
      res.inst.set(k, Reflect2.field(obj, k));
    }
    ;
    return new VariableMap2(null, res);
  }
  static get __name__() {
    return "mcl.VariableMap";
  }
  get __class__() {
    return VariableMap2;
  }
};
Register.createStatic(VariableMap, "globals", function() {
  return new VariableMap(null, Globals.map);
});
var ImportFileType = Register.global("$hxEnums")["mcl.ImportFileType"] = {
  __ename__: "mcl.ImportFileType",
  IMcFile: Object.assign((f) => ({ _hx_index: 0, __enum__: "mcl.ImportFileType", "f": f }), { _hx_name: "IMcFile", __params__: ["f"] }),
  IJsFile: Object.assign((f) => ({ _hx_index: 1, __enum__: "mcl.ImportFileType", "f": f }), { _hx_name: "IJsFile", __params__: ["f"] })
};
ImportFileType.__constructs__ = [ImportFileType.IMcFile, ImportFileType.IJsFile];
ImportFileType.__empty_constructs__ = [];
var McFile = Register.global("$hxClasses")["mcl.McFile"] = class McFile2 extends Register.inherits() {
  new(name, ast) {
    this.tagsDir = "tags";
    this.functionsDir = "functions";
    this.fileJs = {};
    this.tickCommands = [];
    this.loadCommands = [];
    this.imports = new StringMap();
    this.exportedTemplates = new StringMap();
    this.templates = new StringMap();
    this.ast = [];
    this.name = name;
    this.ast = ast;
    this.ext = Path2.extension(name);
  }
  getTemplates() {
    if (this.ext == "mcbt") {
      return this.exportedTemplates;
    }
    ;
    throw new CompilerError("tried to get templates from non-template file:" + this.name, true);
  }
  setup(compiler) {
    if (compiler.config.features.useFolderRenames48) {
      this.functionsDir = "function";
    }
    ;
    let ast = this.ast;
    this.ast = [];
    let _g = 0;
    while (_g < ast.length) {
      let node = ast[_g];
      ++_g;
      switch (node._hx_index) {
        case 2:
          let _g1 = node.pos;
          let name = node.name;
          let body = node.body;
          let template = new McTemplate(name, body, this);
          this.templates.inst.set(name, template);
          this.exportedTemplates.inst.set(name, template);
          break;
        case 4:
          let _g2 = node.pos;
          let importName = node.name;
          let res = compiler.resolve(this.name, importName);
          switch (res._hx_index) {
            case 0:
              let f = res.f;
              this.imports.inst.set(importName, f);
              break;
            case 1:
              let f1 = res.f;
              Object.assign(this.fileJs, f1);
              ;
              break;
          }
          ;
          break;
        case 15:
          let _g3 = node.pos;
          let _g4 = node.value;
          break;
        default:
          this.ast.push(node);
      }
      ;
    }
    ;
    let dep = EsMap.adaptIterator(this.imports.inst.values());
    while (dep.hasNext()) {
      let dep1 = dep.next();
      let importedTemplates = dep1.getTemplates();
      let map = importedTemplates;
      let _g_map = map;
      let _g_keys = map.keys();
      while (_g_keys.hasNext()) {
        let key = _g_keys.next();
        let _g_value = _g_map.get(key);
        let _g_key = key;
        let k = _g_key;
        let v = _g_value;
        this.templates.inst.set(k, v);
      }
      ;
    }
    ;
  }
  createAnonymousFunction(pos, body, data, context, name, isMacro) {
    name = name != null ? this.injectValues(name, context, pos) : null;
    let commands = [];
    let uid = name == null ? Std.string(context.uidIndex.get()) : "";
    let id = name == null ? "" + context.compiler.config.generatedDirName + "/" + uid : name;
    let newGeneratedRoot = name == null ? [] : [name];
    if (name != null && name.indexOf("/") != -1) {
      let segments = name.split("/");
      segments.pop();
      newGeneratedRoot = segments;
    }
    ;
    let callSig = context.namespace + ":" + context.path.concat(name == null ? [context.compiler.config.generatedDirName, uid] : [name]).join("/");
    let namespace = context.namespace;
    let _this = context.variables;
    let variables = null;
    let variableMap = variables == null ? _this : new VariableMap(_this, variables);
    let path = context.path.concat(newGeneratedRoot);
    let uidIndex = context.uidIndex;
    let stack = context.stack;
    let replacements2 = context.variables;
    let templates = context.templates;
    let requireTemplateKeyword = context.requireTemplateKeyword;
    let compiler = context.compiler;
    let globalVariables = context.globalVariables;
    let functions = context.functions.concat([callSig]);
    let newContext = { "append": function(v) {
      commands.push(v);
    }, "namespace": namespace, "path": path == null ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": stack, "replacements": replacements2, "isTemplate": this.ext == "mcbt", "templates": templates, "requireTemplateKeyword": requireTemplateKeyword, "compiler": compiler, "globalVariables": globalVariables, "functions": functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
    let _g = 0;
    while (_g < body.length) {
      let node = body[_g];
      ++_g;
      this.compileCommand(node, newContext);
    }
    ;
    let result = commands.join("\n");
    if (name != null) {
      name = this.injectValues(name, context, pos);
    }
    ;
    let path1 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([id + ".mcfunction"])));
    let content = result;
    if (context.compiler.config.header.length > 0 && path1.endsWith(".mcfunction")) {
      content = context.compiler.config.header + "\n" + content;
    }
    ;
    context.compiler.io.write(path1, content);
    let cmd = "function " + context.namespace + ":" + context.path.concat([id]).join("/");
    let cmd1 = data == null ? "" : " " + this.injectValues(data, context, pos);
    return (isMacro ? "$" : "") + (cmd + cmd1);
  }
  embedTransform(context, pos, varmap, body, useTld) {
    if (useTld == null) {
      useTld = false;
    }
    ;
    let namespace = context.namespace;
    let append = context.append;
    let _this = context.globalVariables;
    let variableMap = new VariableMap(VariableMap.globals, (varmap == null ? _this : new VariableMap(_this, varmap)).get());
    let path = context.path;
    let newContext = { "append": append, "namespace": namespace, "path": path == null ? [] : path, "uidIndex": context.uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
    let _g = [];
    let _g1 = 0;
    while (_g1 < body.length) {
      let node = body[_g1];
      ++_g1;
      if (useTld) {
        _g.push(this.transformTld(node, newContext));
      } else {
        _g.push(this.transformCommand(node, newContext));
      }
      ;
    }
    ;
    let res = AstNode.Group(_g);
    if (useTld) {
      context.compiler.addTopLevelAstNode(res);
    }
    ;
    if (useTld) {
      return AstNode.Void;
    } else {
      return res;
    }
    ;
  }
  embed(context, pos, varmap, body, useTld) {
    if (useTld == null) {
      useTld = false;
    }
    ;
    let namespace = context.namespace;
    let append = context.append;
    let _this = context.globalVariables;
    let variableMap = new VariableMap(VariableMap.globals, (varmap == null ? _this : new VariableMap(_this, varmap)).get());
    let path = context.path;
    let newContext = { "append": append, "namespace": namespace, "path": path == null ? [] : path, "uidIndex": context.uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
    let _g = 0;
    while (_g < body.length) {
      let node = body[_g];
      ++_g;
      if (useTld) {
        this.compileTld(node, newContext);
      } else {
        this.compileCommand(node, newContext);
      }
      ;
    }
    ;
  }
  transformTemplate(context, pos, value, extras, isMacro) {
    if (context.compiler.templateParsingEnabled) {
      if (value.startsWith("template ")) {
        value = value.substring(9);
      }
      ;
      let map = context.templates;
      let _g_map = map;
      let _g_keys = map.keys();
      while (_g_keys.hasNext()) {
        let key = _g_keys.next();
        let _g_value = _g_map.get(key);
        let _g_key = key;
        let k = _g_key;
        let v = _g_value;
        if (value == k || value.startsWith(k)) {
          return v.transform(this, context, pos, value, extras);
        }
        ;
      }
      ;
      if (extras != null && extras.length > 0) {
        throw new CompilerError(ErrorUtil.formatContext("Unexpected extra data in non template command", pos, context), false, [pos].concat(context.stack));
      }
      ;
    }
    ;
    return AstNode.Raw(pos, this.injectValues(value, context, pos), extras, isMacro);
  }
  processTemplate(context, pos, value, extras, isMacro) {
    if (context.compiler.templateParsingEnabled) {
      if (value.startsWith("template ")) {
        value = value.substring(9);
      }
      ;
      let map = context.templates;
      let _g_map = map;
      let _g_keys = map.keys();
      while (_g_keys.hasNext()) {
        let key = _g_keys.next();
        let _g_value = _g_map.get(key);
        let _g_key = key;
        let k = _g_key;
        let v = _g_value;
        if (value == k || value.startsWith(k)) {
          v.process(this, context, pos, value, extras);
          return;
        }
        ;
      }
      ;
      if (extras != null && extras.length > 0) {
        throw new CompilerError(ErrorUtil.formatContext("Unexpected extra data in non template command", pos, context), false, [pos].concat(context.stack));
      }
      ;
    }
    ;
    let cmd = this.injectValues(value, context, pos);
    context.append((isMacro ? "$" : "") + cmd);
  }
  compileInline(context, code, isTLD) {
    if (isTLD == null) {
      isTLD = false;
    }
    ;
    let tokens = Tokenizer.tokenize(code, "<inline " + this.name + ">");
    let tokenInput = new ArrayInput(tokens);
    let astNodes = [];
    while (tokenInput.hasNext())
      if (isTLD) {
        astNodes.push(Parser.parseTLD(tokenInput));
      } else {
        astNodes.push(Parser.innerParse(tokenInput));
      }
    ;
    if (isTLD) {
      let _g = 0;
      while (_g < astNodes.length) {
        let node = astNodes[_g];
        ++_g;
        this.compileTld(node, context);
      }
      ;
    } else {
      let _g = 0;
      while (_g < astNodes.length) {
        let node = astNodes[_g];
        ++_g;
        this.compileCommand(node, context);
      }
      ;
    }
    ;
  }
  transformInline(context, code, isTLD) {
    if (isTLD == null) {
      isTLD = false;
    }
    ;
    let tokens = Tokenizer.tokenize(code, "<inline " + this.name + ">");
    let tokenInput = new ArrayInput(tokens);
    let astNodes = [];
    while (tokenInput.hasNext())
      if (isTLD) {
        astNodes.push(Parser.parseTLD(tokenInput));
      } else {
        astNodes.push(Parser.innerParse(tokenInput));
      }
    ;
    let tmp;
    if (isTLD) {
      let _g = [];
      let _g1 = 0;
      while (_g1 < astNodes.length) {
        let node = astNodes[_g1];
        ++_g1;
        _g.push(this.transformTld(node, context));
      }
      ;
      tmp = _g;
    } else {
      let _g = [];
      let _g1 = 0;
      while (_g1 < astNodes.length) {
        let node = astNodes[_g1];
        ++_g1;
        _g.push(this.transformCommand(node, context));
      }
      ;
      tmp = _g;
    }
    ;
    return AstNode.Group(tmp);
  }
  processMlScript(context, pos, tokens, isTLD) {
    if (isTLD == null) {
      isTLD = false;
    }
    ;
    let str = "";
    let _g = 0;
    while (_g < tokens.length) {
      let t = tokens[_g];
      ++_g;
      switch (t._hx_index) {
        case 0:
          let v = t.v;
          let pos2 = t.pos;
          str += v + "\n";
          break;
        case 1:
          let pos1 = t.pos;
          let data = t.data;
          str += "{" + data;
          break;
        case 2:
          let pos22 = t.pos;
          str += "}";
          break;
      }
      ;
    }
    ;
    let names = ["emit", "context", "embed", "require"];
    let emit = function(c) {
      context.append(c);
    };
    let _gthis = this;
    let emitMcb = function(code) {
      _gthis.compileInline(context, code, isTLD);
    };
    let emitBlock = function(commands, data) {
      let id = "" + context.compiler.config.generatedDirName + "/" + Std.string(context.uidIndex.get());
      let path = Path2.join(["data", context.namespace, _gthis.functionsDir].concat(context.path.concat([id + ".mcfunction"])));
      let content = commands.join("\n");
      if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
        content = context.compiler.config.header + "\n" + content;
      }
      ;
      context.compiler.io.write(path, content);
      let signature = "" + context.namespace + ":" + context.path.concat([id]).join("/");
      context.append("function " + signature + (data == null ? "" : " " + data));
      return signature;
    };
    emit.mcb = emitMcb;
    if (!isTLD) {
      emit.block = emitBlock;
    }
    ;
    let values = [emit, context, function(v) {
      if (isTLD) {
        throw new CompilerError(ErrorUtil.formatContext("embed not available in toplevel script blocks", pos, context), false, [pos].concat(context.stack));
      }
      ;
      return v.embedTo(context, pos, _gthis);
    }, context.compiler.disableRequire ? function(s) {
      throw new CompilerError(ErrorUtil.formatContext("Require not available as it has been disabled, please disable compiler.disableRequire", pos, context), false, [pos].concat(context.stack));
    } : Module.createRequire(this.name)];
    let jsEnv = context.variables.get();
    let map = jsEnv;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      names.push(k);
      values.push(v);
    }
    ;
    try {
      new Function(...names, str)(...values);
    } catch (_g2) {
      let e = Exception.caught(_g2);
      if (e instanceof McbError) {
        throw Exception.thrown(e);
      } else {
        throw new CompilerError(ErrorUtil.formatContext("Error in multi-line script, '" + e.get_message() + "' at " + pos.file + ":" + pos.line + ":" + (pos.col + 1), pos, context), false, [pos].concat(context.stack));
      }
      ;
    }
    ;
  }
  processMlScriptTransform(context, pos, tokens, isTLD) {
    if (isTLD == null) {
      isTLD = false;
    }
    ;
    let str = "";
    let _g = 0;
    while (_g < tokens.length) {
      let t = tokens[_g];
      ++_g;
      switch (t._hx_index) {
        case 0:
          let v = t.v;
          let pos2 = t.pos;
          str += v + "\n";
          break;
        case 1:
          let pos1 = t.pos;
          let data = t.data;
          str += "{" + data;
          break;
        case 2:
          let pos22 = t.pos;
          str += "}";
          break;
      }
      ;
    }
    ;
    let names = ["emit", "context", "embed", "require"];
    let results = [];
    let emit = function(c) {
      return results.push(AstNode.Raw(pos, c, [], null));
    };
    let _gthis = this;
    let emitMcb = function(code) {
      results.push(_gthis.transformInline(context, code, isTLD));
    };
    let emitBlock = function(commands, data) {
      let id = context.uidIndex.get();
      let context1 = context.compiler;
      let pos1 = pos;
      let pos2 = pos;
      let emitBlock2 = "block_" + id;
      let _g2 = [];
      let _g1 = 0;
      while (_g1 < commands.length) {
        let c = commands[_g1];
        ++_g1;
        _g2.push(AstNode.Raw(pos, c, [], false));
      }
      ;
      context1.addTopLevelAstNode(AstNode.Directory(pos1, "mcb_emmited_blocks", [AstNode.FunctionDef(pos2, emitBlock2, _g2, null)]));
      results.push(AstNode.FunctionCall(pos, context.namespace + ":" + context.baseNamespaceInfo.path.concat(["mcb_emmited_blocks", "block_" + id]).join("/"), data == null ? null : _gthis.injectValues(data, context, pos), false));
      return context.namespace + ":" + context.baseNamespaceInfo.path.concat(["mcb_emmited_blocks", "block_" + id]).join("/");
    };
    emit.mcb = emitMcb;
    if (!isTLD) {
      emit.block = emitBlock;
    }
    ;
    let values = [emit, context, function(v) {
      if (isTLD) {
        throw new CompilerError(ErrorUtil.formatContext("embed not available in toplevel script blocks", pos, context), false, [pos].concat(context.stack));
      }
      ;
      return v.embedTo(context, pos, _gthis, false);
    }, context.compiler.disableRequire ? function(s) {
      throw new CompilerError(ErrorUtil.formatContext("Require not available as it has been disabled, please disable compiler.disableRequire", pos, context), false, [pos].concat(context.stack));
    } : Module.createRequire(this.name)];
    let jsEnv = context.variables.get();
    let map = jsEnv;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      names.push(k);
      values.push(v);
    }
    ;
    try {
      new Function(...names, str)(...values);
    } catch (_g2) {
      let e = Exception.caught(_g2);
      if (e instanceof McbError) {
        throw Exception.thrown(e);
      } else {
        throw new CompilerError(ErrorUtil.formatContext("Error in multi-line script, '" + e.get_message() + "' at " + pos.file + ":" + pos.line + ":" + (pos.col + 1), pos, context), false, [pos].concat(context.stack));
      }
      ;
    }
    ;
    return AstNode.Group(results);
  }
  transformCommand(node, context) {
    let _gthis = this;
    switch (node._hx_index) {
      case 0:
        let pos = node.pos;
        let value = node.value;
        let extras = node.continuations;
        let isMacro = node.isMacro;
        return this.transformTemplate(context, pos, value, extras, isMacro);
        break;
      case 5:
        let pos1 = node.pos;
        let expression = node.expression;
        let as = node.as;
        let body = node.body;
        let nodes = [];
        this.processCompilerLoop(expression, as, context, body, pos1, function(ctx, v) {
          nodes.push(_gthis.transformCommand(v, ctx));
        });
        return AstNode.Group(nodes);
        break;
      case 6:
        let pos2 = node.pos;
        let expression1 = node.expression;
        let body1 = node.body;
        let elseExpressions = node.elseExpressions;
        return this.transformCompileTimeIf(expression1, body1, elseExpressions, pos2, context, function(v) {
          return _gthis.transformCommand(v, context);
        });
        break;
      case 7:
        let pos3 = node.pos;
        let value1 = node.value;
        return this.processMlScriptTransform(context, pos3, value1);
        break;
      case 8:
        let pos4 = node.pos;
        let name = node.name;
        let body2 = node.body;
        let data = node.data;
        let isMacro1 = node.isMacro;
        let isInline = node.isInline;
        let tmp = this.injectValues(name, context, pos4);
        let _g = [];
        let _g1 = 0;
        while (_g1 < body2.length) {
          let node2 = body2[_g1];
          ++_g1;
          _g.push(this.transformCommand(node2, context));
        }
        ;
        return AstNode.Block(pos4, tmp, _g, this.injectValues(data, context, pos4), isMacro1, isInline);
        break;
      case 9:
        let pos5 = node.pos;
        let body3 = node.body;
        let _g2 = [];
        let _g3 = 0;
        while (_g3 < body3.length) {
          let node2 = body3[_g3];
          ++_g3;
          _g2.push(this.transformCommand(node2, context));
        }
        ;
        return AstNode.TickBlock(pos5, _g2);
        break;
      case 10:
        let pos6 = node.pos;
        let body4 = node.body;
        let _g4 = [];
        let _g5 = 0;
        while (_g5 < body4.length) {
          let node2 = body4[_g5];
          ++_g5;
          _g4.push(this.transformCommand(node2, context));
        }
        ;
        return AstNode.LoadBlock(pos6, _g4);
        break;
      case 11:
        let pos7 = node.pos;
        let execute = node.execute;
        let data1 = node.data;
        let body5 = node.body;
        let continuations = node.continuations;
        let isMacro2 = node.isMacro;
        let tmp1 = this.injectValues(execute, context, pos7);
        let tmp2 = this.injectValues(data1, context, pos7);
        let _g6 = [];
        let _g7 = 0;
        while (_g7 < body5.length) {
          let node2 = body5[_g7];
          ++_g7;
          _g6.push(this.transformCommand(node2, context));
        }
        ;
        let tmp3 = _g6;
        let tmp4;
        if (continuations == null) {
          tmp4 = [];
        } else {
          let _g10 = [];
          let _g12 = 0;
          while (_g12 < continuations.length) {
            let node2 = continuations[_g12];
            ++_g12;
            _g10.push(this.transformCommand(node2, context));
          }
          ;
          tmp4 = _g10;
        }
        ;
        return AstNode.ExecuteBlock(pos7, tmp1, tmp2, tmp3, tmp4, isMacro2);
        break;
      case 12:
        let pos8 = node.pos;
        let delay = node.delay;
        let type = node.type;
        let body6 = node.body;
        let isMacro3 = node.isMacro;
        let tmp5 = this.injectValues(delay, context, pos8);
        let tmp6 = this.injectValues(type, context, pos8);
        let _g8 = [];
        let _g9 = 0;
        while (_g9 < body6.length) {
          let node2 = body6[_g9];
          ++_g9;
          _g8.push(this.transformCommand(node2, context));
        }
        ;
        return AstNode.ScheduleBlock(pos8, tmp5, tmp6, _g8, isMacro3);
        break;
      case 15:
        let pos9 = node.pos;
        let value2 = node.value;
        if (context.compiler.config.dontEmitComments) {
          return AstNode.Void;
        } else {
          return AstNode.Comment(pos9, value2);
        }
        ;
        break;
      case 19:
        let pos10 = node.pos;
        let command = node.command;
        let value3 = node.value;
        let isMacro4 = node.isMacro;
        return AstNode.Execute(pos10, this.injectValues(command, context, pos10), this.transformCommand(value3, context), isMacro4);
        break;
      case 20:
        let pos11 = node.pos;
        let name1 = node.name;
        let data2 = node.data;
        let isMacro5 = node.isMacro;
        return AstNode.FunctionCall(pos11, this.injectValues(name1, context, pos11), this.injectValues(data2, context, pos11), isMacro5);
        break;
      case 21:
        let pos12 = node.pos;
        let command1 = node.command;
        return AstNode.EqCommand(pos12, this.injectValues(command1, context, pos12));
        break;
      case 22:
        let pos13 = node.pos;
        let delay1 = node.delay;
        let target = node.target;
        let mode = node.mode;
        let isMacro6 = node.isMacro;
        return AstNode.ScheduleCall(pos13, this.injectValues(delay1, context, pos13), this.injectValues(target, context, pos13), this.injectValues(mode, context, pos13), isMacro6);
        break;
      case 23:
        let pos14 = node.pos;
        let value4 = node.value;
        let isMacro7 = node.isMacro;
        return AstNode.ReturnRun(pos14, this.transformCommand(value4, context), isMacro7);
        break;
      case 24:
        let pos15 = node.pos;
        let target1 = node.target;
        let isMacro8 = node.isMacro;
        return AstNode.ScheduleClear(pos15, this.injectValues(target1, context, pos15), isMacro8);
        break;
      default:
        debugger;
        console.log("src/mcl/Compiler.hx:897:", Std.string(node));
        throw Exception.thrown("Unexpected node type in transformCommand: " + Std.string(node));
    }
    ;
  }
  evaluateFunctionHandle(handle, context, pos, isMacro) {
    let name = this.injectValues(handle, context, pos);
    let tagPrefix = name.charAt(0) == "#" ? "#" : "";
    if (tagPrefix != "") {
      name = name.substring(1);
    }
    ;
    switch (name.charAt(0)) {
      case "*":
        return "" + tagPrefix + context.namespace + ":" + name.substring(1);
        break;
      case ".":
        if (name.charAt(1) == "/" || name.charAt(1) == "." && name.charAt(2) == "/") {
          let path = context.currentFunction.concat(name.split("/"));
          let resolved = [];
          let _g = 0;
          while (_g < path.length) {
            let node = path[_g];
            ++_g;
            switch (node) {
              case "":
              case ".":
                break;
              case "..":
                if (resolved.length == 0) {
                  throw new CompilerError(ErrorUtil.formatContext("Invalid call: " + name, pos, context), false, [pos].concat(context.stack));
                }
                ;
                resolved.pop();
                break;
              default:
                resolved.push(node);
            }
            ;
          }
          ;
          return "" + tagPrefix + context.namespace + ":" + resolved.join("/");
        } else {
          if (name.indexOf(":") == -1) {
            name = "" + context.namespace + ":" + context.path.concat([name]).join("/");
          }
          ;
          return "" + tagPrefix + name;
        }
        ;
        break;
      case "^":
        let levels = Std.parseInt(name.substring(1));
        let fn = context.functions[context.functions.length - levels - 1];
        if (fn == null) {
          throw new CompilerError(ErrorUtil.formatContext("Unexpected call: " + name, pos, context), false, [pos].concat(context.stack));
        }
        ;
        return "" + tagPrefix + fn;
        break;
      default:
        if (name.indexOf(":") == -1) {
          name = "" + context.namespace + ":" + context.path.concat([name]).join("/");
        }
        ;
        return "" + tagPrefix + name;
    }
    ;
  }
  compileCommand(node, context) {
    let _gthis = this;
    switch (node._hx_index) {
      case 0:
        let pos = node.pos;
        let value = node.value;
        let extras = node.continuations;
        let isMacro = node.isMacro;
        this.processTemplate(context, pos, value, extras, isMacro);
        break;
      case 5:
        let pos1 = node.pos;
        let expression = node.expression;
        let as = node.as;
        let body = node.body;
        this.processCompilerLoop(expression, as, context, body, pos1, function(context7, v) {
          _gthis.compileCommand(v, context7);
        });
        break;
      case 6:
        let pos2 = node.pos;
        let expression1 = node.expression;
        let body1 = node.body;
        let elseExpressions = node.elseExpressions;
        this.compileTimeIf(expression1, body1, elseExpressions, pos2, context, function(v) {
          _gthis.compileCommand(v, context);
        });
        break;
      case 7:
        let pos3 = node.pos;
        let value1 = node.value;
        this.processMlScript(context, pos3, value1);
        break;
      case 8:
        let _g = node.pos;
        let _g1 = node.name;
        let _g2 = node.body;
        let _g3 = node.data;
        let _g4 = node.isMacro;
        let _g5 = node.isInline;
        if (_g1 == null) {
          let pos14 = _g;
          let body6 = _g2;
          let data2 = _g3;
          let isMacro8 = _g4;
          let isInline = _g5;
          if (isInline) {
            if (data2 != null) {
              throw new CompilerError(ErrorUtil.formatContext("Inline block cannot have data", pos14, context), false, [pos14].concat(context.stack));
            } else {
              let _g13 = 0;
              while (_g13 < body6.length) {
                let node2 = body6[_g13];
                ++_g13;
                this.compileCommand(node2, context);
              }
              ;
            }
            ;
          } else {
            let context12 = context;
            let tmp3 = this.createAnonymousFunction(pos14, body6, data2, context, null, isMacro8);
            context12.append(tmp3);
          }
          ;
        } else if (_g1 == "") {
          let pos14 = _g;
          let body6 = _g2;
          let data2 = _g3;
          let isMacro8 = _g4;
          let isInline = _g5;
          if (isInline) {
            if (data2 != null) {
              throw new CompilerError(ErrorUtil.formatContext("Inline block cannot have data", pos14, context), false, [pos14].concat(context.stack));
            } else {
              let _g13 = 0;
              while (_g13 < body6.length) {
                let node2 = body6[_g13];
                ++_g13;
                this.compileCommand(node2, context);
              }
              ;
            }
            ;
          } else {
            let context12 = context;
            let tmp3 = this.createAnonymousFunction(pos14, body6, data2, context, null, isMacro8);
            context12.append(tmp3);
          }
          ;
        } else {
          let name3 = _g1;
          let pos14 = _g;
          let body6 = _g2;
          let data2 = _g3;
          let isMacro8 = _g4;
          let isInline = _g5;
          if (isInline) {
            if (data2 != null) {
              throw new CompilerError(ErrorUtil.formatContext("Inline block cannot have data", pos14, context), false, [pos14].concat(context.stack));
            } else {
              let _g13 = 0;
              while (_g13 < body6.length) {
                let node2 = body6[_g13];
                ++_g13;
                this.compileCommand(node2, context);
              }
              ;
            }
            ;
          } else {
            let context12 = context;
            let tmp3 = this.createAnonymousFunction(pos14, body6, data2, context, name3, isMacro8);
            context12.append(tmp3);
          }
          ;
        }
        ;
        break;
      case 9:
        let pos4 = node.pos;
        let body2 = node.body;
        let functions = context.functions.concat([null]);
        let path = context.path;
        let newContext = { "append": function(v) {
          _gthis.tickCommands.push(v);
        }, "namespace": context.namespace, "path": path == null ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        let _g6 = 0;
        while (_g6 < body2.length) {
          let node2 = body2[_g6];
          ++_g6;
          this.compileCommand(node2, newContext);
        }
        ;
        break;
      case 10:
        let pos5 = node.pos;
        let body3 = node.body;
        let functions1 = context.functions.concat([null]);
        let path1 = context.path;
        let newContext1 = { "append": function(v) {
          _gthis.loadCommands.push(v);
        }, "namespace": context.namespace, "path": path1 == null ? [] : path1, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions1, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        let _g7 = 0;
        while (_g7 < body3.length) {
          let node2 = body3[_g7];
          ++_g7;
          this.compileCommand(node2, newContext1);
        }
        ;
        break;
      case 11:
        let pos6 = node.pos;
        let execute = node.execute;
        let data = node.data;
        let body4 = node.body;
        let continuations = node.continuations;
        let isMacro1 = node.isMacro;
        let commands = [];
        let append = function(command2) {
          commands.push(command2);
        };
        let uid = Std.string(context.uidIndex.get());
        let callSignature = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, uid]).join("/");
        let functions2 = context.functions.concat([callSignature]);
        let path2 = context.path;
        let newContext2 = { "append": append, "namespace": context.namespace, "path": path2 == null ? [] : path2, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions2, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        if (continuations != null) {
          context.append("scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 0");
          newContext2.append("scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 1");
        }
        ;
        let _g8 = 0;
        while (_g8 < body4.length) {
          let node2 = body4[_g8];
          ++_g8;
          this.compileCommand(node2, newContext2);
        }
        ;
        let result = commands.join("\n");
        let path3 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, uid + ".mcfunction"])));
        let content = result;
        if (context.compiler.config.header.length > 0 && path3.endsWith(".mcfunction")) {
          content = context.compiler.config.header + "\n" + content;
        }
        ;
        context.compiler.io.write(path3, content);
        let context1 = context;
        let tmp = this.injectValues((isMacro1 ? "$" : "") + ("" + execute + " function " + callSignature + (data == null ? "" : " " + data)), context, pos6);
        context1.append(tmp);
        if (continuations != null) {
          let idx = 0;
          let _g13 = 0;
          while (_g13 < continuations.length) {
            let continuation = continuations[_g13];
            ++_g13;
            let isDone = idx == continuations.length - 1;
            switch (continuation._hx_index) {
              case 8:
                let _g14 = continuation.pos;
                let _g22 = continuation.name;
                let _g32 = continuation.isInline;
                let body6 = continuation.body;
                let data2 = continuation.data;
                let isMacro22 = continuation.isMacro;
                let embedCommands = ["scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 1"];
                if (!isDone) {
                  throw new CompilerError("block continuation must be the last continuation", true);
                }
                ;
                let appendEmbed = function(command2) {
                  embedCommands.push(command2);
                };
                let id2 = Std.string(context.uidIndex.get());
                let callSignature2 = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id2]).join("/");
                let functions4 = context.functions.concat([callSignature2]);
                let path8 = context.path;
                let embedContext = { "append": appendEmbed, "namespace": context.namespace, "path": path8 == null ? [] : path8, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions4, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
                let _g42 = 0;
                while (_g42 < body6.length) {
                  let node2 = body6[_g42];
                  ++_g42;
                  this.compileCommand(node2, embedContext);
                }
                ;
                let result2 = embedCommands.join("\n");
                let path12 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, id2 + ".mcfunction"])));
                let content3 = result2;
                if (context.compiler.config.header.length > 0 && path12.endsWith(".mcfunction")) {
                  content3 = context.compiler.config.header + "\n" + content3;
                }
                ;
                context.compiler.io.write(path12, content3);
                let context12 = context;
                let cmd5 = "execute if score #ifelse " + context.compiler.config.internalScoreboardName + " matches 0 run function " + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id2]).join("/");
                context12.append((isMacro22 ? "$" : "") + (cmd5 + (data2 == null ? "" : " " + data2)));
                break;
              case 11:
                let _g52 = continuation.continuations;
                let pos14 = continuation.pos;
                let execute2 = continuation.execute;
                let data12 = continuation.data;
                let body12 = continuation.body;
                let isMacro21 = continuation.isMacro;
                let embedCommands1 = ["scoreboard players set #ifelse " + context.compiler.config.internalScoreboardName + " 1"];
                let embedAppend = function(command2) {
                  embedCommands1.push(command2);
                };
                let id1 = Std.string(context.uidIndex.get());
                let callSignature12 = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id1]).join("/");
                let functions12 = context.functions.concat([callSignature12]);
                let path22 = context.path;
                let embedContext1 = { "append": embedAppend, "namespace": context.namespace, "path": path22 == null ? [] : path22, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions12, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
                let _g62 = 0;
                while (_g62 < body12.length) {
                  let node2 = body12[_g62];
                  ++_g62;
                  this.compileCommand(node2, embedContext1);
                }
                ;
                let result12 = embedCommands1.join("\n");
                let path32 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, id1 + ".mcfunction"])));
                let content12 = result12;
                if (context.compiler.config.header.length > 0 && path32.endsWith(".mcfunction")) {
                  content12 = context.compiler.config.header + "\n" + content12;
                }
                ;
                context.compiler.io.write(path32, content12);
                let executeCommandArgs = execute2.startsWith("execute ") ? execute2.substring(8) : execute2;
                let context22 = context;
                let cmd12 = "execute if score #ifelse " + context.compiler.config.internalScoreboardName + " matches 0 " + executeCommandArgs + " function " + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id1]).join("/");
                context22.append((isMacro21 ? "$" : "") + (cmd12 + (data12 == null ? "" : " " + data12)));
                break;
              default:
                let pos15 = continuation.pos;
                throw new CompilerError(ErrorUtil.formatContext("Unexpected continuation type: " + Std.string(continuation), pos15, newContext2), false, [pos15].concat(newContext2.stack));
            }
            ;
            ++idx;
          }
          ;
        }
        ;
        break;
      case 12:
        let pos7 = node.pos;
        let delay = node.delay;
        let type = node.type;
        let body5 = node.body;
        let isMacro2 = node.isMacro;
        delay = this.injectValues(delay, context, pos7);
        type = this.injectValues(type, context, pos7);
        let commands1 = [];
        let append1 = function(command2) {
          commands1.push(command2);
        };
        let uid1 = Std.string(context.uidIndex.get());
        let callSignature1 = "" + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, uid1]).join("/");
        let functions3 = context.functions.concat([callSignature1]);
        let path4 = context.path;
        let newContext3 = { "append": append1, "namespace": context.namespace, "path": path4 == null ? [] : path4, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions3, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        let _g9 = 0;
        while (_g9 < body5.length) {
          let node2 = body5[_g9];
          ++_g9;
          this.compileCommand(node2, newContext3);
        }
        ;
        let result1 = commands1.join("\n");
        let id = Std.string(context.uidIndex.get());
        let path5 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, id + ".mcfunction"])));
        let content1 = result1;
        if (context.compiler.config.header.length > 0 && path5.endsWith(".mcfunction")) {
          content1 = context.compiler.config.header + "\n" + content1;
        }
        ;
        context.compiler.io.write(path5, content1);
        let context2 = context;
        let cmd = "schedule function " + context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, id]).join("/") + " " + delay + " " + type;
        context2.append((isMacro2 ? "$" : "") + cmd);
        break;
      case 15:
        let _g10 = node.pos;
        let value2 = node.value;
        if (!context.compiler.config.dontEmitComments) {
          context.append(value2);
        }
        ;
        break;
      case 19:
        let pos8 = node.pos;
        let command = node.command;
        let value3 = node.value;
        let isMacro3 = node.isMacro;
        let commands2 = [];
        let path6 = context.path;
        let newContext4 = { "append": function(v) {
          commands2.push(v);
        }, "namespace": context.namespace, "path": path6 == null ? [] : path6, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        this.compileCommand(value3, newContext4);
        if (commands2.length != 1) {
          throw new CompilerError(ErrorUtil.formatContext("Expected exactly 1 command after execute, got " + commands2.length, pos8, context), false, [pos8].concat(context.stack));
        }
        ;
        let context3 = context;
        let tmp1 = this.injectValues((isMacro3 ? "$" : "") + ("" + command + " " + commands2[0]), context, pos8);
        context3.append(tmp1);
        break;
      case 20:
        let pos9 = node.pos;
        let name = node.name;
        let data1 = node.data;
        let isMacro4 = node.isMacro;
        let context4 = context;
        let cmd1 = "function " + this.evaluateFunctionHandle(name, context, pos9, isMacro4);
        let cmd2 = data1.length == 0 ? "" : " " + this.injectValues(data1, context, pos9);
        let tmp2 = this.injectValues((isMacro4 ? "$" : "") + (cmd1 + cmd2), context, pos9);
        context4.append(tmp2);
        break;
      case 21:
        let pos10 = node.pos;
        let command1 = node.command;
        let res = McMath.compile(this.injectValues(command1, context, pos10), context);
        context.append(res.commands);
        let addScoreboardCommand = "scoreboard objectives add " + context.compiler.config.eqConstScoreboardName + " dummy";
        if (!this.loadCommands.includes(addScoreboardCommand)) {
          this.loadCommands.push(addScoreboardCommand);
        }
        ;
        addScoreboardCommand = "scoreboard objectives add " + context.compiler.config.eqVarScoreboardName + " dummy";
        if (!this.loadCommands.includes(addScoreboardCommand)) {
          this.loadCommands.push(addScoreboardCommand);
        }
        ;
        let _g11 = 0;
        let _g12 = res.constants;
        while (_g11 < _g12.length) {
          let k = _g12[_g11];
          ++_g11;
          let cmd5 = "scoreboard players set " + k + " " + context.compiler.config.eqConstScoreboardName + " " + k;
          if (!this.loadCommands.includes(cmd5)) {
            this.loadCommands.push(cmd5);
          }
          ;
        }
        ;
        break;
      case 22:
        let pos11 = node.pos;
        let delay1 = node.delay;
        let name1 = node.target;
        let mode = node.mode;
        let isMacro5 = node.isMacro;
        delay1 = this.injectValues(delay1, context, pos11);
        mode = this.injectValues(mode, context, pos11);
        let context5 = context;
        let cmd3 = "schedule function " + this.evaluateFunctionHandle(name1, context, pos11, isMacro5) + " " + delay1 + " " + mode;
        context5.append((isMacro5 ? "$" : "") + cmd3);
        break;
      case 23:
        let pos12 = node.pos;
        let value4 = node.value;
        let isMacro6 = node.isMacro;
        let content2 = [];
        let path7 = context.path;
        let newContext5 = { "append": function(v) {
          content2.push(v);
        }, "namespace": context.namespace, "path": path7 == null ? [] : path7, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        this.compileCommand(value4, newContext5);
        if (content2.length != 1) {
          throw new CompilerError(ErrorUtil.formatContext("Expected exactly 1 command after return run, got " + content2.length, pos12, context), false, [pos12].concat(context.stack));
        }
        ;
        context.append((isMacro6 ? "$" : "") + ("return run " + content2[0]));
        break;
      case 24:
        let pos13 = node.pos;
        let name2 = node.target;
        let isMacro7 = node.isMacro;
        let context6 = context;
        let cmd4 = "schedule clear " + this.evaluateFunctionHandle(name2, context, pos13, isMacro7);
        context6.append((isMacro7 ? "$" : "") + cmd4);
        break;
      default:
        debugger;
        console.log("src/mcl/Compiler.hx:1275:", Std.string(node));
    }
    ;
  }
  compileFunction(pos, name, body, appendTo, context) {
    name = this.injectValues(name, context, pos);
    let commands = [];
    let append = function(command) {
      commands.push(command);
    };
    let funcId = context.namespace + ":" + context.path.concat([name]).join("/");
    let functions = context.functions.concat([funcId]);
    let path = context.path;
    let newContext = { "append": append, "namespace": context.namespace, "path": path == null ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
    newContext.currentFunction = context.path;
    let _g = 0;
    while (_g < body.length) {
      let node = body[_g];
      ++_g;
      this.compileCommand(node, newContext);
    }
    ;
    if (appendTo != null) {
      context.compiler.tags.addTagEntry(this.injectValues(appendTo, context, pos), funcId, context);
    }
    ;
    let path1 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([name + ".mcfunction"])));
    let content = commands.join("\n");
    if (context.compiler.config.header.length > 0 && path1.endsWith(".mcfunction")) {
      content = context.compiler.config.header + "\n" + content;
    }
    ;
    context.compiler.io.write(path1, content);
  }
  compileDirectory(pos, name, body, context) {
    name = this.injectValues(name, context, pos);
    let namespace = context.namespace;
    let variableMap = context.variables;
    let path = context.path.concat([name]);
    let uidIndex = new UidTracker();
    let newContext = { "append": function(v) {
      throw new CompilerError(ErrorUtil.formatContext("append not available for directory context", pos, context), true, [pos].concat(context.stack));
    }, "namespace": namespace, "path": path == null ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
    let _g = 0;
    while (_g < body.length) {
      let node = body[_g];
      ++_g;
      this.compileTld(node, newContext);
    }
    ;
  }
  transformTld(node, context) {
    let _gthis = this;
    switch (node._hx_index) {
      case 1:
        let pos = node.pos;
        let name = node.name;
        let body = node.body;
        let appendTo = node.appendTo;
        let tmp = this.injectValues(name, context, pos);
        let _g = [];
        let _g1 = 0;
        while (_g1 < body.length) {
          let node2 = body[_g1];
          ++_g1;
          _g.push(this.transformCommand(node2, context));
        }
        ;
        return AstNode.FunctionDef(pos, tmp, _g, appendTo);
        break;
      case 3:
        let pos1 = node.pos;
        let name1 = node.name;
        let body1 = node.body;
        let tmp1 = this.injectValues(name1, context, pos1);
        let _g2 = [];
        let _g3 = 0;
        while (_g3 < body1.length) {
          let node2 = body1[_g3];
          ++_g3;
          _g2.push(this.transformTld(node2, context));
        }
        ;
        return AstNode.Directory(pos1, tmp1, _g2);
        break;
      case 5:
        let pos2 = node.pos;
        let expression = node.expression;
        let as = node.as;
        let body2 = node.body;
        let results = [];
        this.processCompilerLoop(expression, as, context, body2, pos2, function(context2, v) {
          results.push(_gthis.transformTld(v, context2));
        });
        return AstNode.Group(results);
        break;
      case 6:
        let pos3 = node.pos;
        let expression1 = node.expression;
        let body3 = node.body;
        let elseExpressions = node.elseExpressions;
        return this.transformCompileTimeIf(expression1, body3, elseExpressions, pos3, context, function(v) {
          return _gthis.transformTld(v, context);
        });
        break;
      case 7:
        let pos4 = node.pos;
        let value = node.value;
        return this.processMlScriptTransform(context, pos4, value, true);
        break;
      case 15:
        let _g4 = node.pos;
        let _g5 = node.value;
        return node;
        break;
      case 16:
        let pos5 = node.pos;
        let name2 = node.name;
        let info = node.info;
        if (info._hx_index == 0) {
          let subType = info.subType;
          let replace = info.replace;
          let entries = info.entries;
          let _g8 = [];
          let _g12 = 0;
          while (_g12 < entries.length) {
            let e = entries[_g12];
            ++_g12;
            let tmp2;
            switch (e._hx_index) {
              case 0:
                let _g22 = e.continuations;
                if (_g22 == null) {
                  throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
                } else if (_g22.length == 0) {
                  if (e.isMacro == false) {
                    let pos9 = e.pos;
                    let value3 = e.value;
                    tmp2 = this.injectValues(value3, context, pos9);
                  } else {
                    throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
                  }
                  ;
                } else {
                  throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
                }
                ;
                break;
              case 15:
                let pos8 = e.pos;
                let value2 = e.value;
                tmp2 = this.injectValues(value2, context, pos8);
                break;
              default:
                throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos5, context), false, [pos5].concat(context.stack));
            }
            ;
            _g8.push(AstNode.Raw(pos5, this.injectValues(tmp2, context, pos5), [], false));
          }
          ;
          return AstNode.JsonFile(pos5, name2, JsonTagType.Tag(subType, replace, _g8));
        } else {
          return AstNode.JsonFile(pos5, this.injectValues(name2, context, pos5), info);
        }
        ;
        break;
      case 18:
        let pos6 = node.pos;
        let name3 = node.name;
        let time = node.time;
        let body4 = node.body;
        let _g6 = [];
        let _g7 = 0;
        while (_g7 < body4.length) {
          let node2 = body4[_g7];
          ++_g7;
          _g6.push(this.transformCommand(node2, context));
        }
        ;
        return AstNode.ClockExpr(pos6, name3, time, _g6);
        break;
      default:
        let pos7 = node.pos;
        throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(node), pos7, context), true, [pos7].concat(context.stack));
    }
    ;
  }
  compileTld(node, context) {
    let _gthis = this;
    switch (node._hx_index) {
      case 1:
        let pos = node.pos;
        let name = node.name;
        let body = node.body;
        let appendTo = node.appendTo;
        if (!context.isTemplate) {
          this.compileFunction(pos, name, body, appendTo, context);
        } else {
          let pos8 = node.pos;
          throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(node), pos8, context), true, [pos8].concat(context.stack));
        }
        ;
        break;
      case 3:
        let pos1 = node.pos;
        let name1 = node.name;
        let body1 = node.body;
        this.compileDirectory(pos1, name1, body1, context);
        break;
      case 5:
        let pos2 = node.pos;
        let expression = node.expression;
        let as = node.as;
        let body2 = node.body;
        this.processCompilerLoop(expression, as, context, body2, pos2, function(context2, v) {
          _gthis.compileTld(v, context2);
        });
        break;
      case 6:
        let pos3 = node.pos;
        let expression1 = node.expression;
        let body3 = node.body;
        let elseExpressions = node.elseExpressions;
        this.compileTimeIf(expression1, body3, elseExpressions, pos3, context, function(v) {
          _gthis.compileTld(v, context);
        });
        break;
      case 7:
        let pos4 = node.pos;
        let value = node.value;
        this.processMlScript(context, pos4, value, true);
        break;
      case 15:
        let _g = node.pos;
        let _g1 = node.value;
        break;
      case 16:
        let pos5 = node.pos;
        let name2 = node.name;
        let info = node.info;
        this.compileJsonFile(pos5, name2, info, context);
        break;
      case 18:
        let pos6 = node.pos;
        let name3 = node.name;
        let time = node.time;
        let body4 = node.body;
        let commands = [];
        let path = context.path;
        let newContext = { "append": function(v) {
          commands.push(v);
        }, "namespace": context.namespace, "path": path == null ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        let id = Std.string(context.uidIndex.get());
        let path1 = (name3 == null ? context.path.concat([context.compiler.config.generatedDirName, "" + id]) : context.path.concat([name3])).join("/");
        let functionId = context.namespace + ":" + path1;
        commands.push("schedule function " + functionId + " " + time + " replace");
        let _g2 = 0;
        while (_g2 < body4.length) {
          let node2 = body4[_g2];
          ++_g2;
          this.compileCommand(node2, newContext);
        }
        ;
        let result = commands.join("\n");
        let path2 = Path2.join(["data", context.namespace, this.functionsDir, "" + path1 + ".mcfunction"]);
        let content = result;
        if (context.compiler.config.header.length > 0 && path2.endsWith(".mcfunction")) {
          content = context.compiler.config.header + "\n" + content;
        }
        ;
        context.compiler.io.write(path2, content);
        context.compiler.tags.addTagEntry("minecraft:load", functionId, context);
        break;
      default:
        let pos7 = node.pos;
        throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(node), pos7, context), true, [pos7].concat(context.stack));
    }
    ;
  }
  compileJsonFileImpl(pos, name, info, entries, context) {
    let values = "{" + this.stringifyJsonTag(pos, name, entries, context) + "}";
    let type;
    switch (info._hx_index) {
      case 1:
        let _g = info.entries;
        type = context.compiler.config.features.useFolderRenames48 ? "advancement" : "advancements";
        break;
      case 2:
        let _g1 = info.entries;
        type = context.compiler.config.features.useFolderRenames48 ? "item_modifier" : "item_modifiers";
        break;
      case 3:
        let _g2 = info.entries;
        type = context.compiler.config.features.useFolderRenames48 ? "loot_table" : "loot_tables";
        break;
      case 4:
        let _g3 = info.entries;
        type = context.compiler.config.features.useFolderRenames48 ? "predicate" : "predicates";
        break;
      case 5:
        let _g4 = info.entries;
        type = context.compiler.config.features.useFolderRenames48 ? "recipe" : "recipes";
        break;
      case 6:
        let _g5 = info.entries;
        type = "chat";
        break;
      case 7:
        let _g6 = info.entries;
        type = "damage";
        break;
      case 8:
        let _g7 = info.entries;
        type = "dimension";
        break;
      case 9:
        let _g8 = info.entries;
        type = "dimension_type";
        break;
      case 10:
        let _g9 = info.entries;
        type = "enchantment";
        break;
      default:
        throw new CompilerError(ErrorUtil.formatContext("unexpected json tag type:" + Std.string(info), pos, context), true, [pos].concat(context.stack));
    }
    ;
    let path = Path2.join(["data", context.namespace, type].concat(context.path.concat([name + ".json"])));
    let content = values;
    if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
      content = context.compiler.config.header + "\n" + content;
    }
    ;
    context.compiler.io.write(path, content);
  }
  compileJsonFile(pos, name, info, context) {
    switch (info._hx_index) {
      case 0:
        let subType = info.subType;
        let replace = info.replace;
        let entries = info.entries;
        if (subType == "function" || subType == "functions") {
          name = context.namespace + ":" + context.path.concat([name]).join("/");
          context.compiler.tags.ensureTag(name, context);
          let _g = 0;
          while (_g < entries.length) {
            let e = entries[_g];
            ++_g;
            switch (e._hx_index) {
              case 0:
                let _g1 = e.continuations;
                if (_g1 == null) {
                  throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
                } else if (_g1.length == 0) {
                  if (e.isMacro == false) {
                    let pos2 = e.pos;
                    let value2 = e.value;
                    value2 = this.injectValues(value2, context, pos2);
                    if (value2.indexOf(" ") != -1 && value2.endsWith(" replace")) {
                      context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value2.substring(0, value2.length - 8), context, pos2, false), context, true);
                    } else if (value2.indexOf(" ") != -1) {
                      throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos2, context), false, [pos2].concat(context.stack));
                    } else {
                      context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value2, context, pos2, false), context, false);
                    }
                    ;
                  } else {
                    throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
                  }
                  ;
                } else {
                  throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
                }
                ;
                break;
              case 15:
                let pos1 = e.pos;
                let value = e.value;
                value = this.injectValues(value, context, pos1);
                if (value.indexOf(" ") != -1 && value.endsWith(" replace")) {
                  context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value.substring(0, value.length - 8), context, pos1, false), context, true);
                } else if (value.indexOf(" ") != -1) {
                  throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos1, context), false, [pos1].concat(context.stack));
                } else {
                  context.compiler.tags.addTagEntry(name, this.evaluateFunctionHandle(value, context, pos1, false), context, false);
                }
                ;
                break;
              default:
                throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
            }
            ;
          }
          ;
          if (replace) {
            context.compiler.tags.setTagReplace(name, context, true);
          }
          ;
        } else {
          let _g = [];
          let _g1 = 0;
          while (_g1 < entries.length) {
            let e = entries[_g1];
            ++_g1;
            let data2;
            switch (e._hx_index) {
              case 0:
                let _g2 = e.continuations;
                if (_g2 == null) {
                  throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
                } else if (_g2.length == 0) {
                  if (e.isMacro == false) {
                    let pos2 = e.pos;
                    let value2 = e.value;
                    value2 = this.injectValues(value2, context, pos2);
                    if (value2.indexOf(" ") != -1 && value2.endsWith(" replace")) {
                      data2 = { "id": this.evaluateFunctionHandle(value2.substring(0, value2.length - 8), context, pos2, false), "replace": true };
                    } else if (value2.indexOf(" ") != -1) {
                      throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos2, context), false, [pos2].concat(context.stack));
                    } else {
                      data2 = this.evaluateFunctionHandle(value2, context, pos2, false);
                    }
                    ;
                  } else {
                    throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
                  }
                  ;
                } else {
                  throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
                }
                ;
                break;
              case 15:
                let pos1 = e.pos;
                let value = e.value;
                value = this.injectValues(value, context, pos1);
                if (value.indexOf(" ") != -1 && value.endsWith(" replace")) {
                  data2 = { "id": this.evaluateFunctionHandle(value.substring(0, value.length - 8), context, pos1, false), "replace": true };
                } else if (value.indexOf(" ") != -1) {
                  throw new CompilerError(ErrorUtil.formatContext("Malformed tag entry", pos1, context), false, [pos1].concat(context.stack));
                } else {
                  data2 = this.evaluateFunctionHandle(value, context, pos1, false);
                }
                ;
                break;
              default:
                throw new CompilerError(ErrorUtil.formatContext("Unexpected node type in json tag", pos, context), false, [pos].concat(context.stack));
            }
            ;
            _g.push(data2);
          }
          ;
          let data = JSON.stringify({ "replace": replace, "values": _g });
          let isPlural = subType.charAt(subType.length - 1) == "s";
          let writePath = context.compiler.config.features.useFolderRenames48 ? isPlural ? subType.substring(0, subType.length - 1) : subType : isPlural ? subType : subType + "s";
          let path2 = Path2.join(["data", context.namespace, this.tagsDir, writePath].concat(context.path.concat([name + ".json"])));
          let content2 = data;
          if (context.compiler.config.header.length > 0 && path2.endsWith(".mcfunction")) {
            content2 = context.compiler.config.header + "\n" + content2;
          }
          ;
          context.compiler.io.write(path2, content2);
        }
        ;
        break;
      case 1:
        let entries1 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries1, context);
        break;
      case 2:
        let entries2 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries2, context);
        break;
      case 3:
        let entries3 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries3, context);
        break;
      case 4:
        let entries4 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries4, context);
        break;
      case 5:
        let entries5 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries5, context);
        break;
      case 6:
        let entries6 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries6, context);
        break;
      case 7:
        let entries7 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries7, context);
        break;
      case 8:
        let entries8 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries8, context);
        break;
      case 9:
        let entries9 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries9, context);
        break;
      case 10:
        let entries10 = info.entries;
        this.compileJsonFileImpl(pos, name, info, entries10, context);
        break;
      case 11:
        let subType1 = info.subType;
        let name1 = info.name;
        let entries11 = info.entries;
        let values = "{" + this.stringifyJsonTag(pos, name1, entries11, context) + "}";
        let path = Path2.join(["data", context.namespace, "worldgen", subType1].concat(context.path.concat([name1 + ".json"])));
        let content = values;
        if (context.compiler.config.header.length > 0 && path.endsWith(".mcfunction")) {
          content = context.compiler.config.header + "\n" + content;
        }
        ;
        context.compiler.io.write(path, content);
        break;
    }
    ;
  }
  processCompilerLoop(expression, as, context, body, pos, handler) {
    let itterator = McFile2.invokeExpressionInline(expression, context, pos);
    let v = itterator;
    while (v.hasNext()) {
      let v1 = v.next();
      if (as == null) {
        let _g = 0;
        while (_g < body.length) {
          let node = body[_g];
          ++_g;
          handler(context, node);
        }
        ;
      } else {
        let varMap = new StringMap();
        if (as.length == 1) {
          varMap.inst.set(as[0], v1);
        } else if (Array.isArray(as)) {
          if (v1.length < as.length) {
            throw new CompilerError(ErrorUtil.formatContext("Failed to destructure as there are fewer elements then requested", pos, context), false, [pos].concat(context.stack));
          }
          ;
          let _g2 = 0;
          let _g1 = as.length;
          while (_g2 < _g1) {
            let i = _g2++;
            varMap.inst.set(as[i], v1[i]);
          }
          ;
        } else {
          throw new CompilerError(ErrorUtil.formatContext("Invalid as clause", pos, context), false, [pos].concat(context.stack));
        }
        ;
        let namespace = context.namespace;
        let append = context.append;
        let _this = context.variables;
        let variableMap = varMap == null ? _this : new VariableMap(_this, varMap);
        let path = context.path;
        let newContext = { "append": append, "namespace": namespace, "path": path == null ? [] : path, "uidIndex": context.uidIndex, "variables": variableMap, "stack": context.stack, "replacements": context.variables, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
        let _g = 0;
        while (_g < body.length) {
          let node = body[_g];
          ++_g;
          handler(newContext, node);
        }
        ;
      }
      ;
    }
    ;
  }
  stringifyJsonTag(pos, name, value, context) {
    name = this.injectValues(name, context, pos);
    let values = [];
    let path = context.path;
    let newContext = { "append": function(v) {
      values.push(v);
    }, "namespace": context.namespace, "path": path == null ? [] : path, "uidIndex": context.uidIndex, "variables": context.variables, "stack": context.stack, "replacements": context.replacements, "isTemplate": this.ext == "mcbt", "templates": context.templates, "requireTemplateKeyword": context.requireTemplateKeyword, "compiler": context.compiler, "globalVariables": context.globalVariables, "functions": context.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": context.currentFunction };
    let _gthis = this;
    let _g = 0;
    while (_g < value.length) {
      let v = value[_g];
      ++_g;
      switch (v._hx_index) {
        case 0:
          if (v.isMacro == false) {
            let extra = v.continuations;
            let value2 = v.value;
            let pos3 = v.pos;
            if (extra != null && extra.length > 0) {
              throw new CompilerError(ErrorUtil.formatContext("Unexpected extra data in json tag", pos3, context), false, [pos3].concat(context.stack));
            }
            ;
            values.push(this.injectValues(value2, context, pos3));
          } else {
            let pos3 = v.pos;
            throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(v), pos3, context), true, [pos3].concat(context.stack));
          }
          ;
          break;
        case 5:
          let pos2 = v.pos;
          let expression = v.expression;
          let as = v.as;
          let body = v.body;
          this.processCompilerLoop(expression, as, context, body, pos2, function(context2, v2) {
            _gthis.compileCommand(v2, context2);
          });
          break;
        case 6:
          let pos1 = v.pos;
          let expression1 = v.expression;
          let body1 = v.body;
          let elseExpression = v.elseExpressions;
          this.compileTimeIf(expression1, body1, elseExpression, pos1, newContext, function(v2) {
            _gthis.compileCommand(v2, context);
          });
          break;
        default:
          let pos22 = v.pos;
          throw new CompilerError(ErrorUtil.formatContext("unexpected node type:" + Std.string(v), pos22, context), true, [pos22].concat(context.stack));
      }
      ;
    }
    ;
    return values.join("");
  }
  injectValues(target, context, pos) {
    if (target == null) {
      return "";
    }
    ;
    if (target.indexOf("<%") == -1) {
      return target;
    }
    ;
    let variables = context.variables.get();
    let argList = ["embed", "context"];
    let _gthis = this;
    let valueList = [function(v) {
      return v.embedTo(context, pos, _gthis);
    }, context];
    let map = variables;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      argList.push(k);
      valueList.push(v);
    }
    ;
    let segments = [];
    let values = [];
    let _g = 0;
    let _g1 = target.split("<%");
    while (_g < _g1.length) {
      let segment = _g1[_g];
      ++_g;
      let parts = segment.split("%>");
      if (parts.length == 1) {
        values.push(parts[0]);
        segments.push("$$context[" + Std.string(values.length - 1) + "]");
      } else {
        segments.push(parts[0]);
        values.push(parts[1]);
        segments.push("$$context[" + Std.string(values.length - 1) + "]");
      }
      ;
    }
    ;
    let code = "return ([" + segments.join(",") + "].join(''));";
    try {
      return new Function(...argList, "$$context", code).apply(null, valueList.concat([values]));
      ;
    } catch (_g2) {
      let e = Exception.caught(_g2);
      throw new CompilerError(ErrorUtil.formatContext(Parser.format("Encountered an error whilst evaluating expression '{}' at {}:{}:{}", e.get_message(), pos.file, pos.line, pos.col + 1), pos, context), false, [pos].concat(context.stack));
    }
    ;
  }
  transformCompileTimeIf(expression, body, elseExpression, pos, newContext, processNode, isContinuation) {
    if (isContinuation == null) {
      isContinuation = false;
    }
    ;
    let bool = McFile2.invokeExpressionInline(expression, newContext, pos);
    if (bool) {
      let _g = [];
      let _g1 = 0;
      while (_g1 < body.length) {
        let node = body[_g1];
        ++_g1;
        _g.push(processNode(node));
      }
      ;
      return AstNode.Group(_g);
    } else {
      let _g = 0;
      while (_g < elseExpression.length) {
        let elseNode = elseExpression[_g];
        ++_g;
        let invoke = elseNode.condition == null ? true : McFile2.invokeExpressionInline(elseNode.condition, newContext, pos);
        if (invoke) {
          let _g2 = [];
          let _g1 = 0;
          let _g22 = elseNode.node;
          while (_g1 < _g22.length) {
            let node = _g22[_g1];
            ++_g1;
            _g2.push(processNode(node));
          }
          ;
          return AstNode.Group(_g2);
        }
        ;
      }
      ;
      return AstNode.Void;
    }
    ;
  }
  compileTimeIf(expression, body, elseExpression, pos, newContext, processNode, isContinuation) {
    if (isContinuation == null) {
      isContinuation = false;
    }
    ;
    let bool = McFile2.invokeExpressionInline(expression, newContext, pos);
    if (bool) {
      let _g = 0;
      while (_g < body.length) {
        let node = body[_g];
        ++_g;
        processNode(node);
      }
      ;
    } else {
      let _g = 0;
      while (_g < elseExpression.length) {
        let elseNode = elseExpression[_g];
        ++_g;
        let invoke = elseNode.condition == null ? true : McFile2.invokeExpressionInline(elseNode.condition, newContext, pos);
        if (invoke) {
          let _g2 = 0;
          let _g1 = elseNode.node;
          while (_g2 < _g1.length) {
            let node = _g1[_g2];
            ++_g2;
            processNode(node);
          }
          ;
          return;
        }
        ;
      }
      ;
    }
    ;
  }
  transform(vars, compiler) {
    let info = compiler.getInitialPathInfo(this.name);
    let _g = new StringMap();
    let _g1 = 0;
    let _g2 = Reflect2.fields(this.fileJs);
    while (_g1 < _g2.length) {
      let k = _g2[_g1];
      ++_g1;
      _g.inst.set(k, Reflect2.field(this.fileJs, k));
    }
    ;
    let thisFileVars = new VariableMap(vars, _g);
    let namespace = info.namespace;
    let variableMap = new VariableMap(thisFileVars, Globals.map);
    let path = info.path;
    let uidIndex = new UidTracker();
    let replacements2 = new VariableMap(null, new StringMap());
    let context = { "append": function(v) {
      throw new CompilerError("append not available for top-level context", true);
    }, "namespace": namespace, "path": path == null ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": [], "replacements": replacements2, "isTemplate": this.ext == "mcbt", "templates": this.templates, "requireTemplateKeyword": this.ext == "mcbt", "compiler": compiler, "globalVariables": thisFileVars, "functions": [], "baseNamespaceInfo": info, "currentFunction": null };
    if (context.isTemplate) {
      if (this.ast.length > 0) {
        let pos = this.ast[0].pos;
        throw new CompilerError(ErrorUtil.formatContext("Unexpected top-level content in template file", pos, context), false, [pos].concat(context.stack));
      }
      ;
      return [AstNode.Void];
    }
    ;
    let _g3 = [];
    let _g4 = 0;
    let _g5 = this.ast;
    while (_g4 < _g5.length) {
      let node = _g5[_g4];
      ++_g4;
      let tmp;
      switch (node._hx_index) {
        case 2:
          let _g6 = node.pos;
          let _g12 = node.name;
          let _g22 = node.body;
          throw new CompilerError("import or template definition found after setup", true);
          break;
        case 4:
          let _g62 = node.pos;
          let _g7 = node.name;
          throw new CompilerError("import or template definition found after setup", true);
          break;
        default:
          tmp = this.transformTld(node, context);
      }
      ;
      _g3.push(tmp);
    }
    ;
    return _g3;
  }
  compile(vars, compiler) {
    let info = compiler.getInitialPathInfo(this.name);
    let _g = new StringMap();
    let _g1 = 0;
    let _g2 = Reflect2.fields(this.fileJs);
    while (_g1 < _g2.length) {
      let k = _g2[_g1];
      ++_g1;
      _g.inst.set(k, Reflect2.field(this.fileJs, k));
    }
    ;
    let thisFileVars = new VariableMap(vars, _g);
    let namespace = info.namespace;
    let variableMap = new VariableMap(thisFileVars, Globals.map);
    let path = info.path;
    let uidIndex = new UidTracker();
    let replacements2 = new VariableMap(null, new StringMap());
    let context = { "append": function(v) {
      throw new CompilerError("append not available for top-level context", true);
    }, "namespace": namespace, "path": path == null ? [] : path, "uidIndex": uidIndex, "variables": variableMap, "stack": [], "replacements": replacements2, "isTemplate": this.ext == "mcbt", "templates": this.templates, "requireTemplateKeyword": this.ext == "mcbt", "compiler": compiler, "globalVariables": thisFileVars, "functions": [], "baseNamespaceInfo": info, "currentFunction": null };
    if (context.isTemplate) {
      if (this.ast.length > 0) {
        let pos = this.ast[0].pos;
        throw new CompilerError(ErrorUtil.formatContext("Unexpected top-level content in template file", pos, context), false, [pos].concat(context.stack));
      }
      ;
      return;
    }
    ;
    let _g3 = 0;
    let _g4 = this.ast;
    while (_g3 < _g4.length) {
      let node = _g4[_g3];
      ++_g3;
      switch (node._hx_index) {
        case 2:
          let _g5 = node.pos;
          let _g12 = node.name;
          let _g22 = node.body;
          throw new CompilerError("import or template definition found after setup", true);
          break;
        case 4:
          let _g52 = node.pos;
          let _g6 = node.name;
          throw new CompilerError("import or template definition found after setup", true);
          break;
        default:
          this.compileTld(node, context);
      }
      ;
    }
    ;
    if (this.loadCommands.length > 0) {
      let path2 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, "load.mcfunction"])));
      let content = this.loadCommands.join("\n");
      if (context.compiler.config.header.length > 0 && path2.endsWith(".mcfunction")) {
        content = context.compiler.config.header + "\n" + content;
      }
      ;
      context.compiler.io.write(path2, content);
      compiler.tags.addTagEntry("minecraft:load", context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, "load"]).join("/"), context);
    }
    ;
    if (this.tickCommands.length > 0) {
      let path2 = Path2.join(["data", context.namespace, this.functionsDir].concat(context.path.concat([context.compiler.config.generatedDirName, "tick.mcfunction"])));
      let content = this.tickCommands.join("\n");
      if (context.compiler.config.header.length > 0 && path2.endsWith(".mcfunction")) {
        content = context.compiler.config.header + "\n" + content;
      }
      ;
      context.compiler.io.write(path2, content);
      compiler.tags.addTagEntry("minecraft:tick", context.namespace + ":" + context.path.concat([context.compiler.config.generatedDirName, "tick"]).join("/"), context);
    }
    ;
  }
  static invokeExpressionInline(expression, context, pos) {
    let variables = context.variables.get();
    let argList = ["context"];
    let valueList = [context];
    let map = variables;
    let _g_map = map;
    let _g_keys = map.keys();
    while (_g_keys.hasNext()) {
      let key = _g_keys.next();
      let _g_value = _g_map.get(key);
      let _g_key = key;
      let k = _g_key;
      let v = _g_value;
      argList.push(k);
      valueList.push(v);
    }
    ;
    let code = "return (" + expression + ");";
    try {
      return new Function(...argList, code).apply(null, valueList);
      ;
    } catch (_g) {
      let e = Exception.caught(_g);
      throw new CompilerError(ErrorUtil.formatContext(Parser.format("Encountered an error whilst evaluating expression '{}' at {}:{}:{}", e.get_message(), pos.file, pos.line, pos.col + 1), pos, context), false, [pos].concat(context.stack));
    }
    ;
  }
  static get __name__() {
    return "mcl.McFile";
  }
  get __class__() {
    return McFile2;
  }
};
var Compiler = Register.global("$hxClasses")["mcl.Compiler"] = class Compiler2 extends Register.inherits() {
  new(baseDir, config, lib) {
    this.topLevelAstNodes = new Array();
    this.success = true;
    this.templateParsingEnabled = true;
    this.disableRequire = false;
    this.packNamespace = "mcb-" + Std.string(/* @__PURE__ */ new Date());
    this.tags = new TagManager();
    this.libStore = null;
    this.alreadySetupFiles = new StringMap();
    this.files = new StringMap();
    this.io = new SyncIo();
    this.config = Config.create(config);
    this.baseDir = baseDir;
    this.libStore = lib;
  }
  addFile(name, ast) {
    let file = new McFile(name, ast);
    this.files.inst.set(name, file);
  }
  resolve(baseFile, resolutionPath) {
    if (resolutionPath.charAt(0) == "." || resolutionPath.charAt(0) == "/") {
      let base;
      if (resolutionPath.charAt(0) == "/") {
        resolutionPath = resolutionPath.substring(1);
        base = this.baseDir;
      } else {
        base = Path2.directory(baseFile);
      }
      ;
      let resolved = Path2.join([base, resolutionPath]);
      let ext = Path2.extension(resolutionPath);
      if (ext.endsWith("js") || ext == "json") {
        return ImportFileType.IJsFile(require(resolved));
      }
      ;
      if (this.files.inst.has(resolved)) {
        if (!this.alreadySetupFiles.inst.has(resolved)) {
          this.alreadySetupFiles.inst.set(resolved, true);
          this.files.inst.get(resolved).setup(this);
        }
        ;
        return ImportFileType.IMcFile(this.files.inst.get(resolved));
      }
      ;
      throw new CompilerError("Failed to resolve import: " + resolved, false);
    } else {
      return ImportFileType.IMcFile(this.libStore.lookup(resolutionPath, { "file": baseFile, "line": 0, "col": 0 }, this));
    }
    ;
  }
  getInitialPathInfo(p) {
    let projectPath = (p.startsWith(this.baseDir) ? p.substring(this.baseDir.length) : p).split("\\").join("/");
    if (projectPath.charAt(0) == "/") {
      projectPath = projectPath.substring(1);
    }
    ;
    let parts = projectPath.split("/");
    let namespace = Path2.withoutExtension(parts[0]);
    let path = parts.slice(1).join("/");
    return { "namespace": namespace, "path": parts.length > 1 ? Path2.withoutExtension(path).split("/") : [] };
  }
  compile(root) {
    this.success = true;
    try {
      let file = EsMap.adaptIterator(this.files.inst.values());
      while (file.hasNext()) {
        let file12 = file.next();
        if (this.alreadySetupFiles.inst.has(file12.name)) {
          continue;
        }
        ;
        file12.setup(this);
      }
      ;
      let file1 = EsMap.adaptIterator(this.files.inst.values());
      while (file1.hasNext()) {
        let file2 = file1.next();
        file2.compile(root, this);
      }
      ;
      this.tags.writeTagFiles(this);
    } catch (_g) {
      let e = Exception.caught(_g).unwrap();
      this.success = false;
      throw Exception.thrown(e);
    }
    ;
  }
  transform(root) {
    let result = /* @__PURE__ */ new Map();
    let file = EsMap.adaptIterator(this.files.inst.values());
    while (file.hasNext()) {
      let file12 = file.next();
      if (this.alreadySetupFiles.inst.has(file12.name)) {
        continue;
      }
      ;
      file12.setup(this);
    }
    ;
    let file1 = EsMap.adaptIterator(this.files.inst.values());
    while (file1.hasNext()) {
      let file2 = file1.next();
      this.topLevelAstNodes = [];
      result.set(file2.name, AstNode.Group(file2.transform(root, this).concat(this.topLevelAstNodes)));
    }
    ;
    return result;
  }
  addTopLevelAstNode(node) {
    this.topLevelAstNodes.push(node);
  }
  static get __name__() {
    return "mcl.Compiler";
  }
  get __class__() {
    return Compiler2;
  }
};

// bin/mcl/args/JsTemplateArgument.js
var $global63 = Register.$global;
var JsTemplateArgument = Register.global("$hxClasses")["mcl.args.JsTemplateArgument"] = class JsTemplateArgument2 extends Register.inherits(() => TemplateArgument, true) {
  new(s, p) {
    super.new(s, p);
    this.expectJsValue = true;
  }
  parseValue(value, pos, ctx) {
    if (value.startsWith("<%")) {
      let end = value.indexOf("%>");
      if (end == -1) {
        return { "success": false };
      }
      ;
      let code = value.substring(2, end);
      try {
        let idx = TemplateArgument.jsCacheIdx;
        let alreadyParsed = TemplateArgument.jsCache.inst.has(idx);
        let v;
        if (!alreadyParsed) {
          v = McFile.invokeExpressionInline(code, ctx, pos);
          TemplateArgument.jsCache.inst.set(idx, v);
        } else {
          v = TemplateArgument.jsCache.inst.get(idx);
        }
        ;
        return { "success": true, "value": v, "raw": value.substring(0, end + 2) };
      } catch (_g) {
        return { "success": false };
      }
      ;
    }
    ;
    return { "success": false };
  }
  static register() {
    TemplateArgument.register("js", JsTemplateArgument2);
  }
  static get __name__() {
    return "mcl.args.JsTemplateArgument";
  }
  static get __super__() {
    return TemplateArgument;
  }
  get __class__() {
    return JsTemplateArgument2;
  }
};

// bin/mcl/args/LiteralTemplateArgument.js
var $global64 = Register.$global;
var LiteralTemplateArgument = Register.global("$hxClasses")["mcl.args.LiteralTemplateArgument"] = class LiteralTemplateArgument2 extends Register.inherits(() => TemplateArgument, true) {
  new(pos, value) {
    this.value = value;
    super.new(null, pos);
  }
  parseValue(value, pos, ctx) {
    if (value == this.value || value.startsWith(this.value + " ")) {
      return { "success": true, "value": value, "raw": this.value };
    }
    ;
    return { "success": false };
  }
  static register() {
    TemplateArgument.register("literal", JsTemplateArgument);
  }
  static get __name__() {
    return "mcl.args.LiteralTemplateArgument";
  }
  static get __super__() {
    return TemplateArgument;
  }
  get __class__() {
    return LiteralTemplateArgument2;
  }
};

// bin/mcl/args/TemplateArgument.js
var $global65 = Register.$global;
var TemplateArgument = Register.global("$hxClasses")["mcl.args.TemplateArgument"] = class TemplateArgument2 extends Register.inherits() {
  new(s, pos) {
    this.expectJsValue = false;
    this.expectBlock = false;
    this.name = s;
    this.pos = pos;
  }
  parseValue(s, p, context) {
    throw Exception.thrown("override this method in subclass, plz thx");
  }
  parseValueBlock(s, p, context) {
    throw Exception.thrown("override this method in subclass, plz thx");
  }
  static parse(s, p) {
    let colon = s.indexOf(":");
    let type = colon == -1 ? "literal" : s.substring(colon + 1);
    let name = colon == -1 ? s : s.substring(0, colon);
    if (type == "literal") {
      return new LiteralTemplateArgument(p, name);
    }
    ;
    if (!TemplateArgument2.argumentTypes.inst.has(type)) {
      throw Exception.thrown("Unknown template argument type: '" + type + "'");
    }
    ;
    return Type.createInstance(TemplateArgument2.argumentTypes.inst.get(type), [name]);
  }
  static register(type, c) {
    if (TemplateArgument2.argumentTypes.inst.has(type)) {
      throw Exception.thrown("Template argument type already registered: " + type);
    }
    ;
    TemplateArgument2.argumentTypes.inst.set(type, c);
  }
  static get __name__() {
    return "mcl.args.TemplateArgument";
  }
  get __class__() {
    return TemplateArgument2;
  }
};
TemplateArgument.jsCache = null;
TemplateArgument.jsCacheIdx = 0;
TemplateArgument.argumentTypes = new StringMap();

// bin/mcl/args/WordTemplateArgument.js
var $global66 = Register.$global;
var WordTemplateArgument = Register.global("$hxClasses")["mcl.args.WordTemplateArgument"] = class WordTemplateArgument2 extends Register.inherits(TemplateArgument) {
  new(s, pos) {
    super.new(s, pos);
  }
  parseValue(value, pos, ctx) {
    if (value == "") {
      return { "success": false };
    }
    ;
    let split = value.indexOf(" ");
    let res = split == -1 ? value : HxOverrides.substr(value, 0, split);
    return { "success": true, "value": res, "raw": res };
  }
  static register() {
    TemplateArgument.register("word", WordTemplateArgument2);
  }
  static get __name__() {
    return "mcl.args.WordTemplateArgument";
  }
  static get __super__() {
    return TemplateArgument;
  }
  get __class__() {
    return WordTemplateArgument2;
  }
};

// bin/mcl/args/RawTemplateArgument.js
var $global67 = Register.$global;
var RawTemplateArgument = Register.global("$hxClasses")["mcl.args.RawTemplateArgument"] = class RawTemplateArgument2 extends Register.inherits(TemplateArgument) {
  new(s, pos) {
    super.new(s, pos);
  }
  parseValue(value, pos, ctx) {
    return { "success": true, "value": value, "raw": value };
  }
  static register() {
    TemplateArgument.register("raw", RawTemplateArgument2);
  }
  static get __name__() {
    return "mcl.args.RawTemplateArgument";
  }
  static get __super__() {
    return TemplateArgument;
  }
  get __class__() {
    return RawTemplateArgument2;
  }
};

// bin/mcl/args/IntTemplateArgument.js
var $global68 = Register.$global;
var IntTemplateArgument = Register.global("$hxClasses")["mcl.args.IntTemplateArgument"] = class IntTemplateArgument2 extends Register.inherits(TemplateArgument) {
  new(s, pos) {
    super.new(s, pos);
  }
  parseValue(value, pos, ctx) {
    let spaceIdx = value.indexOf(" ");
    if (spaceIdx != -1) {
      value = value.substring(0, spaceIdx);
    }
    ;
    let intValue = Std.parseInt(value);
    if (intValue == null) {
      return { "success": false };
    }
    ;
    return { "success": true, "value": intValue, "raw": value };
  }
  static register() {
    TemplateArgument.register("int", IntTemplateArgument2);
  }
  static get __name__() {
    return "mcl.args.IntTemplateArgument";
  }
  static get __super__() {
    return TemplateArgument;
  }
  get __class__() {
    return IntTemplateArgument2;
  }
};

// bin/mcl/args/FloatTemplateArgument.js
var $global69 = Register.$global;
var FloatTemplateArgument = Register.global("$hxClasses")["mcl.args.FloatTemplateArgument"] = class FloatTemplateArgument2 extends Register.inherits(TemplateArgument) {
  new(s, pos) {
    super.new(s, pos);
  }
  parseValue(value, pos, ctx) {
    let spaceIdx = value.indexOf(" ");
    if (spaceIdx != -1) {
      value = value.substring(0, spaceIdx);
    }
    ;
    let intValue = parseFloat(value);
    if (intValue == null) {
      return { "success": false };
    }
    ;
    return { "success": true, "value": intValue, "raw": value };
  }
  static register() {
    TemplateArgument.register("float", FloatTemplateArgument2);
  }
  static get __name__() {
    return "mcl.args.FloatTemplateArgument";
  }
  static get __super__() {
    return TemplateArgument;
  }
  get __class__() {
    return FloatTemplateArgument2;
  }
};

// bin/mcl/args/BlockTemplateArgument.js
var $global70 = Register.$global;
var BoundBlock = Register.global("$hxClasses")["mcl.args.BoundBlock"] = class BoundBlock2 extends Register.inherits() {
  new(node, ctx) {
    this.node = node;
    this.ctx = ctx;
  }
  appendAstNode(node) {
    let _g = this.node;
    if (_g._hx_index == 8) {
      let _g1 = _g.pos;
      let _g2 = _g.name;
      let _g3 = _g.data;
      let _g4 = _g.isMacro;
      let _g5 = _g.isInline;
      let body = _g.body;
      body.push(node);
    } else {
      throw Exception.thrown("BoundBlock.append: node is not a block");
    }
    ;
  }
  append(code) {
    let tokens = Tokenizer.tokenize(code, "<inline BoundBlock.append>");
    let tokenInput = new ArrayInput(tokens);
    while (tokenInput.hasNext())
      this.appendAstNode(Parser.innerParse(tokenInput));
  }
  setName(name) {
    let _g = this.node;
    if (_g._hx_index == 8) {
      let _g1 = _g.name;
      let pos = _g.pos;
      let body = _g.body;
      let data = _g.data;
      let isMacro = _g.isMacro;
      let isInline = _g.isInline;
      this.node = AstNode.Block(pos, name, body, data, isMacro, isInline);
    } else {
      throw Exception.thrown("BoundBlock.setName: node is not a block");
    }
    ;
  }
  embedTo(context, pos, file, actuallyEmbed) {
    if (actuallyEmbed == null) {
      actuallyEmbed = true;
    }
    ;
    let content = [];
    let ctx = { "isTemplate": false, "uidIndex": context.uidIndex, "namespace": context.namespace, "path": context.path, "variables": this.ctx.variables, "replacements": this.ctx.replacements, "stack": this.ctx.stack, "append": function(s) {
      content.push(s);
    }, "templates": this.ctx.templates, "requireTemplateKeyword": this.ctx.requireTemplateKeyword, "compiler": this.ctx.compiler, "globalVariables": this.ctx.globalVariables, "functions": this.ctx.functions, "baseNamespaceInfo": context.baseNamespaceInfo, "currentFunction": this.ctx.currentFunction };
    if (actuallyEmbed) {
      file.embed(ctx, pos, new StringMap(), [this.node]);
    } else {
      file.embedTransform(ctx, pos, new StringMap(), [this.node]);
    }
    ;
    return content.join("\n");
  }
  static get __name__() {
    return "mcl.args.BoundBlock";
  }
  get __class__() {
    return BoundBlock2;
  }
};
var BlockTemplateArgument = Register.global("$hxClasses")["mcl.args.BlockTemplateArgument"] = class BlockTemplateArgument2 extends Register.inherits(TemplateArgument) {
  new(s, pos) {
    super.new(s, pos);
    this.expectBlock = true;
  }
  parseValueBlock(s, p, context) {
    if (s._hx_index == 8) {
      let _g = s.pos;
      let _g1 = s.name;
      let _g2 = s.body;
      let _g3 = s.data;
      let _g4 = s.isMacro;
      let _g5 = s.isInline;
      return { "success": true, "value": new BoundBlock(s, context) };
    } else {
      return { "success": false };
    }
    ;
  }
  static register() {
    TemplateArgument.register("block", BlockTemplateArgument2);
  }
  static get __name__() {
    return "mcl.args.BlockTemplateArgument";
  }
  static get __super__() {
    return TemplateArgument;
  }
  get __class__() {
    return BlockTemplateArgument2;
  }
};

// bin/mcl/TemplateRegisterer.js
var $global71 = Register.$global;
var TemplateRegisterer = Register.global("$hxClasses")["mcl.TemplateRegisterer"] = class TemplateRegisterer2 {
  static register() {
    RawTemplateArgument.register();
    IntTemplateArgument.register();
    JsTemplateArgument.register();
    BlockTemplateArgument.register();
    FloatTemplateArgument.register();
    WordTemplateArgument.register();
  }
  static get __name__() {
    return "mcl.TemplateRegisterer";
  }
  get __class__() {
    return TemplateRegisterer2;
  }
};

// bin/mcl/error/LibraryError.js
var $global72 = Register.$global;
var LibraryError = Register.global("$hxClasses")["mcl.error.LibraryError"] = class LibraryError2 extends Register.inherits(McbError) {
  new(message) {
    super.new("Library Error:\n	" + message, []);
  }
  static get __name__() {
    return "mcl.error.LibraryError";
  }
  static get __super__() {
    return McbError;
  }
  get __class__() {
    return LibraryError2;
  }
};

// bin/mcl/LibStore.js
var Fs5 = __toESM(require("fs"));
var $global73 = Register.$global;
var LibStore = Register.global("$hxClasses")["mcl.LibStore"] = class LibStore2 extends Register.inherits() {
  new(dir) {
    this.loadedLibs = new StringMap();
    this.libDir = dir;
  }
  lookup(id, pos, compiler) {
    if (this.loadedLibs.inst.has(id)) {
      return this.loadedLibs.inst.get(id).inst.get("mcblib/" + id + ".mcbt");
    }
    ;
    let p = Path2.join([this.libDir, id]);
    if (FileSystem.exists(p)) {
      return this.loadLib(id, p, compiler, pos);
    }
    ;
    throw new LibraryError(ErrorUtil.format("Library not found: " + id, pos));
  }
  getFilesInDirectory(dir) {
    let files = Fs5.readdirSync(dir);
    let result = [];
    let _g = 0;
    while (_g < files.length) {
      let f = files[_g];
      ++_g;
      let p = Path2.join([dir, f]);
      if (FileSystem.isDirectory(p)) {
        result = result.concat(this.getFilesInDirectory(p));
      } else {
        result.push(p);
      }
      ;
    }
    ;
    return result;
  }
  loadLib(id, p, compiler, pos) {
    let baseDir = Path2.join([p, "src", "mcblib"]);
    let srcDir = Path2.join([p, "src"]);
    if (!FileSystem.exists(baseDir)) {
      throw new LibraryError("Library " + id + " does not have a src/mcblib folder");
    }
    ;
    let c = new Compiler(p, {});
    let files = this.getFilesInDirectory(baseDir);
    let result = new StringMap();
    let _g = 0;
    while (_g < files.length) {
      let f = files[_g];
      ++_g;
      let ext = Path2.extension(f);
      if (ext != "mbt" && ext != "mcbt") {
        continue;
      }
      ;
      let tokens = Tokenizer.tokenize(Fs5.readFileSync(f, { "encoding": "utf8" }), f);
      let ast = ext == "mcb" ? Parser.parseMcbFile(tokens) : Parser.parseMcbtFile(tokens);
      let mcFile = new McFile(f, ast);
      mcFile.setup(compiler);
      let finalPath = HxOverrides.substr(f, srcDir.length + 1, null);
      mcFile.name = finalPath;
      result.inst.set(finalPath, mcFile);
    }
    ;
    this.loadedLibs.inst.set(id, result);
    return result.inst.get("mcblib/" + id + ".mcbt");
  }
  static get __name__() {
    return "mcl.LibStore";
  }
  get __class__() {
    return LibStore2;
  }
};

// bin/haxe/http/HttpNodeJs.js
var import_url = require("url");
var Https = __toESM(require("https"));
var Http = __toESM(require("http"));

// bin/haxe/http/HttpBase.js
var $global74 = Register.$global;
var HttpBase = Register.global("$hxClasses")["haxe.http.HttpBase"] = class HttpBase2 extends Register.inherits() {
  new(url) {
    this.url = url;
    this.headers = [];
    this.params = [];
    this.emptyOnData = Register.bind(this, this.onData);
  }
  get responseData() {
    return this.get_responseData();
  }
  /**
  This method is called upon a successful request, with `data` containing
  the result String.
  
  The intended usage is to bind it to a custom function:
  `httpInstance.onData = function(data) { // handle result }`
  */
  onData(data) {
  }
  /**
  This method is called upon a successful request, with `data` containing
  the result String.
  
  The intended usage is to bind it to a custom function:
  `httpInstance.onBytes = function(data) { // handle result }`
  */
  onBytes(data) {
  }
  /**
  This method is called upon a request error, with `msg` containing the
  error description.
  
  The intended usage is to bind it to a custom function:
  `httpInstance.onError = function(msg) { // handle error }`
  */
  onError(msg) {
  }
  /**
  This method is called upon a Http status change, with `status` being the
  new status.
  
  The intended usage is to bind it to a custom function:
  `httpInstance.onStatus = function(status) { // handle status }`
  */
  onStatus(status) {
  }
  /**
  Override this if extending `haxe.Http` with overriding `onData`
  */
  hasOnData() {
    return Register.bind(this, this.onData) != this.emptyOnData;
  }
  success(data) {
    this.responseBytes = data;
    this.responseAsString = null;
    if (this.hasOnData()) {
      this.onData(this.get_responseData());
    }
    ;
    this.onBytes(this.responseBytes);
  }
  get_responseData() {
    if (this.responseAsString == null && this.responseBytes != null) {
      this.responseAsString = this.responseBytes.getString(0, this.responseBytes.length, Encoding.UTF8);
    }
    ;
    return this.responseAsString;
  }
  static get __name__() {
    return "haxe.http.HttpBase";
  }
  get __class__() {
    return HttpBase2;
  }
};

// bin/haxe/http/HttpNodeJs.js
var import_buffer2 = require("buffer");
var $global75 = Register.$global;
var HttpNodeJs = Register.global("$hxClasses")["haxe.http.HttpNodeJs"] = class HttpNodeJs2 extends Register.inherits(HttpBase) {
  new(url) {
    super.new(url);
  }
  request(post) {
    this.responseAsString = null;
    this.responseBytes = null;
    this.responseHeaders = null;
    let parsedUrl = new import_url.URL(this.url);
    let secure = parsedUrl.protocol == "https:";
    let host = parsedUrl.hostname;
    let path = parsedUrl.pathname;
    let port = parsedUrl.port != null ? Std.parseInt(parsedUrl.port) : secure ? 443 : 80;
    let h = {};
    let _g = 0;
    let _g1 = this.headers;
    while (_g < _g1.length) {
      let i = _g1[_g];
      ++_g;
      let arr = Reflect2.field(h, i.name);
      if (arr == null) {
        arr = new Array();
        h[i.name] = arr;
      }
      ;
      arr.push(i.value);
    }
    ;
    if (this.postData != null || this.postBytes != null) {
      post = true;
    }
    ;
    let uri = null;
    let _g2 = 0;
    let _g3 = this.params;
    while (_g2 < _g3.length) {
      let p = _g3[_g2];
      ++_g2;
      if (uri == null) {
        uri = "";
      } else {
        uri += "&";
      }
      ;
      let s = p.name;
      let uri1 = encodeURIComponent(s) + "=";
      let s1 = p.value;
      uri += uri1 + encodeURIComponent(s1);
    }
    ;
    let question = path.split("?").length <= 1;
    if (uri != null) {
      path += (question ? "?" : "&") + uri;
    }
    ;
    let opts = { "protocol": parsedUrl.protocol, "hostname": host, "port": port, "method": post ? "POST" : "GET", "path": path, "headers": h };
    let _gthis = this;
    let httpResponse = function(res) {
      res.setEncoding("binary");
      let s = res.statusCode;
      if (s != null) {
        _gthis.onStatus(s);
      }
      ;
      let data = [];
      res.on("data", function(chunk) {
        data.push(import_buffer2.Buffer.from(chunk, "binary"));
      });
      res.on("end", function(_) {
        let buf = data.length == 1 ? data[0] : import_buffer2.Buffer.concat(data);
        let httpResponse2 = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        _gthis.responseBytes = Bytes.ofData(httpResponse2);
        _gthis.req = null;
        let httpResponse1 = new StringMap();
        _gthis.responseHeaders = httpResponse1;
        let _g4 = 0;
        let _g12 = Reflect2.fields(res.headers);
        while (_g4 < _g12.length) {
          let field = _g12[_g4];
          ++_g4;
          _gthis.responseHeaders.inst.set(field, Reflect2.field(res.headers, field));
        }
        ;
        if (s != null && s >= 200 && s < 400) {
          _gthis.success(_gthis.responseBytes);
        } else {
          _gthis.onError("Http Error #" + s);
        }
        ;
      });
    };
    this.req = secure ? Https.request(opts, httpResponse) : Http.request(opts, httpResponse);
    if (post) {
      if (this.postData != null) {
        this.req.write(this.postData);
      } else if (this.postBytes != null) {
        this.req.setHeader("Content-Length", "" + this.postBytes.length);
        this.req.write(import_buffer2.Buffer.from(this.postBytes.b.bufferValue));
      }
      ;
    }
    ;
    this.req.end();
  }
  static get __name__() {
    return "haxe.http.HttpNodeJs";
  }
  static get __super__() {
    return HttpBase;
  }
  get __class__() {
    return HttpNodeJs2;
  }
};

// bin/haxe/ds/List.js
var $global76 = Register.$global;
var List = Register.global("$hxClasses")["haxe.ds.List"] = class List2 extends Register.inherits() {
  new() {
    this.length = 0;
  }
  /**
  Adds element `item` at the end of `this` List.
  
  `this.length` increases by 1.
  */
  add(item) {
    let x = new ListNode(item, null);
    if (this.h == null) {
      this.h = x;
    } else {
      this.q.next = x;
    }
    ;
    this.q = x;
    this.length++;
  }
  /**
  Adds element `item` at the beginning of `this` List.
  
  `this.length` increases by 1.
  */
  push(item) {
    let x = new ListNode(item, this.h);
    this.h = x;
    if (this.q == null) {
      this.q = x;
    }
    ;
    this.length++;
  }
  /**
  Returns the first element of `this` List, or null if no elements exist.
  
  This function does not modify `this` List.
  */
  first() {
    if (this.h == null) {
      return null;
    } else {
      return this.h.item;
    }
    ;
  }
  /**
  Returns the first element of `this` List, or null if no elements exist.
  
  The element is removed from `this` List.
  */
  pop() {
    if (this.h == null) {
      return null;
    }
    ;
    let x = this.h.item;
    this.h = this.h.next;
    if (this.h == null) {
      this.q = null;
    }
    ;
    this.length--;
    return x;
  }
  /**
  Tells if `this` List is empty.
  */
  isEmpty() {
    return this.h == null;
  }
  /**
  Returns a string representation of `this` List.
  
  The result is enclosed in { } with the individual elements being
  separated by a comma.
  */
  toString() {
    let s_b = "";
    let first = true;
    let l = this.h;
    s_b += "{";
    while (l != null) {
      if (first) {
        first = false;
      } else {
        s_b += ", ";
      }
      ;
      s_b += Std.string(Std.string(l.item));
      l = l.next;
    }
    ;
    s_b += "}";
    return s_b;
  }
  static get __name__() {
    return "haxe.ds.List";
  }
  get __class__() {
    return List2;
  }
};
var ListNode = Register.global("$hxClasses")["haxe.ds._List.ListNode"] = class ListNode2 extends Register.inherits() {
  new(item, next) {
    this.item = item;
    this.next = next;
  }
  static get __name__() {
    return "haxe.ds._List.ListNode";
  }
  get __class__() {
    return ListNode2;
  }
};

// bin/haxe/Unserializer.js
var $global77 = Register.$global;
var DefaultResolver = Register.global("$hxClasses")["haxe._Unserializer.DefaultResolver"] = class DefaultResolver2 extends Register.inherits() {
  new() {
  }
  resolveClass(name) {
    return Register.global("$hxClasses")[name];
  }
  resolveEnum(name) {
    return Register.global("$hxEnums")[name];
  }
  static get __name__() {
    return "haxe._Unserializer.DefaultResolver";
  }
  get __class__() {
    return DefaultResolver2;
  }
};
var Unserializer = Register.global("$hxClasses")["haxe.Unserializer"] = class Unserializer2 extends Register.inherits() {
  new(buf) {
    this.buf = buf;
    this.length = this.buf.length;
    this.pos = 0;
    this.scache = new Array();
    this.cache = new Array();
    let r = Unserializer2.DEFAULT_RESOLVER;
    if (r == null) {
      r = new DefaultResolver();
      Unserializer2.DEFAULT_RESOLVER = r;
    }
    ;
    this.resolver = r;
  }
  readDigits() {
    let k = 0;
    let s = false;
    let fpos = this.pos;
    while (true) {
      let c = this.buf.charCodeAt(this.pos);
      if (c != c) {
        break;
      }
      ;
      if (c == 45) {
        if (this.pos != fpos) {
          break;
        }
        ;
        s = true;
        this.pos++;
        continue;
      }
      ;
      if (c < 48 || c > 57) {
        break;
      }
      ;
      k = k * 10 + (c - 48);
      this.pos++;
    }
    ;
    if (s) {
      k *= -1;
    }
    ;
    return k;
  }
  readFloat() {
    let p1 = this.pos;
    while (true) {
      let c = this.buf.charCodeAt(this.pos);
      if (c != c) {
        break;
      }
      ;
      if (c >= 43 && c < 58 || c == 101 || c == 69) {
        this.pos++;
      } else {
        break;
      }
      ;
    }
    ;
    return parseFloat(HxOverrides.substr(this.buf, p1, this.pos - p1));
  }
  unserializeObject(o) {
    while (true) {
      if (this.pos >= this.length) {
        throw Exception.thrown("Invalid object");
      }
      ;
      if (this.buf.charCodeAt(this.pos) == 103) {
        break;
      }
      ;
      let k = this.unserialize();
      if (typeof k != "string") {
        throw Exception.thrown("Invalid object key");
      }
      ;
      let v = this.unserialize();
      o[k] = v;
    }
    ;
    this.pos++;
  }
  unserializeEnum(edecl, tag) {
    if (this.buf.charCodeAt(this.pos++) != 58) {
      throw Exception.thrown("Invalid enum format");
    }
    ;
    let nargs = this.readDigits();
    if (nargs == 0) {
      return Type.createEnum(edecl, tag);
    }
    ;
    let args = new Array();
    while (nargs-- > 0)
      args.push(this.unserialize());
    return Type.createEnum(edecl, tag, args);
  }
  /**
  Unserializes the next part of `this` Unserializer instance and returns
  the according value.
  
  This function may call `this.resolver.resolveClass` to determine a
  Class from a String, and `this.resolver.resolveEnum` to determine an
  Enum from a String.
  
  If `this` Unserializer instance contains no more or invalid data, an
  exception is thrown.
  
  This operation may fail on structurally valid data if a type cannot be
  resolved or if a field cannot be set. This can happen when unserializing
  Strings that were serialized on a different Haxe target, in which the
  serialization side has to make sure not to include platform-specific
  data.
  
  Classes are created from `Type.createEmptyInstance`, which means their
  constructors are not called.
  */
  unserialize() {
    switch (this.buf.charCodeAt(this.pos++)) {
      case 65:
        let name = this.unserialize();
        let cl = this.resolver.resolveClass(name);
        if (cl == null) {
          throw Exception.thrown("Class not found " + name);
        }
        ;
        return cl;
        break;
      case 66:
        let name1 = this.unserialize();
        let e = this.resolver.resolveEnum(name1);
        if (e == null) {
          throw Exception.thrown("Enum not found " + name1);
        }
        ;
        return e;
        break;
      case 67:
        let name2 = this.unserialize();
        let cl1 = this.resolver.resolveClass(name2);
        if (cl1 == null) {
          throw Exception.thrown("Class not found " + name2);
        }
        ;
        let o = Object.create(cl1.prototype);
        this.cache.push(o);
        o.hxUnserialize(this);
        if (this.buf.charCodeAt(this.pos++) != 103) {
          throw Exception.thrown("Invalid custom data");
        }
        ;
        return o;
        break;
      case 77:
        let h = new ObjectMap();
        this.cache.push(h);
        let buf = this.buf;
        while (this.buf.charCodeAt(this.pos) != 104) {
          let s2 = this.unserialize();
          let value = this.unserialize();
          h.inst.set(s2, value);
        }
        ;
        this.pos++;
        return h;
        break;
      case 82:
        let n = this.readDigits();
        if (n < 0 || n >= this.scache.length) {
          throw Exception.thrown("Invalid string reference");
        }
        ;
        return this.scache[n];
        break;
      case 97:
        let buf1 = this.buf;
        let a = new Array();
        this.cache.push(a);
        while (true) {
          let c2 = this.buf.charCodeAt(this.pos);
          if (c2 == 104) {
            this.pos++;
            break;
          }
          ;
          if (c2 == 117) {
            this.pos++;
            let n2 = this.readDigits();
            a[a.length + n2 - 1] = null;
          } else {
            a.push(this.unserialize());
          }
          ;
        }
        ;
        return a;
        break;
      case 98:
        let h1 = new StringMap();
        this.cache.push(h1);
        let buf2 = this.buf;
        while (this.buf.charCodeAt(this.pos) != 104) {
          let s2 = this.unserialize();
          let value = this.unserialize();
          h1.inst.set(s2, value);
        }
        ;
        this.pos++;
        return h1;
        break;
      case 99:
        let name3 = this.unserialize();
        let cl2 = this.resolver.resolveClass(name3);
        if (cl2 == null) {
          throw Exception.thrown("Class not found " + name3);
        }
        ;
        let o1 = Object.create(cl2.prototype);
        this.cache.push(o1);
        this.unserializeObject(o1);
        return o1;
        break;
      case 100:
        return this.readFloat();
        break;
      case 102:
        return false;
        break;
      case 105:
        return this.readDigits();
        break;
      case 106:
        let name4 = this.unserialize();
        let edecl = this.resolver.resolveEnum(name4);
        if (edecl == null) {
          throw Exception.thrown("Enum not found " + name4);
        }
        ;
        this.pos++;
        let index = this.readDigits();
        let _this = edecl.__constructs__;
        let result = new Array(_this.length);
        let _g = 0;
        let _g1 = _this.length;
        while (_g < _g1) {
          let i2 = _g++;
          result[i2] = _this[i2]._hx_name;
        }
        ;
        let tag = result[index];
        if (tag == null) {
          throw Exception.thrown("Unknown enum index " + name4 + "@" + index);
        }
        ;
        let e1 = this.unserializeEnum(edecl, tag);
        this.cache.push(e1);
        return e1;
        break;
      case 107:
        return NaN;
        break;
      case 108:
        let l = new List();
        this.cache.push(l);
        let buf3 = this.buf;
        while (this.buf.charCodeAt(this.pos) != 104)
          l.add(this.unserialize());
        this.pos++;
        return l;
        break;
      case 109:
        return -Infinity;
        break;
      case 110:
        return null;
        break;
      case 111:
        let o2 = {};
        this.cache.push(o2);
        this.unserializeObject(o2);
        return o2;
        break;
      case 112:
        return Infinity;
        break;
      case 113:
        let h2 = new IntMap();
        this.cache.push(h2);
        let buf4 = this.buf;
        let c = this.buf.charCodeAt(this.pos++);
        while (c == 58) {
          let i2 = this.readDigits();
          let value = this.unserialize();
          h2.inst.set(i2, value);
          c = this.buf.charCodeAt(this.pos++);
        }
        ;
        if (c != 104) {
          throw Exception.thrown("Invalid IntMap format");
        }
        ;
        return h2;
        break;
      case 114:
        let n1 = this.readDigits();
        if (n1 < 0 || n1 >= this.cache.length) {
          throw Exception.thrown("Invalid reference");
        }
        ;
        return this.cache[n1];
        break;
      case 115:
        let len = this.readDigits();
        let buf5 = this.buf;
        if (this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
          throw Exception.thrown("Invalid bytes length");
        }
        ;
        let codes = Unserializer2.CODES;
        if (codes == null) {
          codes = Unserializer2.initCodes();
          Unserializer2.CODES = codes;
        }
        ;
        let i = this.pos;
        let rest = len & 3;
        let size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
        let max = i + (len - rest);
        let bytes = new Bytes(new ArrayBuffer(size));
        let bpos = 0;
        while (i < max) {
          let c1 = codes[buf5.charCodeAt(i++)];
          let c2 = codes[buf5.charCodeAt(i++)];
          bytes.b[bpos++] = c1 << 2 | c2 >> 4;
          let c3 = codes[buf5.charCodeAt(i++)];
          bytes.b[bpos++] = c2 << 4 | c3 >> 2;
          let c4 = codes[buf5.charCodeAt(i++)];
          bytes.b[bpos++] = c3 << 6 | c4;
        }
        ;
        if (rest >= 2) {
          let c1 = codes[buf5.charCodeAt(i++)];
          let c2 = codes[buf5.charCodeAt(i++)];
          bytes.b[bpos++] = c1 << 2 | c2 >> 4;
          if (rest == 3) {
            let c3 = codes[buf5.charCodeAt(i++)];
            bytes.b[bpos++] = c2 << 4 | c3 >> 2;
          }
          ;
        }
        ;
        this.pos += len;
        this.cache.push(bytes);
        return bytes;
        break;
      case 116:
        return true;
        break;
      case 118:
        let d;
        if (this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
          d = HxOverrides.strDate(HxOverrides.substr(this.buf, this.pos, 19));
          this.pos += 19;
        } else {
          d = new Date(this.readFloat());
        }
        ;
        this.cache.push(d);
        return d;
        break;
      case 119:
        let name5 = this.unserialize();
        let edecl1 = this.resolver.resolveEnum(name5);
        if (edecl1 == null) {
          throw Exception.thrown("Enum not found " + name5);
        }
        ;
        let e2 = this.unserializeEnum(edecl1, this.unserialize());
        this.cache.push(e2);
        return e2;
        break;
      case 120:
        throw Exception.thrown(this.unserialize());
        break;
      case 121:
        let len1 = this.readDigits();
        if (this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len1) {
          throw Exception.thrown("Invalid string length");
        }
        ;
        let s = HxOverrides.substr(this.buf, this.pos, len1);
        this.pos += len1;
        s = decodeURIComponent(s.split("+").join(" "));
        this.scache.push(s);
        return s;
        break;
      case 122:
        return 0;
        break;
      default:
    }
    ;
    this.pos--;
    throw Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
  }
  static initCodes() {
    let codes = new Array();
    let _g = 0;
    let _g1 = Unserializer2.BASE64.length;
    while (_g < _g1) {
      let i = _g++;
      codes[Unserializer2.BASE64.charCodeAt(i)] = i;
    }
    ;
    return codes;
  }
  static get __name__() {
    return "haxe.Unserializer";
  }
  get __class__() {
    return Unserializer2;
  }
};
Unserializer.DEFAULT_RESOLVER = new DefaultResolver();
Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
Unserializer.CODES = null;

// bin/haxe/Template.js
var $global78 = Register.$global;
var TemplateExpr = Register.global("$hxEnums")["haxe._Template.TemplateExpr"] = {
  __ename__: "haxe._Template.TemplateExpr",
  OpVar: Object.assign((v) => ({ _hx_index: 0, __enum__: "haxe._Template.TemplateExpr", "v": v }), { _hx_name: "OpVar", __params__: ["v"] }),
  OpExpr: Object.assign((expr) => ({ _hx_index: 1, __enum__: "haxe._Template.TemplateExpr", "expr": expr }), { _hx_name: "OpExpr", __params__: ["expr"] }),
  OpIf: Object.assign((expr, eif, eelse) => ({ _hx_index: 2, __enum__: "haxe._Template.TemplateExpr", "expr": expr, "eif": eif, "eelse": eelse }), { _hx_name: "OpIf", __params__: ["expr", "eif", "eelse"] }),
  OpStr: Object.assign((str) => ({ _hx_index: 3, __enum__: "haxe._Template.TemplateExpr", "str": str }), { _hx_name: "OpStr", __params__: ["str"] }),
  OpBlock: Object.assign((l) => ({ _hx_index: 4, __enum__: "haxe._Template.TemplateExpr", "l": l }), { _hx_name: "OpBlock", __params__: ["l"] }),
  OpForeach: Object.assign((expr, loop) => ({ _hx_index: 5, __enum__: "haxe._Template.TemplateExpr", "expr": expr, "loop": loop }), { _hx_name: "OpForeach", __params__: ["expr", "loop"] }),
  OpMacro: Object.assign((name, params) => ({ _hx_index: 6, __enum__: "haxe._Template.TemplateExpr", "name": name, "params": params }), { _hx_name: "OpMacro", __params__: ["name", "params"] })
};
TemplateExpr.__constructs__ = [TemplateExpr.OpVar, TemplateExpr.OpExpr, TemplateExpr.OpIf, TemplateExpr.OpStr, TemplateExpr.OpBlock, TemplateExpr.OpForeach, TemplateExpr.OpMacro];
TemplateExpr.__empty_constructs__ = [];
var Template = Register.global("$hxClasses")["haxe.Template"] = class Template2 extends Register.inherits() {
  new(str) {
    let tokens = this.parseTokens(str);
    this.expr = this.parseBlock(tokens);
    if (!tokens.isEmpty()) {
      throw Exception.thrown("Unexpected '" + Std.string(tokens.first().s) + "'");
    }
    ;
  }
  /**
  Executes `this` `Template`, taking into account `context` for
  replacements and `macros` for callback functions.
  
  If `context` has a field `name`, its value replaces all occurrences of
  `::name::` in the `Template`. Otherwise `Template.globals` is checked instead,
  If `name` is not a field of that either, `::name::` is replaced with `null`.
  
  If `macros` has a field `name`, all occurrences of `$$name(args)` are
  replaced with the result of calling that field. The first argument is
  always the `resolve()` method, followed by the given arguments.
  If `macros` has no such field, the result is unspecified.
  
  If `context` is `null`, the result is unspecified. If `macros` is `null`,
  no macros are used.
  */
  execute(context, macros) {
    this.macros = macros == null ? {} : macros;
    this.context = context;
    this.stack = new List();
    this.buf = new StringBuf();
    this.run(this.expr);
    return this.buf.b;
  }
  resolve(v) {
    if (v == "__current__") {
      return this.context;
    }
    ;
    if (Reflect2.isObject(this.context)) {
      let value = Reflect2.getProperty(this.context, v);
      if (value != null || Object.prototype.hasOwnProperty.call(this.context, v)) {
        return value;
      }
      ;
    }
    ;
    let _g_head = this.stack.h;
    while (_g_head != null) {
      let val = _g_head.item;
      _g_head = _g_head.next;
      let ctx = val;
      let value = Reflect2.getProperty(ctx, v);
      if (value != null || Object.prototype.hasOwnProperty.call(ctx, v)) {
        return value;
      }
      ;
    }
    ;
    return Reflect2.field(Template2.globals, v);
  }
  parseTokens(data) {
    let tokens = new List();
    while (Template2.splitter.match(data)) {
      let p = Template2.splitter.matchedPos();
      if (p.pos > 0) {
        tokens.add({ "p": HxOverrides.substr(data, 0, p.pos), "s": true, "l": null });
      }
      ;
      if (HxOverrides.cca(data, p.pos) == 58) {
        tokens.add({ "p": HxOverrides.substr(data, p.pos + 2, p.len - 4), "s": false, "l": null });
        data = Template2.splitter.matchedRight();
        continue;
      }
      ;
      let parp = p.pos + p.len;
      let npar = 1;
      let params = [];
      let part = "";
      while (true) {
        let c = HxOverrides.cca(data, parp);
        ++parp;
        if (c == 40) {
          ++npar;
        } else if (c == 41) {
          --npar;
          if (npar <= 0) {
            break;
          }
          ;
        } else if (c == null) {
          throw Exception.thrown("Unclosed macro parenthesis");
        }
        ;
        if (c == 44 && npar == 1) {
          params.push(part);
          part = "";
        } else {
          part += String.fromCodePoint(c);
        }
        ;
      }
      ;
      params.push(part);
      tokens.add({ "p": Template2.splitter.matched(2), "s": false, "l": params });
      data = HxOverrides.substr(data, parp, data.length - parp);
    }
    ;
    if (data.length > 0) {
      tokens.add({ "p": data, "s": true, "l": null });
    }
    ;
    return tokens;
  }
  parseBlock(tokens) {
    let l = new List();
    while (true) {
      let t = tokens.first();
      if (t == null) {
        break;
      }
      ;
      if (!t.s && (t.p == "end" || t.p == "else" || HxOverrides.substr(t.p, 0, 7) == "elseif ")) {
        break;
      }
      ;
      l.add(this.parse(tokens));
    }
    ;
    if (l.length == 1) {
      return l.first();
    }
    ;
    return TemplateExpr.OpBlock(l);
  }
  parse(tokens) {
    let t = tokens.pop();
    let p = t.p;
    if (t.s) {
      return TemplateExpr.OpStr(p);
    }
    ;
    if (t.l != null) {
      let pe = new List();
      let _g = 0;
      let _g1 = t.l;
      while (_g < _g1.length) {
        let p2 = _g1[_g];
        ++_g;
        pe.add(this.parseBlock(this.parseTokens(p2)));
      }
      ;
      return TemplateExpr.OpMacro(p, pe);
    }
    ;
    let kwdEnd = function(kwd) {
      let pos2 = -1;
      let length = kwd.length;
      if (HxOverrides.substr(p, 0, length) == kwd) {
        pos2 = length;
        let _g_offset = 0;
        let _g_s = HxOverrides.substr(p, length, null);
        while (_g_offset < _g_s.length) {
          let c = _g_s.charCodeAt(_g_offset++);
          if (c == 32) {
            ++pos2;
          } else {
            break;
          }
          ;
        }
        ;
      }
      ;
      return pos2;
    };
    let pos = kwdEnd("if");
    if (pos > 0) {
      p = HxOverrides.substr(p, pos, p.length - pos);
      let e = this.parseExpr(p);
      let eif = this.parseBlock(tokens);
      let t2 = tokens.first();
      let eelse;
      if (t2 == null) {
        throw Exception.thrown("Unclosed 'if'");
      }
      ;
      if (t2.p == "end") {
        tokens.pop();
        eelse = null;
      } else if (t2.p == "else") {
        tokens.pop();
        eelse = this.parseBlock(tokens);
        t2 = tokens.pop();
        if (t2 == null || t2.p != "end") {
          throw Exception.thrown("Unclosed 'else'");
        }
        ;
      } else {
        t2.p = HxOverrides.substr(t2.p, 4, t2.p.length - 4);
        eelse = this.parse(tokens);
      }
      ;
      return TemplateExpr.OpIf(e, eif, eelse);
    }
    ;
    let pos1 = kwdEnd("foreach");
    if (pos1 >= 0) {
      p = HxOverrides.substr(p, pos1, p.length - pos1);
      let e = this.parseExpr(p);
      let efor = this.parseBlock(tokens);
      let t2 = tokens.pop();
      if (t2 == null || t2.p != "end") {
        throw Exception.thrown("Unclosed 'foreach'");
      }
      ;
      return TemplateExpr.OpForeach(e, efor);
    }
    ;
    if (Template2.expr_splitter.match(p)) {
      return TemplateExpr.OpExpr(this.parseExpr(p));
    }
    ;
    return TemplateExpr.OpVar(p);
  }
  parseExpr(data) {
    let l = new List();
    let expr = data;
    while (Template2.expr_splitter.match(data)) {
      let p = Template2.expr_splitter.matchedPos();
      let k = p.pos + p.len;
      if (p.pos != 0) {
        l.add({ "p": HxOverrides.substr(data, 0, p.pos), "s": true });
      }
      ;
      let p1 = Template2.expr_splitter.matched(0);
      l.add({ "p": p1, "s": p1.indexOf('"') >= 0 });
      data = Template2.expr_splitter.matchedRight();
    }
    ;
    if (data.length != 0) {
      let _g_offset = 0;
      let _g_s = data;
      while (_g_offset < _g_s.length) {
        let _g_key = _g_offset;
        let _g_value = _g_s.charCodeAt(_g_offset++);
        let i = _g_key;
        let c = _g_value;
        if (c != 32) {
          l.add({ "p": HxOverrides.substr(data, i, null), "s": true });
          break;
        }
        ;
      }
      ;
    }
    ;
    let e;
    try {
      e = this.makeExpr(l);
      if (!l.isEmpty()) {
        throw Exception.thrown(l.first().p);
      }
      ;
    } catch (_g) {
      let _g1 = Exception.caught(_g).unwrap();
      if (typeof _g1 == "string") {
        let s = _g1;
        throw Exception.thrown("Unexpected '" + s + "' in " + expr);
      } else {
        throw _g;
      }
      ;
    }
    ;
    return function() {
      try {
        return e();
      } catch (_g) {
        let exc = Exception.caught(_g).unwrap();
        throw Exception.thrown("Error : " + Std.string(exc) + " in " + expr);
      }
      ;
    };
  }
  makeConst(v) {
    Template2.expr_trim.match(v);
    v = Template2.expr_trim.matched(1);
    if (HxOverrides.cca(v, 0) == 34) {
      let str = HxOverrides.substr(v, 1, v.length - 2);
      return function() {
        return str;
      };
    }
    ;
    if (Template2.expr_int.match(v)) {
      let i = Std.parseInt(v);
      return function() {
        return i;
      };
    }
    ;
    if (Template2.expr_float.match(v)) {
      let f = parseFloat(v);
      return function() {
        return f;
      };
    }
    ;
    let me = this;
    return function() {
      return me.resolve(v);
    };
  }
  makePath(e, l) {
    let p = l.first();
    if (p == null || p.p != ".") {
      return e;
    }
    ;
    l.pop();
    let field = l.pop();
    if (field == null || !field.s) {
      throw Exception.thrown(field.p);
    }
    ;
    let f = field.p;
    Template2.expr_trim.match(f);
    f = Template2.expr_trim.matched(1);
    return this.makePath(function() {
      return Reflect2.field(e(), f);
    }, l);
  }
  makeExpr(l) {
    return this.makePath(this.makeExpr2(l), l);
  }
  skipSpaces(l) {
    let p = l.first();
    while (p != null) {
      let _g_offset = 0;
      let _g_s = p.p;
      while (_g_offset < _g_s.length) {
        let c = _g_s.charCodeAt(_g_offset++);
        if (c != 32) {
          return;
        }
        ;
      }
      ;
      l.pop();
      p = l.first();
    }
    ;
  }
  makeExpr2(l) {
    this.skipSpaces(l);
    let p = l.pop();
    this.skipSpaces(l);
    if (p == null) {
      throw Exception.thrown("<eof>");
    }
    ;
    if (p.s) {
      return this.makeConst(p.p);
    }
    ;
    switch (p.p) {
      case "!":
        let e = this.makeExpr(l);
        return function() {
          let v = e();
          if (v != null) {
            return v == false;
          } else {
            return true;
          }
          ;
        };
        break;
      case "(":
        this.skipSpaces(l);
        let e1 = this.makeExpr(l);
        this.skipSpaces(l);
        let p1 = l.pop();
        if (p1 == null || p1.s) {
          throw Exception.thrown(p1);
        }
        ;
        if (p1.p == ")") {
          return e1;
        }
        ;
        this.skipSpaces(l);
        let e2 = this.makeExpr(l);
        this.skipSpaces(l);
        let p2 = l.pop();
        this.skipSpaces(l);
        if (p2 == null || p2.p != ")") {
          throw Exception.thrown(p2);
        }
        ;
        switch (p1.p) {
          case "!=":
            return function() {
              return e1() != e2();
            };
            break;
          case "&&":
            return function() {
              return e1() && e2();
            };
            break;
          case "*":
            return function() {
              return e1() * e2();
            };
            break;
          case "+":
            return function() {
              return e1() + e2();
            };
            break;
          case "-":
            return function() {
              return e1() - e2();
            };
            break;
          case "/":
            return function() {
              return e1() / e2();
            };
            break;
          case "<":
            return function() {
              return e1() < e2();
            };
            break;
          case "<=":
            return function() {
              return e1() <= e2();
            };
            break;
          case "==":
            return function() {
              return e1() == e2();
            };
            break;
          case ">":
            return function() {
              return e1() > e2();
            };
            break;
          case ">=":
            return function() {
              return e1() >= e2();
            };
            break;
          case "||":
            return function() {
              return e1() || e2();
            };
            break;
          default:
            throw Exception.thrown("Unknown operation " + p1.p);
        }
        ;
        break;
      case "-":
        let e3 = this.makeExpr(l);
        return function() {
          return -e3();
        };
        break;
    }
    ;
    throw Exception.thrown(p.p);
  }
  run(e) {
    switch (e._hx_index) {
      case 0:
        let v = e.v;
        let _this = this.buf;
        let x = Std.string(this.resolve(v));
        _this.b += Std.string(x);
        break;
      case 1:
        let e1 = e.expr;
        let _this1 = this.buf;
        let x1 = Std.string(e1());
        _this1.b += Std.string(x1);
        break;
      case 2:
        let e2 = e.expr;
        let eif = e.eif;
        let eelse = e.eelse;
        let v1 = e2();
        if (v1 == null || v1 == false) {
          if (eelse != null) {
            this.run(eelse);
          }
          ;
        } else {
          this.run(eif);
        }
        ;
        break;
      case 3:
        let str = e.str;
        this.buf.b += str == null ? "null" : "" + str;
        break;
      case 4:
        let l = e.l;
        let _g_head = l.h;
        while (_g_head != null) {
          let val = _g_head.item;
          _g_head = _g_head.next;
          let e4 = val;
          this.run(e4);
        }
        ;
        break;
      case 5:
        let e3 = e.expr;
        let loop = e.loop;
        let v2 = e3();
        try {
          let x2 = Register.getIterator(v2);
          if (x2.hasNext == null) {
            throw Exception.thrown(null);
          }
          ;
          v2 = x2;
        } catch (_g) {
          try {
            if (v2.hasNext == null) {
              throw Exception.thrown(null);
            }
            ;
          } catch (_g2) {
            throw Exception.thrown("Cannot iter on " + Std.string(v2));
          }
          ;
        }
        ;
        this.stack.push(this.context);
        let v3 = v2;
        let ctx = v3;
        while (ctx.hasNext()) {
          let ctx1 = ctx.next();
          this.context = ctx1;
          this.run(loop);
        }
        ;
        this.context = this.stack.pop();
        break;
      case 6:
        let m = e.name;
        let params = e.params;
        let v4 = Reflect2.field(this.macros, m);
        let pl = new Array();
        let old = this.buf;
        pl.push(Register.bind(this, this.resolve));
        let _g_head1 = params.h;
        while (_g_head1 != null) {
          let val = _g_head1.item;
          _g_head1 = _g_head1.next;
          let p = val;
          if (p._hx_index == 0) {
            let v5 = p.v;
            pl.push(this.resolve(v5));
          } else {
            this.buf = new StringBuf();
            this.run(p);
            pl.push(this.buf.b);
          }
          ;
        }
        ;
        this.buf = old;
        try {
          let _this2 = this.buf;
          let x2 = Std.string(v4.apply(this.macros, pl));
          _this2.b += Std.string(x2);
        } catch (_g) {
          let e4 = Exception.caught(_g).unwrap();
          let plstr;
          try {
            plstr = pl.join(",");
          } catch (_g2) {
            plstr = "???";
          }
          ;
          let msg = "Macro call " + m + "(" + plstr + ") failed (" + Std.string(e4) + ")";
          throw Exception.thrown(msg);
        }
        ;
        break;
    }
    ;
  }
  static get __name__() {
    return "haxe.Template";
  }
  get __class__() {
    return Template2;
  }
};
Template.splitter = new EReg('(::[A-Za-z0-9_ ()&|!+=/><*."-]+::|\\$\\$([A-Za-z0-9_-]+)\\()', "");
Template.expr_splitter = new EReg('(\\(|\\)|[ \r\n	]*"[^"]*"[ \r\n	]*|[!+=/><*.&|-]+)', "");
Template.expr_trim = new EReg("^[ ]*([^ ]+)[ ]*$", "");
Template.expr_int = new EReg("^[0-9]+$", "");
Template.expr_float = new EReg("^([+-]?)(?=\\d|,\\d)\\d*(,\\d*)?([Ee]([+-]?\\d+))?$", "");
Template.globals = {};
Template.hxKeepArrayIterator = new ArrayIterator3([]);

// bin/mcb/AppMain.js
var Fs6 = __toESM(require("fs"));

// node_modules/is-unicode-supported/index.js
var import_node_process2 = __toESM(require("node:process"), 1);
function isUnicodeSupported() {
  if (import_node_process2.default.platform !== "win32") {
    return import_node_process2.default.env.TERM !== "linux";
  }
  return Boolean(import_node_process2.default.env.WT_SESSION) || Boolean(import_node_process2.default.env.TERMINUS_SUBLIME) || import_node_process2.default.env.ConEmuTask === "{cmd::Cmder}" || import_node_process2.default.env.TERM_PROGRAM === "Terminus-Sublime" || import_node_process2.default.env.TERM_PROGRAM === "vscode" || import_node_process2.default.env.TERM === "xterm-256color" || import_node_process2.default.env.TERM === "alacritty" || import_node_process2.default.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/figures/index.js
var common = {
  circleQuestionMark: "(?)",
  questionMarkPrefix: "(?)",
  square: "\u2588",
  squareDarkShade: "\u2593",
  squareMediumShade: "\u2592",
  squareLightShade: "\u2591",
  squareTop: "\u2580",
  squareBottom: "\u2584",
  squareLeft: "\u258C",
  squareRight: "\u2590",
  squareCenter: "\u25A0",
  bullet: "\u25CF",
  dot: "\u2024",
  ellipsis: "\u2026",
  pointerSmall: "\u203A",
  triangleUp: "\u25B2",
  triangleUpSmall: "\u25B4",
  triangleDown: "\u25BC",
  triangleDownSmall: "\u25BE",
  triangleLeftSmall: "\u25C2",
  triangleRightSmall: "\u25B8",
  home: "\u2302",
  heart: "\u2665",
  musicNote: "\u266A",
  musicNoteBeamed: "\u266B",
  arrowUp: "\u2191",
  arrowDown: "\u2193",
  arrowLeft: "\u2190",
  arrowRight: "\u2192",
  arrowLeftRight: "\u2194",
  arrowUpDown: "\u2195",
  almostEqual: "\u2248",
  notEqual: "\u2260",
  lessOrEqual: "\u2264",
  greaterOrEqual: "\u2265",
  identical: "\u2261",
  infinity: "\u221E",
  subscriptZero: "\u2080",
  subscriptOne: "\u2081",
  subscriptTwo: "\u2082",
  subscriptThree: "\u2083",
  subscriptFour: "\u2084",
  subscriptFive: "\u2085",
  subscriptSix: "\u2086",
  subscriptSeven: "\u2087",
  subscriptEight: "\u2088",
  subscriptNine: "\u2089",
  oneHalf: "\xBD",
  oneThird: "\u2153",
  oneQuarter: "\xBC",
  oneFifth: "\u2155",
  oneSixth: "\u2159",
  oneEighth: "\u215B",
  twoThirds: "\u2154",
  twoFifths: "\u2156",
  threeQuarters: "\xBE",
  threeFifths: "\u2157",
  threeEighths: "\u215C",
  fourFifths: "\u2158",
  fiveSixths: "\u215A",
  fiveEighths: "\u215D",
  sevenEighths: "\u215E",
  line: "\u2500",
  lineBold: "\u2501",
  lineDouble: "\u2550",
  lineDashed0: "\u2504",
  lineDashed1: "\u2505",
  lineDashed2: "\u2508",
  lineDashed3: "\u2509",
  lineDashed4: "\u254C",
  lineDashed5: "\u254D",
  lineDashed6: "\u2574",
  lineDashed7: "\u2576",
  lineDashed8: "\u2578",
  lineDashed9: "\u257A",
  lineDashed10: "\u257C",
  lineDashed11: "\u257E",
  lineDashed12: "\u2212",
  lineDashed13: "\u2013",
  lineDashed14: "\u2010",
  lineDashed15: "\u2043",
  lineVertical: "\u2502",
  lineVerticalBold: "\u2503",
  lineVerticalDouble: "\u2551",
  lineVerticalDashed0: "\u2506",
  lineVerticalDashed1: "\u2507",
  lineVerticalDashed2: "\u250A",
  lineVerticalDashed3: "\u250B",
  lineVerticalDashed4: "\u254E",
  lineVerticalDashed5: "\u254F",
  lineVerticalDashed6: "\u2575",
  lineVerticalDashed7: "\u2577",
  lineVerticalDashed8: "\u2579",
  lineVerticalDashed9: "\u257B",
  lineVerticalDashed10: "\u257D",
  lineVerticalDashed11: "\u257F",
  lineDownLeft: "\u2510",
  lineDownLeftArc: "\u256E",
  lineDownBoldLeftBold: "\u2513",
  lineDownBoldLeft: "\u2512",
  lineDownLeftBold: "\u2511",
  lineDownDoubleLeftDouble: "\u2557",
  lineDownDoubleLeft: "\u2556",
  lineDownLeftDouble: "\u2555",
  lineDownRight: "\u250C",
  lineDownRightArc: "\u256D",
  lineDownBoldRightBold: "\u250F",
  lineDownBoldRight: "\u250E",
  lineDownRightBold: "\u250D",
  lineDownDoubleRightDouble: "\u2554",
  lineDownDoubleRight: "\u2553",
  lineDownRightDouble: "\u2552",
  lineUpLeft: "\u2518",
  lineUpLeftArc: "\u256F",
  lineUpBoldLeftBold: "\u251B",
  lineUpBoldLeft: "\u251A",
  lineUpLeftBold: "\u2519",
  lineUpDoubleLeftDouble: "\u255D",
  lineUpDoubleLeft: "\u255C",
  lineUpLeftDouble: "\u255B",
  lineUpRight: "\u2514",
  lineUpRightArc: "\u2570",
  lineUpBoldRightBold: "\u2517",
  lineUpBoldRight: "\u2516",
  lineUpRightBold: "\u2515",
  lineUpDoubleRightDouble: "\u255A",
  lineUpDoubleRight: "\u2559",
  lineUpRightDouble: "\u2558",
  lineUpDownLeft: "\u2524",
  lineUpBoldDownBoldLeftBold: "\u252B",
  lineUpBoldDownBoldLeft: "\u2528",
  lineUpDownLeftBold: "\u2525",
  lineUpBoldDownLeftBold: "\u2529",
  lineUpDownBoldLeftBold: "\u252A",
  lineUpDownBoldLeft: "\u2527",
  lineUpBoldDownLeft: "\u2526",
  lineUpDoubleDownDoubleLeftDouble: "\u2563",
  lineUpDoubleDownDoubleLeft: "\u2562",
  lineUpDownLeftDouble: "\u2561",
  lineUpDownRight: "\u251C",
  lineUpBoldDownBoldRightBold: "\u2523",
  lineUpBoldDownBoldRight: "\u2520",
  lineUpDownRightBold: "\u251D",
  lineUpBoldDownRightBold: "\u2521",
  lineUpDownBoldRightBold: "\u2522",
  lineUpDownBoldRight: "\u251F",
  lineUpBoldDownRight: "\u251E",
  lineUpDoubleDownDoubleRightDouble: "\u2560",
  lineUpDoubleDownDoubleRight: "\u255F",
  lineUpDownRightDouble: "\u255E",
  lineDownLeftRight: "\u252C",
  lineDownBoldLeftBoldRightBold: "\u2533",
  lineDownLeftBoldRightBold: "\u252F",
  lineDownBoldLeftRight: "\u2530",
  lineDownBoldLeftBoldRight: "\u2531",
  lineDownBoldLeftRightBold: "\u2532",
  lineDownLeftRightBold: "\u252E",
  lineDownLeftBoldRight: "\u252D",
  lineDownDoubleLeftDoubleRightDouble: "\u2566",
  lineDownDoubleLeftRight: "\u2565",
  lineDownLeftDoubleRightDouble: "\u2564",
  lineUpLeftRight: "\u2534",
  lineUpBoldLeftBoldRightBold: "\u253B",
  lineUpLeftBoldRightBold: "\u2537",
  lineUpBoldLeftRight: "\u2538",
  lineUpBoldLeftBoldRight: "\u2539",
  lineUpBoldLeftRightBold: "\u253A",
  lineUpLeftRightBold: "\u2536",
  lineUpLeftBoldRight: "\u2535",
  lineUpDoubleLeftDoubleRightDouble: "\u2569",
  lineUpDoubleLeftRight: "\u2568",
  lineUpLeftDoubleRightDouble: "\u2567",
  lineUpDownLeftRight: "\u253C",
  lineUpBoldDownBoldLeftBoldRightBold: "\u254B",
  lineUpDownBoldLeftBoldRightBold: "\u2548",
  lineUpBoldDownLeftBoldRightBold: "\u2547",
  lineUpBoldDownBoldLeftRightBold: "\u254A",
  lineUpBoldDownBoldLeftBoldRight: "\u2549",
  lineUpBoldDownLeftRight: "\u2540",
  lineUpDownBoldLeftRight: "\u2541",
  lineUpDownLeftBoldRight: "\u253D",
  lineUpDownLeftRightBold: "\u253E",
  lineUpBoldDownBoldLeftRight: "\u2542",
  lineUpDownLeftBoldRightBold: "\u253F",
  lineUpBoldDownLeftBoldRight: "\u2543",
  lineUpBoldDownLeftRightBold: "\u2544",
  lineUpDownBoldLeftBoldRight: "\u2545",
  lineUpDownBoldLeftRightBold: "\u2546",
  lineUpDoubleDownDoubleLeftDoubleRightDouble: "\u256C",
  lineUpDoubleDownDoubleLeftRight: "\u256B",
  lineUpDownLeftDoubleRightDouble: "\u256A",
  lineCross: "\u2573",
  lineBackslash: "\u2572",
  lineSlash: "\u2571"
};
var mainSymbols = {
  ...common,
  tick: "\u2714",
  info: "\u2139",
  warning: "\u26A0",
  cross: "\u2718",
  squareSmall: "\u25FB",
  squareSmallFilled: "\u25FC",
  circle: "\u25EF",
  circleFilled: "\u25C9",
  circleDotted: "\u25CC",
  circleDouble: "\u25CE",
  circleCircle: "\u24DE",
  circleCross: "\u24E7",
  circlePipe: "\u24BE",
  radioOn: "\u25C9",
  radioOff: "\u25EF",
  checkboxOn: "\u2612",
  checkboxOff: "\u2610",
  checkboxCircleOn: "\u24E7",
  checkboxCircleOff: "\u24BE",
  pointer: "\u276F",
  triangleUpOutline: "\u25B3",
  triangleLeft: "\u25C0",
  triangleRight: "\u25B6",
  lozenge: "\u25C6",
  lozengeOutline: "\u25C7",
  hamburger: "\u2630",
  smiley: "\u32E1",
  mustache: "\u0DF4",
  star: "\u2605",
  play: "\u25B6",
  nodejs: "\u2B22",
  oneSeventh: "\u2150",
  oneNinth: "\u2151",
  oneTenth: "\u2152"
};
var fallbackSymbols = {
  ...common,
  tick: "\u221A",
  info: "i",
  warning: "\u203C",
  cross: "\xD7",
  squareSmall: "\u25A1",
  squareSmallFilled: "\u25A0",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "(\u25CB)",
  circleCross: "(\xD7)",
  circlePipe: "(\u2502)",
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[\xD7]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "(\xD7)",
  checkboxCircleOff: "( )",
  pointer: ">",
  triangleUpOutline: "\u2206",
  triangleLeft: "\u25C4",
  triangleRight: "\u25BA",
  lozenge: "\u2666",
  lozengeOutline: "\u25CA",
  hamburger: "\u2261",
  smiley: "\u263A",
  mustache: "\u250C\u2500\u2510",
  star: "\u2736",
  play: "\u25BA",
  nodejs: "\u2666",
  oneSeventh: "1/7",
  oneNinth: "1/9",
  oneTenth: "1/10"
};
var shouldUseMain = isUnicodeSupported();
var figures = shouldUseMain ? mainSymbols : fallbackSymbols;
var figures_default = figures;
var replacements = Object.entries(mainSymbols).filter(([key, mainSymbol]) => fallbackSymbols[key] !== mainSymbol);

// bin/mcb/AppMain.js
var Chokidar = __toESM(require_chokidar());
var $global79 = Register.$global;
var AppMain = Register.global("$hxClasses")["mcb.AppMain"] = class AppMain2 {
  static loadDebugProject(file, outdir) {
    let reader = new Unserializer(Fs6.readFileSync(file, { "encoding": "utf8" }));
    while (true) {
      let item = reader.unserialize();
      if (item == null) {
        break;
      }
      ;
      let p = Path2.join([outdir, item.f]);
      FileSystem.createDirectory(Path2.directory(p));
      Fs6.writeFileSync(p, item.s);
      Fs6.writeFileSync(p + ".tokens", Std.string(item.t));
      Fs6.writeFileSync(p + ".ast", Std.string(item.a));
    }
    ;
  }
  static discoverConfigFile(p) {
    if (FileSystem.exists(p + ".cjs")) {
      return p + ".cjs";
    } else if (FileSystem.exists(p + ".js")) {
      return p + ".js";
    } else if (FileSystem.exists(p + ".json")) {
      return p + ".json";
    } else {
      return p;
    }
    ;
  }
  static getFilesInDirectory(dir) {
    let files = Fs6.readdirSync(dir);
    let result = [];
    let _g = 0;
    while (_g < files.length) {
      let f = files[_g];
      ++_g;
      let p = Path2.join([dir, f]);
      if (FileSystem.isDirectory(p)) {
        result = result.concat(AppMain2.getFilesInDirectory(p));
      } else {
        result.push(p);
      }
      ;
    }
    ;
    return result;
  }
  static create(name) {
    let templateDir = Path2.join([Path2.directory(__filename), "template"]);
    let destDir = Path2.join([Path2.addTrailingSlash(process.cwd()), name]);
    FileSystem.createDirectory(destDir);
    let fetcher = new HttpNodeJs("https://raw.githubusercontent.com/misode/mcmeta/summary/version.json");
    fetcher.onData = function(data) {
      let version = JSON.parse(data);
      let copyDir = null;
      copyDir = function(from, to) {
        let _g = 0;
        let _g1 = Fs6.readdirSync(from);
        while (_g < _g1.length) {
          let f = _g1[_g];
          ++_g;
          let fromPath = Path2.join([from, f]);
          let toPath = Path2.join([to, f]);
          if (FileSystem.isDirectory(fromPath)) {
            FileSystem.createDirectory(toPath);
            copyDir(fromPath, toPath);
          } else {
            let template = new Template(Fs6.readFileSync(fromPath, { "encoding": "utf8" }));
            let copyDir2 = name == null;
            Fs6.writeFileSync(toPath, template.execute({ "name": name, "version": version.data_pack_version }));
          }
          ;
        }
        ;
      };
      copyDir(templateDir, destDir);
    };
    fetcher.request();
  }
  static compile(opts) {
    Logger.log("Started build at " + HxOverrides.dateStr(/* @__PURE__ */ new Date()));
    let startTime = Date.now() / 1e3;
    let srcDir = Path2.join([opts.baseDir, "src"]);
    let configPath = AppMain2.discoverConfigFile(opts.configPath);
    let config;
    if (Fs6.existsSync(configPath)) {
      try {
        config = require(configPath);
      } catch (_g) {
        let e = Exception.caught(_g);
        Logger.error("Failed to load config file: " + configPath);
        throw Exception.thrown(e);
      }
      ;
    } else {
      Logger.warn("Config file not found, using default config.");
      config = {};
    }
    ;
    let compiler = new Compiler(srcDir, config, new LibStore(opts.libDir));
    let didFail = true;
    try {
      compiler.config.events.onPreBuild.dispatch({});
      let sourceFiles = AppMain2.getFilesInDirectory(srcDir);
      let _g = 0;
      while (_g < sourceFiles.length) {
        let f = sourceFiles[_g];
        ++_g;
        let ext = Path2.extension(f);
        if (ext != "mcb" && ext != "mcbt") {
          continue;
        }
        ;
        let tokens = Tokenizer.tokenize(Fs6.readFileSync(f, { "encoding": "utf8" }), f);
        try {
          let ast = ext == "mcb" ? Parser.parseMcbFile(tokens) : Parser.parseMcbtFile(tokens);
          compiler.addFile(f, ast);
        } catch (_g2) {
          let e = Exception.caught(_g2).unwrap();
          compiler.success = false;
          throw Exception.thrown(e);
        }
        ;
      }
      ;
      let _g1 = new StringMap();
      _g1.inst.set("config", config);
      _g1.inst.set("global", AppMain2.globalJsData);
      _g1.inst.set("store", {});
      compiler.compile(new VariableMap(null, _g1));
      didFail = false;
    } catch (_g) {
      let e = Exception.caught(_g).unwrap();
      didFail = true;
      if (McbError.isMclError(e)) {
        let x = e;
        Logger.error(x.get_message());
      } else {
        Logger.error("A fatal error occurred during compilation. Please report this to the developers.");
        throw Exception.thrown(e);
      }
      ;
    }
    ;
    compiler.config.events.onPostBuild.dispatch({ "success": !didFail });
    let endTime = Date.now() / 1e3;
    Logger.log("Build finished in " + (endTime - startTime).toFixed(2) + " seconds");
    return compiler;
  }
  static doBuild(opts) {
    TemplateRegisterer.register();
    AppMain2.watch = opts.watch;
    let cacheFile = Path2.join([opts.baseDir, ".mcb", "fs-cache.txt"]);
    let cache;
    if (FileSystem.exists(cacheFile)) {
      let _g = new StringMap();
      let _g1 = 0;
      let _this = Fs6.readFileSync(cacheFile, { "encoding": "utf8" }).split("\n");
      let result = new Array(_this.length);
      let _g2 = 0;
      let _g3 = _this.length;
      while (_g2 < _g3) {
        let i = _g2++;
        result[i] = _this[i].split(":");
      }
      ;
      let _g4 = result;
      while (_g1 < _g4.length) {
        let e = _g4[_g1];
        ++_g1;
        if (e[0] != "") {
          _g.inst.set(e[0], e[1]);
        }
        ;
      }
      ;
      cache = _g;
    } else {
      cache = new StringMap();
    }
    ;
    let writeCache = function() {
      FileSystem.createDirectory(Path2.directory(cacheFile));
      let _g = [];
      let map = cache;
      let _g_map = map;
      let _g_keys = map.keys();
      while (_g_keys.hasNext()) {
        let key = _g_keys.next();
        let _g_value = _g_map.get(key);
        let _g_key = key;
        let k = _g_key;
        let v = _g_value;
        _g.push("" + k + ":" + v);
      }
      ;
      let content = _g.join("\n");
      Fs6.writeFileSync(cacheFile, content);
    };
    let handleUpdatingFilesBasedOnCache = function(io) {
      let added = io.reportFilesAdded(cache);
      let removed = io.reportFilesRemoved(cache);
      let changed = io.reportFilesChanged(cache);
      let dirsToCheck = /* @__PURE__ */ new Set();
      let _g = 0;
      while (_g < removed.length) {
        let f = removed[_g];
        ++_g;
        if (FileSystem.exists(f)) {
          Fs6.unlinkSync(f);
        }
        ;
        dirsToCheck.add(Path2.directory(f));
      }
      ;
      let _g1 = [];
      let jsIterator = dirsToCheck.values();
      let _g_jsIterator = jsIterator;
      let _g_lastStep = jsIterator.next();
      while (!_g_lastStep.done) {
        let v = _g_lastStep.value;
        _g_lastStep = _g_jsIterator.next();
        let k = v;
        _g1.push(k);
      }
      ;
      let dirList = _g1;
      let deletedDirs = /* @__PURE__ */ new Set();
      let _g2 = 0;
      while (_g2 < dirList.length) {
        let dir = dirList[_g2];
        ++_g2;
        if (dir != "" && !deletedDirs.has(dir) && Fs6.readdirSync(dir).length == 0) {
          if (FileSystem.exists(dir)) {
            let _g3 = 0;
            let _g12 = Fs6.readdirSync(dir);
            while (_g3 < _g12.length) {
              let file = _g12[_g3];
              ++_g3;
              let curPath = dir + "/" + file;
              if (FileSystem.isDirectory(curPath)) {
                if (FileSystem.exists(curPath)) {
                  let _g4 = 0;
                  let _g13 = Fs6.readdirSync(curPath);
                  while (_g4 < _g13.length) {
                    let file2 = _g13[_g4];
                    ++_g4;
                    let curPath1 = curPath + "/" + file2;
                    if (FileSystem.isDirectory(curPath1)) {
                      FileSystem.deleteDirectory(curPath1);
                    } else {
                      Fs6.unlinkSync(curPath1);
                    }
                    ;
                  }
                  ;
                  Fs6.rmdirSync(curPath);
                }
                ;
              } else {
                Fs6.unlinkSync(curPath);
              }
              ;
            }
            ;
            Fs6.rmdirSync(dir);
          }
          ;
          dirList.push(Path2.join([dir, ".."]));
          deletedDirs.add(dir);
        }
        ;
      }
      ;
      Logger.log("" + AppMain2.chars.arrowUp + " Added: " + added.length);
      Logger.log("" + AppMain2.chars.arrowDown + " Removed: " + removed.length);
      Logger.log("" + AppMain2.chars.arrowRight + " Changed: " + changed.length);
      cache = io.reportFileMetadata();
      writeCache();
    };
    let build = AppMain2.compile(opts);
    if (build.success) {
      handleUpdatingFilesBasedOnCache(build.io);
    } else if (build.io instanceof SyncIo) {
      let x = build.io;
      Logger.warn("Reverting file changes...");
      x.revertMap.revert();
    }
    ;
    if (opts.watch) {
      Logger.log("Watch mode enabled, Watching for changes...");
      let watcher = Chokidar.watch(["src/**"], { "ignoreInitial": true });
      let handleFsEvent = function() {
        Logger.log("File change detected, recompiling...");
        let compiler = AppMain2.compile(opts);
        if (compiler.success) {
          handleUpdatingFilesBasedOnCache(compiler.io);
        } else if (compiler.io instanceof SyncIo) {
          let x = compiler.io;
          Logger.warn("Reverting file changes...");
          x.revertMap.revert();
        }
        ;
        Logger.log("Watching for changes...");
      };
      watcher.on("change", handleFsEvent);
      watcher.on("add", handleFsEvent);
      watcher.on("unlink", handleFsEvent);
    }
    ;
  }
  static generate(outfile, arg) {
    let configPath = AppMain2.discoverConfigFile(arg.configPath);
    let config;
    if (Fs6.existsSync(configPath)) {
      try {
        config = require(configPath);
      } catch (_g2) {
        let e = Exception.caught(_g2);
        Logger.error("Failed to load config file: " + configPath);
        throw Exception.thrown(e);
      }
      ;
    } else {
      Logger.warn("Config file not found, using default config.");
      config = {};
    }
    ;
    let compiler = new Compiler(arg.baseDir, config, new LibStore(arg.libDir));
    let tokens = Tokenizer.tokenize(Fs6.readFileSync(outfile, { "encoding": "utf8" }), outfile);
    let ast = Parser.parseMcbFile(tokens);
    compiler.addFile(outfile, ast);
    let _g = new StringMap();
    _g.inst.set("config", config);
    _g.inst.set("global", AppMain2.globalJsData);
    _g.inst.set("store", {});
    compiler.transform(new VariableMap(null, _g));
  }
  static get __name__() {
    return "mcb.AppMain";
  }
  get __class__() {
    return AppMain2;
  }
};
AppMain.globalJsData = {};
AppMain.watch = false;
AppMain.chars = figures_default;

// bin/mcb/Cli.js
var $global80 = Register.$global;
var Cli = Register.global("$hxClasses")["mcb.Cli"] = class Cli2 extends Register.inherits(CommandLine) {
  new() {
    this.didRun = false;
    this.libPath = Path2.join([Path2.directory(__filename), "./.mcblib"]);
    this.baseDir = Path2.addTrailingSlash(process.cwd());
    this.configPath = Path2.join([this.baseDir, "./mcb.config"]);
    this.ioThreadCount = 0;
    super.new();
  }
  create(packName) {
    this.didRun = true;
    AppMain.create(packName);
  }
  build() {
    this.didRun = true;
    AppMain.doBuild({ "watch": false, "libDir": this.libPath, "baseDir": this.baseDir, "configPath": this.configPath });
  }
  generate(outfile) {
    this.didRun = true;
    AppMain.generate(outfile, { "libDir": this.libPath, "baseDir": this.baseDir, "configPath": this.configPath });
  }
  help() {
    process.stdout.write("MCB - A Minecraft Data Pack build tool.");
    process.stdout.write("\n");
    process.stdout.write("");
    process.stdout.write("\n");
    process.stdout.write("Usage:");
    process.stdout.write("\n");
    process.stdout.write("mcb build");
    process.stdout.write("\n");
    process.stdout.write("mcb watch");
    process.stdout.write("\n");
    process.stdout.write("mcb create <pack-name>");
    process.stdout.write("\n");
    process.stdout.write("mcb venv setup <name>");
    process.stdout.write("\n");
    process.stdout.write("mcb venv activate");
    process.stdout.write("\n");
    process.stdout.write("mcb generate");
    process.stdout.write("\n");
    process.stdout.write("");
    process.stdout.write("\n");
    process.stdout.write("Flags:");
    process.stdout.write("\n");
    let v = this.showUsage();
    process.stdout.write(Std.string(v));
    process.stdout.write("\n");
    process.exit(0);
  }
  runDefault(mode, venvAction, venvName) {
    if (this.didRun) {
      return;
    }
    ;
    if (mode == null) {
      this.help();
    } else {
      switch (mode) {
        case "build":
          this.build();
          break;
        case "create":
          this.create(venvAction);
          break;
        case "generate":
          this.generate(venvAction);
          break;
        case "venv":
          switch (venvAction) {
            case "activate":
              Venv.activate();
              break;
            case "setup":
              Venv.create(venvName);
              break;
          }
          ;
          break;
        case "watch":
          this.watch();
          break;
        default:
          this.help();
      }
      ;
    }
    ;
  }
  venv(action, name) {
    this.didRun = true;
    switch (action) {
      case "activate":
        Venv.activate();
        break;
      case "setup":
        Venv.create(name);
        break;
    }
    ;
  }
  watch() {
    this.didRun = true;
    AppMain.doBuild({ "watch": true, "libDir": this.libPath, "baseDir": this.baseDir, "configPath": this.configPath });
  }
  init(name) {
    this.didRun = true;
  }
  getArguments() {
    return Cli2.ARGUMENTS.concat(super.getArguments());
  }
  static main() {
    new Dispatch(process.argv.slice(2)).dispatch(new Cli2());
  }
  static get __name__() {
    return "mcb.Cli";
  }
  static get __super__() {
    return CommandLine;
  }
  get __class__() {
    return Cli2;
  }
};
Cli.ARGUMENTS = [{ "name": "libPath", "description": null, "command": "libPath", "kind": Kind.Var("String"), "aliases": [] }, { "name": "baseDir", "description": null, "command": "baseDir", "kind": Kind.Var("String"), "aliases": [] }, { "name": "configPath", "description": null, "command": "configPath", "kind": Kind.Var("String"), "aliases": [] }, { "name": "ioThreadCount", "description": null, "command": "ioThreadCount", "kind": Kind.Var("Int"), "aliases": [] }, { "name": "create", "description": null, "command": "create", "kind": Kind.Function([{ "name": "packName", "t": "String", "opt": false }], null), "aliases": [] }, { "name": "build", "description": null, "command": "build", "kind": Kind.Function([], null), "aliases": [] }, { "name": "generate", "description": null, "command": "generate", "kind": Kind.Function([{ "name": "outfile", "t": "String", "opt": false }], null), "aliases": [] }, { "name": "help", "description": null, "command": "help", "kind": Kind.Function([], null), "aliases": [] }, { "name": "runDefault", "description": null, "command": "runDefault", "kind": Kind.Function([{ "name": "mode", "t": "String", "opt": true }, { "name": "venvAction", "t": "String", "opt": true }, { "name": "venvName", "t": "String", "opt": true }], null), "aliases": [] }, { "name": "venv", "description": null, "command": "venv", "kind": Kind.Function([{ "name": "action", "t": "String", "opt": true }, { "name": "name", "t": "String", "opt": true }], null), "aliases": [] }, { "name": "watch", "description": null, "command": "watch", "kind": Kind.Function([], null), "aliases": [] }, { "name": "init", "description": null, "command": "init", "kind": Kind.Function([{ "name": "name", "t": "String", "opt": false }], null), "aliases": [] }];

// bin/mcb.js
var $global81 = Register.$global;
Cli.main();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AppMain,
  Compiler,
  Globals,
  MultiThreadIo,
  Parser,
  RevertTracker,
  SyncIo,
  TemplateArgument,
  ThreadedIo,
  Tokenizer
});
/*! Bundled license information:

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
*/
